<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    
<!-- Baidu Tongji -->
<script>var _hmt = _hmt || []</script>
<script async src="//hm.baidu.com/hm.js?72795d00f0f8823340c6bba6d9a8e7b2"></script>
<!-- End Baidu Tongji -->




    <meta charset="utf-8">
    
    
    
    
    <title>精华篇-01.高频考点知识 | 陈亚的个人主页</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="前端知识体系,高频考点,精华篇">
    <meta name="description" content="1 typeof类型判断 typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么   typeof 对于原始类型来说，除了 null 都可以显示正确的类型  typeof 1 // &apos;number&apos; typeof &apos;1&apos; // &apos;string&apos; typeof undefined // &apos;undefined&apos; typeof true // &apos;boolean&apos; typeof">
<meta name="keywords" content="前端知识体系,高频考点,精华篇">
<meta property="og:type" content="article">
<meta property="og:title" content="精华篇-01.高频考点知识">
<meta property="og:url" content="http://www.chenya.site/2017/06/04/002.前端知识体系/005.精华篇/001.精华篇之高频考点知识/index.html">
<meta property="og:site_name" content="陈亚的个人主页">
<meta property="og:description" content="1 typeof类型判断 typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么   typeof 对于原始类型来说，除了 null 都可以显示正确的类型  typeof 1 // &apos;number&apos; typeof &apos;1&apos; // &apos;string&apos; typeof undefined // &apos;undefined&apos; typeof true // &apos;boolean&apos; typeof">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1480597-c1ede6d7eb711a22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1480597-ce6e82dfdc1b3415.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1480597-88daf8ffd440c0dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/16/1671d387e4189ec8">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/19/1672aeb24a2e2cae">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/19/1672afb8dfa21361">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/13/1670d2d20ead32ec">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/13/1670c0e21540090c">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/13/1670c128acce975f">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/23/16740fa4cd9c6937">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/14/16710fb80dd42d27">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/3/28/1626b1e8eba68e1c">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/3/28/1626b20dfc4fcd26">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/3/28/1626b20e4f8f3257">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/5/1677db8003dc8311">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/6/1678234a1ed20487">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/5/1677ef2cd7bf1bba">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/6/16782357baddf1c6">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/27/16754281e59587f3">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/27/16754288f37a5347">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/27/167540a7b5cef612">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/27/1675416cbea98c3c">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/27/167542b09875a74a">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/27/167542a9af5f193f">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/11/27/16754488529c48bd">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/15/167b1c6887ecbba7">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/3/29/1626fb6f33a6f9d7">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1480597-4d0534470dcfe615.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/2/1676d5e1a09c8367">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/2/1676d8215a3d1f5b">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1480597-e2fd2624a105fce7.png">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/3/16772c479b194d48">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/3/16772c52e83d97c7">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/3/16772ca3d13a68ab">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/3/16772cae50f7eb81">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/3/16772cbdcdaccf15">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/3/16772cf78a4fa18f">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/3/167736409eebe688">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/3/16773b904cfb732f">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/4/16778338eb8b7130">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/20/167cad938817eb7e">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/21/167ced454926a458">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/12/21/167cf01bd8430243">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/6/25/164358b0310f476c">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/6/25/164358f89595d56f">
<meta property="og:updated_time" content="2019-09-16T01:57:01.494Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="精华篇-01.高频考点知识">
<meta name="twitter:description" content="1 typeof类型判断 typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么   typeof 对于原始类型来说，除了 null 都可以显示正确的类型  typeof 1 // &apos;number&apos; typeof &apos;1&apos; // &apos;string&apos; typeof undefined // &apos;undefined&apos; typeof true // &apos;boolean&apos; typeof">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/1480597-c1ede6d7eb711a22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    
        <link rel="alternate" type="application/atom+xml" title="陈亚的个人主页" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<link rel="stylesheet" href="/css/prism-pojoaque.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/gruffalo.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">陈亚</h5>
          <a href="mailto:1123236324@qq.com" title="1123236324@qq.com" class="mail">1123236324@qq.com</a>
          <div style="margin-top: 5px; margin-bottom: 5px; font-size: 92%"><b>文章共 89 篇，约 202.5k 字</b></div>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/前端知识体系"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/学习笔记"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/works/"  >
                <i class="icon icon-lg icon-file-code-o"></i>
                作品
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about/"  >
                <i class="icon icon-lg icon-address-card"></i>
                关于我
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.cnblogs.com/chenyablog" target="_blank" >
                <i class="icon icon-lg icon-edit"></i>
                博客
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/chenya1123236324" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div id="headerTitle" class="flex-col header-title ellipsis">精华篇-01.高频考点知识</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="themeToggle" title="夜间模式">
            <i class="icon icon-lg icon-moon-o"></i>
        </a>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">精华篇-01.高频考点知识</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-06-04T14:52:06.000Z" itemprop="datePublished" class="page-time">
  2017-06-04
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/学习笔记/">学习笔记</a></li></ul>

            
        </h5>
    </div>

    <div class="grass fade-scale">

    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-typeof类型判断"><span class="post-toc-number">1.</span> <span class="post-toc-text">1 typeof类型判断</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-类型转换"><span class="post-toc-number">2.</span> <span class="post-toc-text">2 类型转换</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-This"><span class="post-toc-number">3.</span> <span class="post-toc-text">3 This</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-和-有什么区别"><span class="post-toc-number">4.</span> <span class="post-toc-text">4 == 和 === 有什么区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-闭包"><span class="post-toc-number">5.</span> <span class="post-toc-text">5 闭包</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-深浅拷贝"><span class="post-toc-number">6.</span> <span class="post-toc-text">6 深浅拷贝</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-原型"><span class="post-toc-number">7.</span> <span class="post-toc-text">7 原型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-var、let-及-const-区别"><span class="post-toc-number">8.</span> <span class="post-toc-text">8 var、let 及 const 区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-原型继承和-Class-继承"><span class="post-toc-number">9.</span> <span class="post-toc-text">9 原型继承和 Class 继承</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#10-模块化"><span class="post-toc-number">10.</span> <span class="post-toc-text">10 模块化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#11-实现一个简洁版的promise"><span class="post-toc-number">11.</span> <span class="post-toc-text">11 实现一个简洁版的promise</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#12-Event-Loop"><span class="post-toc-number">12.</span> <span class="post-toc-text">12 Event Loop</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#12-1-进程与线程"><span class="post-toc-number">12.1.</span> <span class="post-toc-text">12.1 进程与线程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#12-2-执行栈"><span class="post-toc-number">12.2.</span> <span class="post-toc-text">12.2 执行栈</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#12-3-浏览器中的-Event-Loop"><span class="post-toc-number">12.3.</span> <span class="post-toc-text">12.3 浏览器中的 Event Loop</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#12-4-Node-中的-Event-loop"><span class="post-toc-number">12.4.</span> <span class="post-toc-text">12.4 Node 中的 Event loop</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#13-手写-call、apply-及-bind-函数"><span class="post-toc-number">13.</span> <span class="post-toc-text">13 手写 call、apply 及 bind 函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#14-new"><span class="post-toc-number">14.</span> <span class="post-toc-text">14 new</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#15-instanceof-的原理"><span class="post-toc-number">15.</span> <span class="post-toc-text">15 instanceof 的原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#16-为什么-0-1-0-2-0-3"><span class="post-toc-number">16.</span> <span class="post-toc-text">16 为什么 0.1 + 0.2 != 0.3</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#17-事件机制"><span class="post-toc-number">17.</span> <span class="post-toc-text">17 事件机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#17-1-事件触发三阶段"><span class="post-toc-number">17.1.</span> <span class="post-toc-text">17.1 事件触发三阶段</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#17-2-注册事件"><span class="post-toc-number">17.2.</span> <span class="post-toc-text">17.2 注册事件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#17-3-事件代理"><span class="post-toc-number">17.3.</span> <span class="post-toc-text">17.3 事件代理</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#18-跨域"><span class="post-toc-number">18.</span> <span class="post-toc-text">18 跨域</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#18-1-JSONP"><span class="post-toc-number">18.1.</span> <span class="post-toc-text">18.1 JSONP</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#18-2-CORS"><span class="post-toc-number">18.2.</span> <span class="post-toc-text">18.2 CORS</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#18-3-document-domain"><span class="post-toc-number">18.3.</span> <span class="post-toc-text">18.3 document.domain</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#18-4-postMessage"><span class="post-toc-number">18.4.</span> <span class="post-toc-text">18.4 postMessage</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#19-存储"><span class="post-toc-number">19.</span> <span class="post-toc-text">19 存储</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#20-浏览器缓存机制"><span class="post-toc-number">20.</span> <span class="post-toc-text">20 浏览器缓存机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#20-1-缓存位置"><span class="post-toc-number">20.1.</span> <span class="post-toc-text">20.1 缓存位置</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#20-2-缓存策略"><span class="post-toc-number">20.2.</span> <span class="post-toc-text">20.2 缓存策略</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#20-2-1-强缓存"><span class="post-toc-number">20.2.1.</span> <span class="post-toc-text">20.2.1 强缓存</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#20-2-2-协商缓存"><span class="post-toc-number">20.2.2.</span> <span class="post-toc-text">20.2.2 协商缓存</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#20-3-实际场景应用缓存策略"><span class="post-toc-number">20.3.</span> <span class="post-toc-text">20.3 实际场景应用缓存策略</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#21-浏览器渲染原理"><span class="post-toc-number">21.</span> <span class="post-toc-text">21 浏览器渲染原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#21-1-渲染过程"><span class="post-toc-number">21.1.</span> <span class="post-toc-text">21.1 渲染过程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#21-2-为什么操作-DOM-慢"><span class="post-toc-number">21.2.</span> <span class="post-toc-text">21.2 为什么操作 DOM 慢</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#21-3-什么情况阻塞渲染"><span class="post-toc-number">21.3.</span> <span class="post-toc-text">21.3 什么情况阻塞渲染</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#21-4-重绘（Repaint）和回流（Reflow）"><span class="post-toc-number">21.4.</span> <span class="post-toc-text">21.4 重绘（Repaint）和回流（Reflow）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#21-5-减少重绘和回流"><span class="post-toc-number">21.5.</span> <span class="post-toc-text">21.5 减少重绘和回流</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#22-安全防范"><span class="post-toc-number">22.</span> <span class="post-toc-text">22 安全防范</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#22-1-XSS"><span class="post-toc-number">22.1.</span> <span class="post-toc-text">22.1 XSS</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#22-2-CSRF"><span class="post-toc-number">22.2.</span> <span class="post-toc-text">22.2 CSRF</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#22-3-点击劫持"><span class="post-toc-number">22.3.</span> <span class="post-toc-text">22.3 点击劫持</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#23-从-V8-中看-JS-性能优化"><span class="post-toc-number">23.</span> <span class="post-toc-text">23 从 V8 中看 JS 性能优化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#23-1-测试性能工具"><span class="post-toc-number">23.1.</span> <span class="post-toc-text">23.1 测试性能工具</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#23-2-JS-性能优化"><span class="post-toc-number">23.2.</span> <span class="post-toc-text">23.2 JS 性能优化</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#24-性能优化"><span class="post-toc-number">24.</span> <span class="post-toc-text">24 性能优化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#24-1-图片优化"><span class="post-toc-number">24.1.</span> <span class="post-toc-text">24.1 图片优化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#24-2-图片加载优化"><span class="post-toc-number">24.2.</span> <span class="post-toc-text">24.2 图片加载优化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#24-3-DNS-预解析"><span class="post-toc-number">24.3.</span> <span class="post-toc-text">24.3 DNS 预解析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#24-4-节流"><span class="post-toc-number">24.4.</span> <span class="post-toc-text">24.4 节流</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#24-5-防抖"><span class="post-toc-number">24.5.</span> <span class="post-toc-text">24.5 防抖</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#24-6-预加载"><span class="post-toc-number">24.6.</span> <span class="post-toc-text">24.6 预加载</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#24-7-预渲染"><span class="post-toc-number">24.7.</span> <span class="post-toc-text">24.7 预渲染</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#24-8-懒执行"><span class="post-toc-number">24.8.</span> <span class="post-toc-text">24.8 懒执行</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#24-9-懒加载"><span class="post-toc-number">24.9.</span> <span class="post-toc-text">24.9 懒加载</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#24-10-CDN"><span class="post-toc-number">24.10.</span> <span class="post-toc-text">24.10 CDN</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#25-Webpack-性能优化"><span class="post-toc-number">25.</span> <span class="post-toc-text">25 Webpack 性能优化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#25-1-减少-Webpack-打包时间"><span class="post-toc-number">25.1.</span> <span class="post-toc-text">25.1 减少 Webpack 打包时间</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#25-2-减少-Webpack-打包后的文件体积"><span class="post-toc-number">25.2.</span> <span class="post-toc-text">25.2 减少 Webpack 打包后的文件体积</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#26-实现小型打包工具"><span class="post-toc-number">26.</span> <span class="post-toc-text">26 实现小型打包工具</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#27-MVVM-虚拟DOM-前端路由"><span class="post-toc-number">27.</span> <span class="post-toc-text">27 MVVM/虚拟DOM/前端路由</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#27-1-MVVM"><span class="post-toc-number">27.1.</span> <span class="post-toc-text">27.1 MVVM</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#27-2-Virtual-DOM"><span class="post-toc-number">27.2.</span> <span class="post-toc-text">27.2 Virtual DOM</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#27-3-路由原理"><span class="post-toc-number">27.3.</span> <span class="post-toc-text">27.3 路由原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#27-4-Vue-和-React-之间的区别"><span class="post-toc-number">27.4.</span> <span class="post-toc-text">27.4 Vue 和 React 之间的区别</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#28-Vue常考知识点"><span class="post-toc-number">28.</span> <span class="post-toc-text">28 Vue常考知识点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#28-1-生命周期钩子函数"><span class="post-toc-number">28.1.</span> <span class="post-toc-text">28.1 生命周期钩子函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#28-2-组件通信"><span class="post-toc-number">28.2.</span> <span class="post-toc-text">28.2 组件通信</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#28-3-extend-能做什么"><span class="post-toc-number">28.3.</span> <span class="post-toc-text">28.3 extend 能做什么</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#28-4-mixin-和-mixins-区别"><span class="post-toc-number">28.4.</span> <span class="post-toc-text">28.4 mixin 和 mixins 区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#28-5-computed-和-watch-区别"><span class="post-toc-number">28.5.</span> <span class="post-toc-text">28.5 computed 和 watch 区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#28-6-keep-alive-组件有什么作用"><span class="post-toc-number">28.6.</span> <span class="post-toc-text">28.6 keep-alive 组件有什么作用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#28-7-v-show-与-v-if-区别"><span class="post-toc-number">28.7.</span> <span class="post-toc-text">28.7 v-show 与 v-if 区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#28-8-组件中-data-什么时候可以使用对象"><span class="post-toc-number">28.8.</span> <span class="post-toc-text">28.8 组件中 data 什么时候可以使用对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#28-9-响应式原理"><span class="post-toc-number">28.9.</span> <span class="post-toc-text">28.9 响应式原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#28-9-1-Object-defineProperty-的缺陷"><span class="post-toc-number">28.9.1.</span> <span class="post-toc-text">28.9.1 Object.defineProperty 的缺陷</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#28-9-2-编译过程"><span class="post-toc-number">28.9.2.</span> <span class="post-toc-text">28.9.2 编译过程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#28-9-3-NextTick-原理分析"><span class="post-toc-number">28.9.3.</span> <span class="post-toc-text">28.9.3 NextTick 原理分析</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#29-React常考知识点"><span class="post-toc-number">29.</span> <span class="post-toc-text">29 React常考知识点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#29-1-生命周期"><span class="post-toc-number">29.1.</span> <span class="post-toc-text">29.1 生命周期</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#29-2-setState"><span class="post-toc-number">29.2.</span> <span class="post-toc-text">29.2 setState</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#29-3-性能优化"><span class="post-toc-number">29.3.</span> <span class="post-toc-text">29.3 性能优化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#29-4-通信"><span class="post-toc-number">29.4.</span> <span class="post-toc-text">29.4 通信</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#30-监控"><span class="post-toc-number">30.</span> <span class="post-toc-text">30 监控</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#31-TCP-UDP"><span class="post-toc-number">31.</span> <span class="post-toc-text">31 TCP/UDP</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#32-HTTP-TLS"><span class="post-toc-number">32.</span> <span class="post-toc-text">32 HTTP/TLS</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#33-HTTP2-0"><span class="post-toc-number">33.</span> <span class="post-toc-text">33 HTTP2.0</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#34-输入URL到页面渲染流程"><span class="post-toc-number">34.</span> <span class="post-toc-text">34 输入URL到页面渲染流程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#35-设计模式"><span class="post-toc-number">35.</span> <span class="post-toc-text">35 设计模式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#36-常见数据结构"><span class="post-toc-number">36.</span> <span class="post-toc-text">36 常见数据结构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#37-常考算法题解析"><span class="post-toc-number">37.</span> <span class="post-toc-text">37 常考算法题解析</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#38-css常考面试题解析"><span class="post-toc-number">38.</span> <span class="post-toc-text">38 css常考面试题解析</span></a></li></ol>
        </nav>
    </aside>


<article id="post-002.前端知识体系/005.精华篇/001.精华篇之高频考点知识"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">精华篇-01.高频考点知识</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-06-04 22:52:06" datetime="2017-06-04T14:52:06.000Z"  itemprop="datePublished">2017-06-04</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/学习笔记/">学习笔记</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="1-typeof类型判断"><a href="#1-typeof类型判断" class="headerlink" title="1 typeof类型判断"></a>1 typeof类型判断</h2><blockquote>
<p><code>typeof</code> 是否能正确判断类型？<code>instanceof</code> 能正确判断对象的原理是什么</p>
</blockquote>
<ul>
<li><code>typeof</code> 对于原始类型来说，除了 <code>null</code> 都可以显示正确的类型</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">typeof</span> <span class="token number">1</span> <span class="token comment" spellcheck="true">// 'number'</span>
<span class="token keyword">typeof</span> <span class="token string">'1'</span> <span class="token comment" spellcheck="true">// 'string'</span>
<span class="token keyword">typeof</span> undefined <span class="token comment" spellcheck="true">// 'undefined'</span>
<span class="token keyword">typeof</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// 'boolean'</span>
<span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'symbol'</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>typeof</code> 对于对象来说，除了函数都会显示 <code>object</code>，所以说 <code>typeof</code> 并不能准确判断变量到底是什么类型</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 'object'</span>
<span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 'object'</span>
<span class="token keyword">typeof</span> console<span class="token punctuation">.</span>log <span class="token comment" spellcheck="true">// 'function'</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>如果我们想判断一个对象的正确类型，这时候可以考虑使用 <code>instanceof</code>，因为内部机制是通过原型链来判断的</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> Person <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
p1 <span class="token keyword">instanceof</span> <span class="token class-name">Person</span> <span class="token comment" spellcheck="true">// true</span>

<span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'hello world'</span>
str <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment" spellcheck="true">// false</span>

<span class="token keyword">var</span> str1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span>
str1 <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment" spellcheck="true">// true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>对于原始类型来说，你想直接通过 <code>instanceof</code>来判断类型是不行的</p>
</blockquote>
<h2 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2 类型转换"></a>2 类型转换</h2><blockquote>
<p>首先我们要知道，在 <code>JS</code> 中类型转换只有三种情况，分别是：</p>
</blockquote>
<ul>
<li>转换为布尔值</li>
<li>转换为数字</li>
<li>转换为字符串</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload-images.jianshu.io/upload_images/1480597-c1ede6d7eb711a22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure>
<p><strong>转Boolean</strong></p>
<blockquote>
<p>在条件判断时，除了 <code>undefined</code>，<code>null</code>， <code>false</code>， <code>NaN</code>， <code>&#39;&#39;</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 <code>true</code>，包括所有对象</p>
</blockquote>
<p><strong>对象转原始类型</strong></p>
<blockquote>
<p>对象在转换类型的时候，会调用内置的 <code>[[ToPrimitive]]</code> 函数，对于该函数来说，算法逻辑一般来说如下</p>
</blockquote>
<ul>
<li>如果已经是原始类型了，那就不需要转换了</li>
<li>调用 <code>x.valueOf()</code>，如果转换为基础类型，就返回转换的值</li>
<li>调用 <code>x.toString()</code>，如果转换为基础类型，就返回转换的值</li>
<li>如果都没有返回原始类型，就会报错</li>
</ul>
<blockquote>
<p>当然你也可以重写 <code>Symbol.toPrimitive</code>，该方法在转原始类型时调用优先级最高。</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'1'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toPrimitive<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token number">1</span> <span class="token operator">+</span> a <span class="token comment" spellcheck="true">// => 3</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>四则运算符</strong></p>
<blockquote>
<p>它有以下几个特点：</p>
</blockquote>
<ul>
<li>运算中其中一方为字符串，那么就会把另一方也转换为字符串</li>
<li>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token number">1</span> <span class="token operator">+</span> <span class="token string">'1'</span> <span class="token comment" spellcheck="true">// '11'</span>
<span class="token boolean">true</span> <span class="token operator">+</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// 2</span>
<span class="token number">4</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// "41,2,3"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>对于第一行代码来说，触发特点一，所以将数字 <code>1</code> 转换为字符串，得到结果 <code>&#39;11&#39;</code></li>
<li>对于第二行代码来说，触发特点二，所以将 <code>true</code> 转为数字 <code>1</code></li>
<li>对于第三行代码来说，触发特点二，所以将数组通过 <code>toString</code>转为字符串 <code>1,2,3</code>，得到结果 <code>41,2,3</code></li>
</ul>
<blockquote>
<p>另外对于加法还需要注意这个表达式 <code>&#39;a&#39; + + &#39;b&#39;</code></p>
</blockquote>
<pre><code>&#39;a&#39; + + &#39;b&#39; // -&gt; &quot;aNaN&quot;
</code></pre><ul>
<li>因为 <code>+ &#39;b&#39;</code> 等于 <code>NaN</code>，所以结果为 <code>&quot;aNaN&quot;</code>，你可能也会在一些代码中看到过 <code>+ &#39;1&#39;</code>的形式来快速获取 <code>number</code> 类型。</li>
<li>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token number">4</span> <span class="token operator">*</span> <span class="token string">'3'</span> <span class="token comment" spellcheck="true">// 12</span>
<span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 0</span>
<span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// NaN</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>比较运算符</strong></p>
<ul>
<li>如果是对象，就通过 <code>toPrimitive</code> 转换对象</li>
<li>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'1'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
a <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment" spellcheck="true">// true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>在以上代码中，因为 <code>a</code> 是对象，所以会通过 <code>valueOf</code> 转换为原始类型再比较值。</p>
</blockquote>
<h2 id="3-This"><a href="#3-This" class="headerlink" title="3 This"></a>3 This</h2><blockquote>
<p>我们先来看几个函数调用的场景</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  foo<span class="token punctuation">:</span> foo
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>对于直接调用 <code>foo</code> 来说，不管 <code>foo</code> 函数被放在了什么地方，<code>this</code> 一定是<code>window</code></li>
<li>对于 <code>obj.foo()</code> 来说，我们只需要记住，谁调用了函数，谁就是 <code>this</code>，所以在这个场景下 <code>foo</code> 函数中的 <code>this</code> 就是 <code>obj</code> 对象</li>
<li>对于 <code>new</code> 的方式来说，<code>this</code> 被永远绑定在了 <code>c</code> 上面，不会被任何方式改变 <code>this</code></li>
</ul>
<blockquote>
<p>说完了以上几种情况，其实很多代码中的 <code>this</code> 应该就没什么问题了，下面让我们看看箭头函数中的 <code>this</code></p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>首先箭头函数其实是没有 <code>this</code> 的，箭头函数中的 <code>this</code> 只取决包裹箭头函数的第一个普通函数的 <code>this</code>。在这个例子中，因为包裹箭头函数的第一个普通函数是 <code>a</code>，所以此时的 <code>this</code> 是 <code>window</code>。另外对箭头函数使用 <code>bind</code>这类函数是无效的。</li>
<li>最后种情况也就是 <code>bind</code> 这些改变上下文的 <code>API</code> 了，对于这些函数来说，<code>this</code> 取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code>。</li>
<li>那么说到 <code>bind</code>，不知道大家是否考虑过，如果对一个函数进行多次 <code>bind</code>，那么上下文会是什么呢？</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> fn <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
fn<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// => ?</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>如果你认为输出结果是 <code>a</code>，那么你就错了，其实我们可以把上述代码转换成另一种形式</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// fn.bind().bind(a) 等于</span>
<span class="token keyword">let</span> fn2 <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>可以从上述代码中发现，不管我们给函数 <code>bind</code> 几次，<code>fn</code> 中的 <code>this</code> 永远由第一次 <code>bind</code> 决定，所以结果永远是 <code>window</code></p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'poetries'</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
foo<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// => 'poetries'</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>以上就是 <code>this</code> 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 <code>this</code> 最终指向哪里。</p>
</blockquote>
<blockquote>
<p>首先，<code>new</code> 的方式优先级最高，接下来是 <code>bind</code> 这些函数，然后是 <code>obj.foo()</code> 这种调用方式，最后是 <code>foo</code> 这种调用方式，同时，箭头函数的 <code>this</code> 一旦被绑定，就不会再被任何方式所改变。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload-images.jianshu.io/upload_images/1480597-ce6e82dfdc1b3415.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure>
<h2 id="4-和-有什么区别"><a href="#4-和-有什么区别" class="headerlink" title="4 == 和 === 有什么区别"></a>4 == 和 === 有什么区别</h2><blockquote>
<p>对于 <code>==</code> 来说，如果对比双方的类型不一样的话，就会进行类型转换</p>
</blockquote>
<p><strong>假如我们需要对比 x 和 y 是否相同，就会进行如下判断流程</strong></p>
<ol>
<li>首先会判断两者类型是否相同。相同的话就是比大小了</li>
<li>类型不相同的话，那么就会进行类型转换</li>
<li>会先判断是否在对比 <code>null</code> 和 <code>undefined</code>，是的话就会返回 <code>true</code></li>
<li>判断两者类型是否为 <code>string</code> 和 <code>number</code>，是的话就会将字符串转换为 <code>number</code></li>
</ol>
<pre><code>1 == &#39;1&#39;
      ↓
1 ==  1
</code></pre><ol start="5">
<li>判断其中一方是否为 <code>boolean</code>，是的话就会把 <code>boolean</code> 转为 <code>number</code> 再进行判断</li>
</ol>
<pre><code>&#39;1&#39; == true
        ↓
&#39;1&#39; ==  1
        ↓
 1  ==  1
</code></pre><ol start="6">
<li>判断其中一方是否为 <code>object</code> 且另一方为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，是的话就会把 <code>object</code> 转为原始类型再进行判断</li>
</ol>
<pre><code>&#39;1&#39; == { name: &#39;yck&#39; }
        ↓
&#39;1&#39; == &#39;[object Object]&#39;
</code></pre><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload-images.jianshu.io/upload_images/1480597-88daf8ffd440c0dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure>
<blockquote>
<p>对于 <code>===</code> 来说就简单多了，就是判断两者类型和值是否相同</p>
</blockquote>
<h2 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5 闭包"></a>5 闭包</h2><blockquote>
<p>闭包的定义其实很简单：函数 <code>A</code> 内部有一个函数 <code>B</code>，函数 <code>B</code> 可以访问到函数 <code>A</code> 中的变量，那么函数 <code>B</code> 就是闭包</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span>
  window<span class="token punctuation">.</span>B <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>闭包存在的意义就是让我们可以间接访问函数内部的变量</strong></p>
<blockquote>
<p>经典面试题，循环中使用闭包解决 <code>var</code> 定义函数的问题</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code>就是 <code>6</code> 了，所以会输出一堆 <code>6</code></p>
</blockquote>
<p><strong>解决办法有三种</strong></p>
<ol>
<li>第一种是使用闭包的方式</li>
</ol>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> j <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>在上述代码中，我们首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的</p>
</blockquote>
<ol start="2">
<li>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入</li>
</ol>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span>
    <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">,</span>
    i
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="3">
<li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li>
</ol>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="6-深浅拷贝"><a href="#6-深浅拷贝" class="headerlink" title="6 深浅拷贝"></a>6 深浅拷贝</h2><p><strong>浅拷贝</strong></p>
<blockquote>
<p>首先可以通过 <code>Object.assign</code> 来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是，<code>Object.assign</code> 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
a<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>另外我们还可以通过展开运算符 <code>...</code> 来实现浅拷贝</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>a <span class="token punctuation">}</span>
a<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  jobs<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    first<span class="token punctuation">:</span> <span class="token string">'FE'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>a <span class="token punctuation">}</span>
a<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token string">'native'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// native</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。</p>
</blockquote>
<p><strong>深拷贝</strong></p>
<blockquote>
<p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决。</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  jobs<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    first<span class="token punctuation">:</span> <span class="token string">'FE'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
a<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token string">'native'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// FE</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>但是该方法也是有局限性的</strong>：</p>
<ul>
<li>会忽略 <code>undefined</code></li>
<li>会忽略 <code>symbol</code></li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  b<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    c<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    d<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span>c <span class="token operator">=</span> obj<span class="token punctuation">.</span>b
obj<span class="token punctuation">.</span>e <span class="token operator">=</span> obj<span class="token punctuation">.</span>a
obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> obj<span class="token punctuation">.</span>c
obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>d <span class="token operator">=</span> obj<span class="token punctuation">.</span>b
obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>e <span class="token operator">=</span> obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c
<span class="token keyword">let</span> newObj <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj<span class="token punctuation">)</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>更多详情 <a href="https://www.jianshu.com/p/2d8a26b3958f" target="_blank" rel="noopener">https://www.jianshu.com/p/2d8a26b3958f</a></p>
</blockquote>
<h2 id="7-原型"><a href="#7-原型" class="headerlink" title="7 原型"></a>7 原型</h2><blockquote>
<p>原型链就是多个对象通过 <code>__proto__</code> 的方式连接了起来。为什么 <code>obj</code> 可以访问到 <code>valueOf</code> 函数，就是因为 <code>obj</code> 通过原型链找到了 <code>valueOf</code> 函数</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/11/16/1671d387e4189ec8" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code>找到它</li>
<li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li>
<li>函数的 <code>prototype</code> 是一个对象</li>
<li>对象的<code>__proto__</code> 属性指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li>
</ul>
<h2 id="8-var、let-及-const-区别"><a href="#8-var、let-及-const-区别" class="headerlink" title="8 var、let 及 const 区别"></a>8 var、let 及 const 区别</h2><blockquote>
<p>涉及面试题：什么是提升？什么是暂时性死区？var、let 及 const 区别？</p>
</blockquote>
<ul>
<li>函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部</li>
<li><code>var</code> 存在提升，我们能在声明之前使用。<code>let</code>、<code>const</code> 因为暂时性死区的原因，不能在声明前使用</li>
<li><code>var</code> 在全局作用域下声明变量会导致变量挂载在 <code>window</code>上，其他两者不会</li>
<li><code>let</code> 和 <code>const</code> 作用基本一致，但是后者声明的变量不能再次赋值</li>
</ul>
<h2 id="9-原型继承和-Class-继承"><a href="#9-原型继承和-Class-继承" class="headerlink" title="9 原型继承和 Class 继承"></a>9 原型继承和 Class 继承</h2><blockquote>
<p>涉及面试题：原型如何实现继承？<code>Class</code> 如何实现继承？<code>Class</code> 本质是什么？</p>
</blockquote>
<p>首先先来讲下 <code>class</code>，其实在 <code>JS</code>中并不存在类，<code>class</code> 只是语法糖，本质还是函数</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
Person <span class="token keyword">instanceof</span> <span class="token class-name">Function</span> <span class="token comment" spellcheck="true">// true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>组合继承</strong></p>
<blockquote>
<p>组合继承是最常用的继承方式</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> value
<span class="token punctuation">}</span>
Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getValue <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

child<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span>
child <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span> <span class="token comment" spellcheck="true">// true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>以上继承的方式核心是在子类的构造函数中通过 <code>Parent.call(this)</code> 继承父类的属性，然后改变子类的原型为 <code>new Parent()</code> 来继承父类的函数。</li>
<li>这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672aeb24a2e2cae" alt></p>
<p><strong>寄生组合继承</strong></p>
<blockquote>
<p>这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> value
<span class="token punctuation">}</span>
Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getValue <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  constructor<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> Child<span class="token punctuation">,</span>
    enumerable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

child<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span>
child <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span> <span class="token comment" spellcheck="true">// true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/11/19/1672afb8dfa21361" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>Class 继承</strong></p>
<blockquote>
<p>以上两种继承方式都是通过原型去解决的，在 ES6 中，我们可以使用 class 去实现继承，并且实现起来很简单</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> value
  <span class="token punctuation">}</span>
  <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> value
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
child<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span>
child <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span> <span class="token comment" spellcheck="true">// true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>class</code> 实现继承的核心在于使用 <code>extends</code> 表明继承自哪个父类，并且在子类构造函数中必须调用 <code>super</code>，因为这段代码可以看成 <code>Parent.call(this, value)</code>。</p>
</blockquote>
<h2 id="10-模块化"><a href="#10-模块化" class="headerlink" title="10 模块化"></a>10 模块化</h2><blockquote>
<p>涉及面试题：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？</p>
</blockquote>
<p>使用一个技术肯定是有原因的，那么使用模块化可以给我们带来以下好处</p>
<ul>
<li>解决命名冲突</li>
<li>提供复用性</li>
<li>提高代码可维护性</li>
</ul>
<p><strong>立即执行函数</strong></p>
<blockquote>
<p>在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题</p>
</blockquote>
<pre><code>(function(globalVariable){
   globalVariable.test = function() {}
   // ... 声明各种变量、函数都不会污染全局作用域
})(globalVariable)
</code></pre><p><strong>AMD 和 CMD</strong></p>
<blockquote>
<p>鉴于目前这两种实现方式已经很少见到，所以不再对具体特性细聊，只需要了解这两者是如何使用的。</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// AMD</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./a'</span><span class="token punctuation">,</span> <span class="token string">'./b'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 加载模块完毕可以使用</span>
  a<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  b<span class="token punctuation">.</span><span class="token keyword">do</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// CMD</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 加载模块</span>
  <span class="token comment" spellcheck="true">// 可以把 require 写在函数体的任意地方实现延迟加载</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a'</span><span class="token punctuation">)</span>
  a<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>CommonJS</strong></p>
<blockquote>
<p><code>CommonJS</code> 最早是 <code>Node</code> 在使用，目前也仍然广泛使用，比如在 <code>Webpack</code> 中你就能见到它，当然目前在 <code>Node</code> 中的模块管理已经和 <code>CommonJS</code>有一些区别了</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// a.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// or</span>
exports<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span>

<span class="token comment" spellcheck="true">// b.js</span>
<span class="token keyword">var</span> module <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>a <span class="token comment" spellcheck="true">// -> log 1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-js"><code class="language-js">ar module <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>a
<span class="token comment" spellcheck="true">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span>
<span class="token comment" spellcheck="true">// 重要的是 module 这里，module 是 Node 独有的一个变量</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// module 基本实现</span>
<span class="token keyword">var</span> module <span class="token operator">=</span> <span class="token punctuation">{</span>
  id<span class="token punctuation">:</span> <span class="token string">'xxxx'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 我总得知道怎么去找到他吧</span>
  exports<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// exports 就是个空对象</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 这个是为什么 exports 和 module.exports 用法相似的原因</span>
<span class="token keyword">var</span> exports <span class="token operator">=</span> module<span class="token punctuation">.</span>exports
<span class="token keyword">var</span> load <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>module<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 导出的东西</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
    module<span class="token punctuation">.</span>exports <span class="token operator">=</span> a
    <span class="token keyword">return</span> module<span class="token punctuation">.</span>exports
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 然后当我 require 的时候去找到独特的</span>
<span class="token comment" spellcheck="true">// id，然后将要使用的东西用立即执行函数包装下，over</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>另外虽然 <code>exports</code> 和 <code>module.exports</code> 用法相似，但是不能对 <code>exports</code> 直接赋值。因为 <code>var exports = module.exports</code> 这句代码表明了 <code>exports</code> 和 <code>module.exports</code>享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 <code>exports</code> 赋值就会导致两者不再指向同一个内存地址，修改并不会对 <code>module.exports</code> 起效</p>
</blockquote>
<p><strong>ES Module</strong></p>
<blockquote>
<p><code>ES Module</code> 是原生实现的模块化方案，与 <code>CommonJS</code> 有以下几个区别</p>
</blockquote>
<ol>
<li><code>CommonJS</code> 支持动态导入，也就是 <code>require(${path}/xx.js)</code>，后者目前不支持，但是已有提案</li>
<li><code>CommonJS</code> 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li>
<li><code>CommonJS</code> 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 <code>ES Module</code> 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li>
<li><code>ES Module</code> 会编译成 <code>require/exports</code>来执行的</li>
</ol>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 引入模块 API</span>
<span class="token keyword">import</span> XXX <span class="token keyword">from</span> <span class="token string">'./a.js'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> XXX <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./a.js'</span>
<span class="token comment" spellcheck="true">// 导出模块 API</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="11-实现一个简洁版的promise"><a href="#11-实现一个简洁版的promise" class="headerlink" title="11 实现一个简洁版的promise"></a>11 实现一个简洁版的promise</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 三个常量用于表示状态</span>
<span class="token keyword">const</span> PENDING <span class="token operator">=</span> <span class="token string">'pending'</span>
<span class="token keyword">const</span> RESOLVED <span class="token operator">=</span> <span class="token string">'resolved'</span>
<span class="token keyword">const</span> REJECTED <span class="token operator">=</span> <span class="token string">'rejected'</span>

<span class="token keyword">function</span> <span class="token function">MyPromise</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> that <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> PENDING

    <span class="token comment" spellcheck="true">// value 变量用于保存 resolve 或者 reject 中传入的值</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span>

    <span class="token comment" spellcheck="true">// 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用</span>
    that<span class="token punctuation">.</span>resolvedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    that<span class="token punctuation">.</span>rejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>


    <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">// 首先两个函数都得判断当前状态是否为等待中</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>state <span class="token operator">===</span> PENDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            that<span class="token punctuation">.</span>state <span class="token operator">=</span> RESOLVED
            that<span class="token punctuation">.</span>value <span class="token operator">=</span> value

            <span class="token comment" spellcheck="true">// 遍历回调数组并执行</span>
            that<span class="token punctuation">.</span>resolvedCallbacks<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>cb<span class="token operator">=</span><span class="token operator">></span><span class="token function">cb</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>state <span class="token operator">===</span> PENDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            that<span class="token punctuation">.</span>state <span class="token operator">=</span> REJECTED
            that<span class="token punctuation">.</span>value <span class="token operator">=</span> value
            that<span class="token punctuation">.</span>rejectedCallbacks<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>cb<span class="token operator">=</span><span class="token operator">></span><span class="token function">cb</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">fn</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token function">cach</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 最后我们来实现较为复杂的 then 函数</span>
MyPromise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>then <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> that <span class="token operator">=</span> <span class="token keyword">this</span>

  <span class="token comment" spellcheck="true">// 判断两个参数是否为函数类型，因为这两个参数是可选参数</span>
  onFulfilled <span class="token operator">=</span> <span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> onFulfilled <span class="token punctuation">:</span> v<span class="token operator">=</span><span class="token operator">></span>v
  onRejected <span class="token operator">=</span> <span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> onRejected <span class="token punctuation">:</span> e<span class="token operator">=</span><span class="token operator">></span><span class="token keyword">throw</span> e

  <span class="token comment" spellcheck="true">// 当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> PENDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>resolvedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>rejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> RESOLVED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">onFulfilled</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> REJECTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">onRejected</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="12-Event-Loop"><a href="#12-Event-Loop" class="headerlink" title="12 Event Loop"></a>12 Event Loop</h2><h3 id="12-1-进程与线程"><a href="#12-1-进程与线程" class="headerlink" title="12.1 进程与线程"></a>12.1 进程与线程</h3><blockquote>
<p>涉及面试题：进程与线程区别？<code>JS</code> 单线程带来的好处？</p>
</blockquote>
<ul>
<li><code>JS</code> 是单线程执行的，但是你是否疑惑过什么是线程？</li>
<li>讲到线程，那么肯定也得说一下进程。本质上来说，两个名词都是 <code>CPU</code> 工作时间片的一个描述。</li>
<li>进程描述了 <code>CPU</code> 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间</li>
</ul>
<blockquote>
<p>把这些概念拿到浏览器中来说，当你打开一个 <code>Tab</code> 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、<code>JS</code> 引擎线程、<code>HTTP</code> 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁</p>
</blockquote>
<ul>
<li>上文说到了 <code>JS</code> 引擎线程和渲染线程，大家应该都知道，在 <code>JS</code> 运行的时候可能会阻止 <code>UI</code> 渲染，这说明了两个线程是互斥的。这其中的原因是因为 JS 可以修改 <code>DOM</code>，如果在 <code>JS</code> 执行的时候 <code>UI</code> 线程还在工作，就可能导致不能安全的渲染 <code>UI</code>。这其实也是一个单线程的好处，得益于 <code>JS</code> 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处</li>
</ul>
<h3 id="12-2-执行栈"><a href="#12-2-执行栈" class="headerlink" title="12.2 执行栈"></a>12.2 执行栈</h3><blockquote>
<p>涉及面试题：什么是执行栈？</p>
</blockquote>
<p>可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/11/13/1670d2d20ead32ec" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>当开始执行 <code>JS</code> 代码时，首先会执行一个 <code>main</code> 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，在图中我们也可以发现，<code>foo</code> 函数后执行，当执行完毕后就从栈中弹出了</p>
</blockquote>
<p>在开发中，大家也可以在报错中找到执行栈的痕迹</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/11/13/1670c0e21540090c" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>大家可以在上图清晰的看到报错在 <code>foo</code> 函数，<code>foo</code> 函数又是在 <code>bar</code> 函数中调用的</p>
</blockquote>
<p>当我们使用递归的时候，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670c128acce975f" alt></p>
<h3 id="12-3-浏览器中的-Event-Loop"><a href="#12-3-浏览器中的-Event-Loop" class="headerlink" title="12.3 浏览器中的 Event Loop"></a>12.3 浏览器中的 Event Loop</h3><blockquote>
<p>涉及面试题：异步代码执行顺序？解释一下什么是 <code>Event Loop</code> ？</p>
</blockquote>
<blockquote>
<p>众所周知 <code>JS</code> 是门非阻塞单线程语言，因为在最初 <code>JS</code> 就是为了和浏览器交互而诞生的。如果 <code>JS</code> 是门多线程的语言话，我们在多个线程中处理 <code>DOM</code> 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点）</p>
</blockquote>
<ul>
<li><code>JS</code> 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 <code>Task</code>（有多种 <code>task</code>） 队列中。一旦执行栈为空，<code>Event</code> <code>Loop</code> 就会从 <code>Task</code> 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 <code>JS</code> 中的异步还是同步行为</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/11/23/16740fa4cd9c6937" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<pre class="line-numbers language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>不同的任务源会被分配到不同的 <code>Task</code> 队列中，任务源可以分为 微任务（<code>microtask</code>） 和 宏任务（<code>macrotask</code>）。在 <code>ES6</code> 规范中，<code>microtask</code> 称为 <code>jobs</code>，<code>macrotask</code> 称为 <code>task</code></p>
</blockquote>
<pre class="line-numbers language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise'</span><span class="token punctuation">)</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// script start => Promise => script end => promise1 => promise2 => setTimeout</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务</p>
</blockquote>
<p><strong>微任务</strong></p>
<ul>
<li><code>process.nextTick</code></li>
<li><code>promise</code></li>
<li><code>Object.observe</code></li>
<li><code>MutationObserver</code></li>
</ul>
<p><strong>宏任务</strong></p>
<ul>
<li><code>script</code></li>
<li><code>setTimeout</code></li>
<li><code>setInterval</code></li>
<li><code>setImmediate</code></li>
<li><code>I/O</code></li>
<li><code>UI rendering</code></li>
</ul>
<blockquote>
<p>宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p>
</blockquote>
<p><strong>所以正确的一次 Event loop 顺序是这样的</strong></p>
<ul>
<li>执行同步代码，这属于宏任务</li>
<li>执行栈为空，查询是否有微任务需要执行</li>
<li>执行所有微任务</li>
<li>必要的话渲染 UI</li>
<li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li>
</ul>
<blockquote>
<p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的响应界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p>
</blockquote>
<h3 id="12-4-Node-中的-Event-loop"><a href="#12-4-Node-中的-Event-loop" class="headerlink" title="12.4 Node 中的 Event loop"></a>12.4 Node 中的 Event loop</h3><ul>
<li><code>Node</code> 中的 <code>Event loop</code> 和浏览器中的不相同。</li>
<li><code>Node</code> 的 <code>Event loop</code> 分为<code>6</code>个阶段，它们会按照顺序反复运行</li>
</ul>
<pre><code>┌───────────────────────┐
┌─&gt;│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │&lt;──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
</code></pre><p><strong>timer</strong></p>
<ul>
<li><code>timers</code> 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code></li>
<li>一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟</li>
</ul>
<p><strong>I/O</strong></p>
<ul>
<li><code>I/O</code> 阶段会执行除了 <code>close</code> 事件，定时器和 <code>setImmediate</code> 的回调</li>
</ul>
<p><strong>poll</strong></p>
<ul>
<li><p><code>poll</code> 阶段很重要，这一阶段中，系统会做两件事情</p>
<ul>
<li>执行到点的定时器</li>
<li>执行 <code>poll</code> 队列中的事件</li>
</ul>
</li>
<li><p>并且当 <code>poll</code> 中没有定时器的情况下，会发现以下两件事情</p>
<ul>
<li>如果 <code>poll</code> 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li>
<li>如果 <code>poll</code> 队列为空，会有两件事发生</li>
<li>如果有 <code>setImmediate</code> 需要执行，<code>poll</code> 阶段会停止并且进入到 <code>check</code> 阶段执行 <code>setImmediate</code></li>
<li>如果没有 <code>setImmediate</code> 需要执行，会等待回调被加入到队列中并立即执行回调</li>
<li>如果有别的定时器需要被执行，会回到 <code>timer</code> 阶段执行回调。</li>
</ul>
</li>
</ul>
<p><strong>check</strong></p>
<ul>
<li><code>check</code> 阶段执行 <code>setImmediate</code></li>
</ul>
<p><strong>close callbacks</strong></p>
<ul>
<li><code>close callbacks</code> 阶段执行 <code>close</code> 事件</li>
<li>并且在 <code>Node</code> 中，有些情况下的定时器执行顺序是随机的</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setImmediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// 这里可能会输出 setTimeout，setImmediate</span>
<span class="token comment" spellcheck="true">// 可能也会相反的输出，这取决于性能</span>
<span class="token comment" spellcheck="true">// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate</span>
<span class="token comment" spellcheck="true">// 否则会执行 setTimeout</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>上面介绍的都是 <code>macrotask</code> 的执行情况，<code>microtask</code> 会在以上每个阶段完成后立即执行</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer1'</span><span class="token punctuation">)</span>

    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer2'</span><span class="token punctuation">)</span>

    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 以上代码在浏览器和 node 中打印情况是不同的</span>
<span class="token comment" spellcheck="true">// 浏览器中一定打印 timer1, promise1, timer2, promise2</span>
<span class="token comment" spellcheck="true">// node 中可能打印 timer1, timer2, promise1, promise2</span>
<span class="token comment" spellcheck="true">// 也可能打印 timer1, promise1, timer2, promise2</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>Node</code> 中的 <code>process.nextTick</code> 会先于其他 <code>microtask</code> 执行</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"timer1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"nextTick"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// nextTick, timer1, promise1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>对于 <code>microtask</code> 来说，它会在以上每个阶段完成前清空 <code>microtask</code> 队列，下图中的 <code>Tick</code> 就代表了 <code>microtask</code></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/11/14/16710fb80dd42d27" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="13-手写-call、apply-及-bind-函数"><a href="#13-手写-call、apply-及-bind-函数" class="headerlink" title="13 手写 call、apply 及 bind 函数"></a>13 手写 call、apply 及 bind 函数</h2><blockquote>
<p>首先从以下几点来考虑如何实现这几个函数</p>
</blockquote>
<ul>
<li>不传入第一个参数，那么上下文默认为 <code>window</code></li>
<li>改变了 <code>this</code> 指向，让新的对象可以执行该函数，并能接受参数</li>
</ul>
<p><strong>实现 call</strong></p>
<ul>
<li>首先 <code>context</code>为可选参数，如果不传的话默认上下文为 <code>window</code></li>
<li>接下来给 <code>context</code> 创建一个 <code>fn</code> 属性，并将值设置为需要调用的函数</li>
<li>因为 <code>call</code> 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来</li>
<li>然后调用函数并将对象上的函数删除</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myCall <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  context <span class="token operator">=</span> context <span class="token operator">||</span> window
  context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>apply实现</strong></p>
<blockquote>
<p><code>apply</code> 的实现也类似，区别在于对参数的处理</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myApply <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  context <span class="token operator">=</span> context <span class="token operator">||</span> window
  context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">let</span> result
  <span class="token comment" spellcheck="true">// 处理参数和 call 有区别</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>bind 的实现</strong></p>
<blockquote>
<p><code>bind</code> 的实现对比其他两个函数略微地复杂了一点，因为 <code>bind</code> 需要返回一个函数，需要判断一些边界问题，以下是 <code>bind</code> 的实现</p>
</blockquote>
<ul>
<li><code>bind</code> 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 <code>new</code> 的方式，我们先来说直接调用的方式</li>
<li>对于直接调用来说，这里选择了 <code>apply</code> 的方式实现，但是对于参数需要注意以下情况：因为 <code>bind</code> 可以实现类似这样的代码 <code>f.bind(obj, 1)(2)</code>，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 <code>args.concat(...arguments)</code></li>
<li>最后来说通过 <code>new</code> 的方式，在之前的章节中我们学习过如何判断 <code>this</code>，对于 <code>new</code> 的情况来说，不会被任何方式改变 <code>this</code>，所以对于这种情况我们需要忽略传入的 <code>this</code></li>
</ul>
<pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myBind <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> _this <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true">// 返回一个函数</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">F</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">_this</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>arguments<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> _this<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="14-new"><a href="#14-new" class="headerlink" title="14 new"></a>14 new</h2><blockquote>
<p>涉及面试题：<code>new</code> 的原理是什么？通过 <code>new</code>的方式创建对象和通过字面量创建有什么区别？</p>
</blockquote>
<p><strong>在调用 new 的过程中会发生四件事情</strong></p>
<ul>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 <code>this</code></li>
<li>返回新对象</li>
</ul>
<blockquote>
<p>根据以上几个过程，我们也可以试着来自己实现一个 new</p>
</blockquote>
<ul>
<li>创建一个空对象</li>
<li>获取构造函数</li>
<li>设置空对象的原型</li>
<li>绑定 <code>this</code> 并执行构造函数</li>
<li>确保返回值为对象</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">let</span> Con <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> Con<span class="token punctuation">.</span>prototype
  <span class="token keyword">let</span> result <span class="token operator">=</span> Con<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
  <span class="token keyword">return</span> result <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> result <span class="token punctuation">:</span> obj
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>对于对象来说，其实都是通过 <code>new</code> 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = { b : 1 }</code>。</li>
<li>对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层找到 <code>Object</code>，但是你使用字面量的方式就没这个问题</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// function 就是个语法糖</span>
<span class="token comment" spellcheck="true">// 内部等同于 new Function()</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 这个字面量内部也是使用了 new Object()</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="15-instanceof-的原理"><a href="#15-instanceof-的原理" class="headerlink" title="15 instanceof 的原理"></a>15 instanceof 的原理</h2><blockquote>
<p>涉及面试题：<code>instanceof</code> 的原理是什么？</p>
</blockquote>
<p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code></p>
<p><strong>实现一下 instanceof</strong></p>
<ul>
<li>首先获取类型的原型</li>
<li>然后获得对象的原型</li>
<li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 <code>null</code>，因为原型链最终为 <code>null</code></li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> prototype <span class="token operator">=</span> right<span class="token punctuation">.</span>prototype
  left <span class="token operator">=</span> left<span class="token punctuation">.</span>__proto__
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> left <span class="token operator">===</span> undefined<span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prototype <span class="token operator">===</span> left<span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    left <span class="token operator">=</span> left<span class="token punctuation">.</span>__proto__
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="16-为什么-0-1-0-2-0-3"><a href="#16-为什么-0-1-0-2-0-3" class="headerlink" title="16 为什么 0.1 + 0.2 != 0.3"></a>16 为什么 0.1 + 0.2 != 0.3</h2><blockquote>
<p>涉及面试题：为什么 <code>0.1 + 0.2 != 0.3</code>？如何解决这个问题？</p>
</blockquote>
<p><strong>原因</strong>，因为 <code>JS</code> 采用 <code>IEEE 754</code>双精度版本（<code>64</code>位），并且只要采用 <code>IEEE 754</code>的语言都有该问题</p>
<blockquote>
<p>我们都知道计算机是通过二进制来存储东西的，那么 <code>0.1</code> 在二进制中会表示为</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// (0011) 表示循环</span>
<span class="token number">0.1</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">^</span><span class="token operator">-</span><span class="token number">4</span> <span class="token operator">*</span> <span class="token number">1.10011</span><span class="token punctuation">(</span><span class="token number">0011</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>我们可以发现，<code>0.1</code> 在二进制中是无限循环的一些数字，其实不只是 <code>0.1</code>，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 <code>JS</code>采用的浮点数标准却会裁剪掉我们的数字。</p>
</blockquote>
<p><strong>IEEE 754 双精度版本（64位）将 64 位分为了三段</strong></p>
<ul>
<li>第一位用来表示符号</li>
<li>接下去的 <code>11</code> 位用来表示指数</li>
<li>其他的位数用来表示有效位，也就是用二进制表示 <code>0.1</code> 中的 <code>10011(0011)</code></li>
</ul>
<blockquote>
<p>那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 <code>0.1</code> 不再是 <code>0.1</code> 了，而是变成了 <code>0.100000000000000002</code></p>
</blockquote>
<pre><code>0.100000000000000002 === 0.1 // true
</code></pre><blockquote>
<p>那么同样的，<code>0.2</code> 在二进制也是无限循环的，被裁剪后也失去了精度变成了 <code>0.200000000000000002</code></p>
</blockquote>
<pre><code>0.200000000000000002 === 0.2 // true
</code></pre><blockquote>
<p>所以这两者相加不等于 <code>0.3</code> 而是 <code>0.300000000000000004</code></p>
</blockquote>
<pre><code>0.1 + 0.2 === 0.30000000000000004 // true
</code></pre><blockquote>
<p>那么可能你又会有一个疑问，既然 <code>0.1</code> 不是 <code>0.1</code>，那为什么 <code>console.log(0.1)</code> 却是正确的呢？</p>
</blockquote>
<blockquote>
<p>因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证</p>
</blockquote>
<pre><code>console.log(0.100000000000000002) // 0.1
</code></pre><p><strong>解决</strong></p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0.3</span> <span class="token comment" spellcheck="true">// true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="17-事件机制"><a href="#17-事件机制" class="headerlink" title="17 事件机制"></a>17 事件机制</h2><blockquote>
<p>涉及面试题：事件的触发过程是怎么样的？知道什么是事件代理嘛？</p>
</blockquote>
<h3 id="17-1-事件触发三阶段"><a href="#17-1-事件触发三阶段" class="headerlink" title="17.1 事件触发三阶段"></a>17.1 事件触发三阶段</h3><p><strong>事件触发有三个阶段</strong>：</p>
<ul>
<li><code>window</code>往事件触发处传播，遇到注册的捕获事件会触发</li>
<li>传播到事件触发处时触发注册的事件</li>
<li>从事件触发处往 <code>window</code> 传播，遇到注册的冒泡事件会触发</li>
</ul>
<blockquote>
<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个 <code>body</code> 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 以下会先打印冒泡然后是捕获</span>
node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">'click'</span><span class="token punctuation">,</span>
  event <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'冒泡'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">false</span>
<span class="token punctuation">)</span>
node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">'click'</span><span class="token punctuation">,</span>
  event <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'捕获 '</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">true</span>
<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="17-2-注册事件"><a href="#17-2-注册事件" class="headerlink" title="17.2 注册事件"></a>17.2 注册事件</h3><blockquote>
<p>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> ，<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性</p>
</blockquote>
<ul>
<li><code>capture</code>：布尔值，和 <code>useCapture</code> 作用一样</li>
<li><code>once</code>：布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li>
<li><code>passive</code>：布尔值，表示永远不会调用 <code>preventDefault</code></li>
</ul>
<blockquote>
<p>一般来说，如果我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code>来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件<code>。stopImmediatePropagation</code>同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js">node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">'click'</span><span class="token punctuation">,</span>
  event <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    event<span class="token punctuation">.</span><span class="token function">stopImmediatePropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'冒泡'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">false</span>
<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// 点击 node 只会执行上面的函数，该函数不会执行</span>
node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">'click'</span><span class="token punctuation">,</span>
  event <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'捕获 '</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">true</span>
<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="17-3-事件代理"><a href="#17-3-事件代理" class="headerlink" title="17.3 事件代理"></a>17.3 事件代理</h3><blockquote>
<p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p>
</blockquote>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ul<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    <span class="token keyword">let</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#ul'</span><span class="token punctuation">)</span>
    ul<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>事件代理的方式相较于直接给目标注册事件来说，有以下优点</strong>：</p>
<ul>
<li>节省内存</li>
<li>不需要给子节点注销事件</li>
</ul>
<h2 id="18-跨域"><a href="#18-跨域" class="headerlink" title="18 跨域"></a>18 跨域</h2><blockquote>
<p>涉及面试题：什么是跨域？为什么浏览器要使用同源策略？你有几种方式可以解决跨域问题？了解预检请求嘛？</p>
</blockquote>
<ul>
<li>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，<code>Ajax</code> 请求会失败。</li>
<li>那么是出于什么安全考虑才会引入这种机制呢？ 其实主要是用来防止 <code>CSRF</code> 攻击的。简单点说，<code>CSRF</code> 攻击是利用用户的登录态发起恶意请求。</li>
<li>也就是说，没有同源策略的情况下，<code>A</code> 网站可以被任意其他来源的 <code>Ajax</code> 访问到内容。如果你当前 <code>A</code> 网站还存在登录态，那么对方就可以通过 <code>Ajax</code> 获得你的任何信息。当然跨域并不能完全阻止 <code>CSRF</code>。</li>
</ul>
<blockquote>
<p>然后我们来考虑一个问题，请求跨域了，那么请求到底发出去没有？ 请求必然是发出去了，但是浏览器拦截了响应。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 <code>Ajax</code>就不会。因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，<code>Ajax</code> 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 <code>CSRF</code>，因为请求毕竟是发出去了。</p>
</blockquote>
<p>接下来我们将来学习几种常见的方式来解决跨域的问题</p>
<h3 id="18-1-JSONP"><a href="#18-1-JSONP" class="headerlink" title="18.1 JSONP"></a>18.1 JSONP</h3><blockquote>
<p><code>JSONP</code> 的原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时</p>
</blockquote>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://domain/api?param1<span class="token punctuation">=</span>a&amp;param2<span class="token punctuation">=</span>b&amp;callback<span class="token punctuation">=</span>jsonp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    <span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>JSONP</code> 使用简单且兼容性不错，但是只限于 <code>get</code> 请求。</p>
</blockquote>
<blockquote>
<p>在开发中可能会遇到多个 <code>JSONP</code> 请求的回调函数名是相同的，这时候就需要自己封装一个 <code>JSONP</code>，以下是简单实现</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> jsonpCallback<span class="token punctuation">,</span> success<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span>
  script<span class="token punctuation">.</span>src <span class="token operator">=</span> url
  script<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token operator">=</span> <span class="token boolean">true</span>
  script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span>
  window<span class="token punctuation">[</span>jsonpCallback<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    success <span class="token operator">&amp;&amp;</span> <span class="token function">success</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token string">'http://xxx'</span><span class="token punctuation">,</span> <span class="token string">'callback'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="18-2-CORS"><a href="#18-2-CORS" class="headerlink" title="18.2 CORS"></a>18.2 CORS</h3><ul>
<li><code>CORS</code> 需要浏览器和后端同时支持。<code>IE 8</code> 和 <code>9</code> 需要通过 <code>XDomainRequest</code> 来实现。</li>
<li>浏览器会自动进行 <code>CORS</code> 通信，实现 <code>CORS</code> 通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</li>
<li>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。<br>虽然设置 <code>CORS</code>和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。</li>
</ul>
<p><strong>简单请求</strong></p>
<blockquote>
<p>以 <code>Ajax</code> 为例，当满足以下条件时，会触发简单请求</p>
</blockquote>
<ol>
<li>使用下列方法之一：</li>
</ol>
<ul>
<li><code>GET</code></li>
<li><code>HEAD</code></li>
<li><code>POST</code></li>
</ul>
<ol start="2">
<li><code>Content-Type</code> 的值仅限于下列三者之一：</li>
</ol>
<ul>
<li>text/plain</li>
<li><code>multipart/form-data</code></li>
<li><code>application/x-www-form-urlencoded</code></li>
</ul>
<blockquote>
<p>请求中的任意 <code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器； <code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问</p>
</blockquote>
<p><strong>复杂请求</strong></p>
<blockquote>
<p>对于复杂请求来说，首先会发起一个预检请求，该请求是 <code>option</code> 方法的，通过该请求来知道服务端是否允许跨域请求。</p>
</blockquote>
<p>对于预检请求来说，如果你使用过 <code>Node</code> 来设置 <code>CORS</code> 的话，可能会遇到过这么一个坑。</p>
<p>以下以 <code>express</code>框架举例</p>
<pre class="line-numbers language-js"><code class="language-js">app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Methods'</span><span class="token punctuation">,</span> <span class="token string">'PUT, GET, POST, DELETE, OPTIONS'</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span>
    <span class="token string">'Access-Control-Allow-Headers'</span><span class="token punctuation">,</span>
    <span class="token string">'Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials'</span>
  <span class="token punctuation">)</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>该请求会验证你的 <code>Authorization</code> 字段，没有的话就会报错。</li>
<li>当前端发起了复杂请求后，你会发现就算你代码是正确的，返回结果也永远是报错的。因为预检请求也会进入回调中，也会触发 <code>next</code> 方法，因为预检请求并不包含 <code>Authorization</code> 字段，所以服务端会报错。</li>
</ul>
<blockquote>
<p>想解决这个问题很简单，只需要在回调中过滤 <code>option</code> 方法即可</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js">res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">204</span>
res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Length'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span>
res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="18-3-document-domain"><a href="#18-3-document-domain" class="headerlink" title="18.3 document.domain"></a>18.3 document.domain</h3><ul>
<li>该方式只能用于主域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</li>
<li>只需要给页面添加 <code>document.domain = &#39;test.com&#39;</code> 表示主域名都相同就可以实现跨域</li>
</ul>
<h3 id="18-4-postMessage"><a href="#18-4-postMessage" class="headerlink" title="18.4 postMessage"></a>18.4 postMessage</h3><blockquote>
<p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 发送消息端</span>
window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token string">'http://test.com'</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// 接收消息端</span>
<span class="token keyword">var</span> mc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
mc<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> event <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> origin <span class="token operator">=</span> event<span class="token punctuation">.</span>origin <span class="token operator">||</span> event<span class="token punctuation">.</span>originalEvent<span class="token punctuation">.</span>origin
  <span class="token keyword">if</span> <span class="token punctuation">(</span>origin <span class="token operator">===</span> <span class="token string">'http://test.com'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'验证通过'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="19-存储"><a href="#19-存储" class="headerlink" title="19 存储"></a>19 存储</h2><blockquote>
<p>涉及面试题：有几种方式可以实现存储功能，分别有什么优缺点？什么是 <code>Service Worker</code>？</p>
</blockquote>
<p><strong>cookie，localStorage，sessionStorage，indexDB</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
<th>indexDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据生命周期</td>
<td>一般由服务器生成，可以设置过期时间</td>
<td>除非被清理，否则一直存在</td>
<td>页面关闭就清理</td>
<td>除非被清理，否则一直存在</td>
</tr>
<tr>
<td>数据存储大小</td>
<td><code>4K</code></td>
<td><code>5M</code></td>
<td><code>5M</code></td>
<td>无限</td>
</tr>
<tr>
<td>与服务端通信</td>
<td>每次都会携带在 <code>header</code> 中，对于请求性能影响</td>
<td>不参与</td>
<td>不参与</td>
<td>不参与</td>
</tr>
</tbody>
</table>
<blockquote>
<p>从上表可以看到，<code>cookie</code> 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 <code>localStorage</code> 和 <code>sessionStorage</code> 。对于不怎么改变的数据尽量使用 <code>localStorage</code> 存储，否则可以用 <code>sessionStorage</code>存储</p>
</blockquote>
<p><strong>对于 cookie 来说，我们还需要注意安全性。</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>value</code></td>
<td>如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</td>
</tr>
<tr>
<td><code>http-only</code></td>
<td>不能通过 <code>JS</code> 访问 <code>Cookie</code>，减少 <code>XSS</code> 攻击</td>
</tr>
<tr>
<td><code>secure</code></td>
<td>只能在协议为 <code>HTTPS</code> 的请求中携带</td>
</tr>
<tr>
<td><code>same-site</code></td>
<td>规定浏览器不能在跨域请求中携带 <code>Cookie</code>，减少 <code>CSRF</code> 攻击</td>
</tr>
</tbody>
</table>
<p><strong>Service Worker</strong></p>
<ul>
<li><code>Service Worker</code> 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 <code>Service Worker</code>的话，传输协议必须为 <code>HTTPS</code>。因为 <code>Service Worker</code> 中涉及到请求拦截，所以必须使用 <code>HTTPS</code> 协议来保障安全</li>
<li><code>Service Worker</code> 实现缓存功能一般分为三个步骤：首先需要先注册 <code>Service Worker</code>，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// index.js</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>navigator<span class="token punctuation">.</span>serviceWorker<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  navigator<span class="token punctuation">.</span>serviceWorker
    <span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'sw.js'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>registration<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'service worker 注册成功'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'servcie worker 注册失败'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// sw.js</span>
<span class="token comment" spellcheck="true">// 监听 `install` 事件，回调中缓存所需文件</span>
self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'install'</span><span class="token punctuation">,</span> e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>
    caches<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'my-cache'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./index.html'</span><span class="token punctuation">,</span> <span class="token string">'./index.js'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 拦截所有请求事件</span>
<span class="token comment" spellcheck="true">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span>
self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'fetch'</span><span class="token punctuation">,</span> e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span><span class="token function">respondWith</span><span class="token punctuation">(</span>
    caches<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> response
      <span class="token punctuation">}</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fetch source'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 <code>Service Worker</code> 已经启动了</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b1e8eba68e1c" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>在 <code>Cache</code> 中也可以发现我们所需的文件已被缓存</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b20dfc4fcd26" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>当我们重新刷新页面可以发现我们缓存的数据是从 <code>Service Worker</code> 中读取的</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b20e4f8f3257" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="20-浏览器缓存机制"><a href="#20-浏览器缓存机制" class="headerlink" title="20 浏览器缓存机制"></a>20 浏览器缓存机制</h2><blockquote>
<p>注意：该知识点属于性能优化领域，并且整一章节都是一个面试题</p>
</blockquote>
<ul>
<li>缓存可以说是性能优化中简单高效的一种优化方式了，它可以显著减少网络传输所带来的损耗。</li>
<li>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</li>
</ul>
<blockquote>
<p>接下来的内容中我们将通过以下几个部分来探讨浏览器缓存机制：</p>
</blockquote>
<ul>
<li>缓存位置</li>
<li>缓存策略</li>
<li>实际场景应用缓存策略</li>
</ul>
<h3 id="20-1-缓存位置"><a href="#20-1-缓存位置" class="headerlink" title="20.1 缓存位置"></a>20.1 缓存位置</h3><blockquote>
<p>从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络</p>
</blockquote>
<ol>
<li><code>Service Worker</code></li>
<li><code>Memory Cache</code></li>
<li><code>Disk Cache</code></li>
<li><code>Push Cache</code></li>
<li>网络请求</li>
</ol>
<p><strong>1. Service Worker</strong></p>
<ul>
<li><code>service Worker</code> 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</li>
<li>当 <code>Service Worker</code> 没有命中缓存的时候，我们需要去调用 <code>fetch</code> 函数获取数据。也就是说，如果我们没有在 <code>Service Worker</code> 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 <code>Memory Cache</code> 中还是从网络请求中获取的数据，浏览器都会显示我们是从 <code>Service Worker</code> 中获取的内容。</li>
</ul>
<p><strong>2. Memory Cache</strong></p>
<ul>
<li><code>Memory Cache</code> 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 <code>Tab</code> 页面，内存中的缓存也就被释放了。</li>
<li>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/5/1677db8003dc8311" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</p>
</blockquote>
<ul>
<li>先说结论，这是不可能的。首先计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。内存中其实可以存储大部分的文件，比如说 <code>JS</code>、<code>HTML</code>、<code>CSS</code>、图片等等</li>
<li>当然，我通过一些实践和猜测也得出了一些结论：</li>
<li>对于大文件来说，大概率是不存储在内存中的，反之优先当前系统内存使用率高的话，文件优先存储进硬盘</li>
</ul>
<p><strong>3. Disk Cache</strong></p>
<ul>
<li><code>Disk Cache</code> 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 <code>Memory Cache</code> 胜在容量和存储时效性上。</li>
<li>在所有浏览器缓存中，<code>Disk Cache</code> 覆盖面基本是最大的。它会根据 ·HTTP Herder· 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据</li>
</ul>
<p><strong>4. Push Cache</strong></p>
<ul>
<li><code>Push Cache</code> 是 <code>HTTP/2</code> 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（<code>Session</code>）中存在，一旦会话结束就被释放。</li>
<li><code>Push Cache</code> 在国内能够查到的资料很少，也是因为 <code>HTTP/2</code> 在国内不够普及，但是 <code>HTTP/2</code> 将会是日后的一个趋势</li>
</ul>
<blockquote>
<p>结论</p>
</blockquote>
<ul>
<li>所有的资源都能被推送，但是 <code>Edge</code> 和 <code>Safari</code> 浏览器兼容性不怎么好</li>
<li>可以推送 <code>no-cache</code> 和 <code>no-store</code> 的资源</li>
<li>一旦连接被关闭，<code>Push Cache</code> 就被释放</li>
<li>多个页面可以使用相同的 <code>HTTP/2</code> 连接，也就是说能使用同样的缓存</li>
<li><code>Push Cache</code> 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>你可以给其他域名推送资源</li>
</ul>
<p><strong>5. 网络请求</strong></p>
<ul>
<li>如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。</li>
<li>那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，接下来我们就来学习缓存策略这部分的内容</li>
</ul>
<h3 id="20-2-缓存策略"><a href="#20-2-缓存策略" class="headerlink" title="20.2 缓存策略"></a>20.2 缓存策略</h3><blockquote>
<p>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 <code>HTTP Header</code> 来实现的</p>
</blockquote>
<h4 id="20-2-1-强缓存"><a href="#20-2-1-强缓存" class="headerlink" title="20.2.1 强缓存"></a>20.2.1 强缓存</h4><blockquote>
<p>强缓存可以通过设置两种 <code>HTTP Header</code> 实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，<code>state code</code>为 <code>200</code></p>
</blockquote>
<p><strong>Expires</strong></p>
<pre><code>Expires: Wed, 22 Oct 2018 08:41:00 GMT
</code></pre><blockquote>
<p><code>Expires</code> 是 <code>HTTP/1</code> 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>
</blockquote>
<p><strong>Cache-control</strong></p>
<pre><code>Cache-control: max-age=30
</code></pre><ul>
<li><code>Cache-Control</code> 出现于 <code>HTTP/1.1</code>，优先级高于 <code>Expires</code> 。该属性值表示资源会在 <code>30</code> 秒后过期，需要再次请求。</li>
<li><code>Cache-Control</code> 可以在请求头或者响应头中设置，并且可以组合使用多种指令</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/6/1678234a1ed20487" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等</p>
</blockquote>
<p><strong>一些常见指令的作用</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/5/1677ef2cd7bf1bba" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="20-2-2-协商缓存"><a href="#20-2-2-协商缓存" class="headerlink" title="20.2.2 协商缓存"></a>20.2.2 协商缓存</h4><ul>
<li>如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 <code>HTTP Header</code> 实现：<code>Last-Modified</code> 和 <code>ETag</code></li>
<li>当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 <code>304</code> 状态码，并且更新浏览器缓存有效期。</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/6/16782357baddf1c6" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>Last-Modified 和 If-Modified-Since</strong></p>
<blockquote>
<p><code>Last-Modified</code> 表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code> 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 <code>304</code> 状态码。</p>
</blockquote>
<p>但是 <code>Last-Modified</code>存在一些弊端：</p>
<ul>
<li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 <code>Last-Modified</code> 被修改，服务端不能命中缓存导致发送相同的资源</li>
<li>因为 <code>Last-Modified</code> 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源<br>因为以上这些弊端，所以在 <code>HTTP / 1.1</code> 出现了 <code>ETag</code></li>
</ul>
<p><strong>ETag 和 If-None-Match</strong></p>
<ul>
<li><code>ETag</code> 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 <code>ETag</code> 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code>优先级比 <code>Last-Modified</code> 高。</li>
</ul>
<blockquote>
<p>以上就是缓存策略的所有内容了，看到这里，不知道你是否存在这样一个疑问。如果什么缓存策略都没设置，那么浏览器会怎么处理？</p>
</blockquote>
<p>对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 <code>Date</code> 减去 <code>Last-Modified</code> 值的 <code>10%</code> 作为缓存时间。</p>
<h3 id="20-3-实际场景应用缓存策略"><a href="#20-3-实际场景应用缓存策略" class="headerlink" title="20.3 实际场景应用缓存策略"></a>20.3 实际场景应用缓存策略</h3><p><strong>频繁变动的资源</strong></p>
<blockquote>
<p>对于频繁变动的资源，首先需要使用 <code>Cache-Control: no-cache</code> 使浏览器每次都请求服务器，然后配合 <code>ETag</code> 或者 <code>Last-Modified</code> 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p>
</blockquote>
<p><strong>代码文件</strong></p>
<blockquote>
<p>这里特指除了 <code>HTML</code> 外的代码文件，因为 <code>HTML</code> 文件一般不缓存或者缓存时间很短。</p>
</blockquote>
<p>一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 <code>Cache-Control: max-age=31536000</code>，这样只有当 <code>HTML</code> 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存</p>
<blockquote>
<p>更多缓存知识详解 <a href="http://blog.poetries.top/2019/01/02/browser-cache" target="_blank" rel="noopener">http://blog.poetries.top/2019/01/02/browser-cache</a></p>
</blockquote>
<h2 id="21-浏览器渲染原理"><a href="#21-浏览器渲染原理" class="headerlink" title="21 浏览器渲染原理"></a>21 浏览器渲染原理</h2><blockquote>
<p>注意：该章节都是一个面试题。</p>
</blockquote>
<h3 id="21-1-渲染过程"><a href="#21-1-渲染过程" class="headerlink" title="21.1 渲染过程"></a>21.1 渲染过程</h3><p><strong>1. 浏览器接收到 HTML 文件并转换为 DOM 树</strong></p>
<blockquote>
<p>当我们打开一个网页时，浏览器都会去请求对应的 <code>HTML</code> 文件。虽然平时我们写代码时都会分为 <code>JS</code>、<code>CSS</code>、<code>HTML</code> 文件，也就是字符串，但是计算机硬件是不理解这些字符串的，所以在网络中传输的内容其实都是 <code>0</code> 和 <code>1</code> 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/11/27/16754281e59587f3" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记（<code>token</code>），这一过程在词法分析中叫做标记化（<code>tokenization</code>）</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/11/27/16754288f37a5347" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>那么什么是标记呢？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/11/27/167540a7b5cef612" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>当结束标记化后，这些标记会紧接着转换为 <code>Node</code>，最后这些 <code>Node</code> 会根据不同 <code>Node</code> 之前的联系构建为一颗 <code>DOM</code> 树</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/11/27/1675416cbea98c3c" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>以上就是浏览器从网络中接收到 <code>HTML</code> 文件然后一系列的转换过程</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/11/27/167542b09875a74a" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>当然，在解析 <code>HTML</code> 文件的时候，浏览器还会遇到 <code>CSS</code> 和 <code>JS</code> 文件，这时候浏览器也会去下载并解析这些文件，接下来就让我们先来学习浏览器如何解析 <code>CSS</code> 文件</p>
</blockquote>
<p><strong>2. 将 CSS 文件转换为 CSSOM 树</strong></p>
<blockquote>
<p>其实转换 <code>CSS</code> 到 <code>CSSOM</code> 树的过程和上一小节的过程是极其类似的</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/11/27/167542a9af5f193f" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li>在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 <code>CSSOM</code> 树，然后确定具体的元素到底是什么样式。</li>
</ul>
<p>如果你有点不理解为什么会消耗资源的话，我这里举个例子</p>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">
  <span class="token selector">span </span><span class="token punctuation">{</span>
    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token selector">div > a > span </span><span class="token punctuation">{</span>
    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 <code>span</code> 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 <code>span</code> 标签，然后找到 <code>span</code> 标签上的 <code>a</code> 标签，最后再去找到 <code>div</code> 标签，然后给符合这种条件的 <code>span</code> 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 <code>CSS</code> 选择器，然后对于 <code>HTML</code> 来说也尽量少的添加无意义标签，保证层级扁平</p>
</blockquote>
<p><strong>3. 生成渲染树</strong></p>
<blockquote>
<p>当我们生成 <code>DOM</code> 树和 <code>CSSOM</code> 树以后，就需要将这两棵树组合为渲染树</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/11/27/16754488529c48bd" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li>在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 <code>display: none</code> 的，那么就不会在渲染树中显示。</li>
<li>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 <code>GPU</code>绘制，合成图层，显示在屏幕上。对于这一部分的内容因为过于底层，还涉及到了硬件相关的知识，这里就不再继续展开内容了。</li>
</ul>
<h3 id="21-2-为什么操作-DOM-慢"><a href="#21-2-为什么操作-DOM-慢" class="headerlink" title="21.2 为什么操作 DOM 慢"></a>21.2 为什么操作 DOM 慢</h3><blockquote>
<p>想必大家都听过操作 DOM 性能很差，但是这其中的原因是什么呢？</p>
</blockquote>
<ul>
<li>因为 <code>DOM</code>是属于渲染引擎中的东西，而 <code>JS</code> 又是 <code>JS</code> 引擎中的东西。当我们通过 <code>JS</code> 操作 <code>DOM</code> 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 <code>DOM</code> 次数一多，也就等同于一直在进行线程之间的通信，并且操作 <code>DOM</code> 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。</li>
</ul>
<blockquote>
<p>经典面试题：插入几万个 DOM，如何实现页面不卡顿？</p>
</blockquote>
<ul>
<li>对于这道题目来说，首先我们肯定不能一次性把几万个 <code>DOM</code> 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 <code>DOM</code>。大部分人应该可以想到通过 <code>requestAnimationFrame</code> 的方式去循环的插入 <code>DOM</code>，其实还有种方式去解决这个问题：虚拟滚动（<code>virtualized scroller</code>）。</li>
<li>这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/15/167b1c6887ecbba7" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>从上图中我们可以发现，即使列表很长，但是渲染的 <code>DOM</code> 元素永远只有那么几个，当我们滚动页面的时候就会实时去更新 <code>DOM</code>，这个技术就能顺利解决这道经典面试题</p>
</blockquote>
<h3 id="21-3-什么情况阻塞渲染"><a href="#21-3-什么情况阻塞渲染" class="headerlink" title="21.3 什么情况阻塞渲染"></a>21.3 什么情况阻塞渲染</h3><ul>
<li>首先渲染的前提是生成渲染树，所以 <code>HTML</code> 和 <code>CSS</code> 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。</li>
<li>然后当浏览器在解析到 <code>script</code> 标签时，会暂停构建 <code>DOM</code>，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 <code>JS</code>文件，这也是都建议将 <code>script</code> 标签放在 <code>body</code> 标签底部的原因。</li>
<li>当然在当下，并不是说 <code>script</code> 标签必须放在底部，因为你可以给 <code>script</code> 标签添加 <code>defer</code> 或者 <code>async</code> 属性。</li>
<li>当 <code>script</code> 标签加上 <code>defer</code> 属性以后，表示该 <code>JS</code> 文件会并行下载，但是会放到 <code>HTML</code> 解析完成后顺序执行，所以对于这种情况你可以把 <code>script</code>标签放在任意位置。</li>
<li>对于没有任何依赖的 <code>JS</code> 文件可以加上 <code>async</code> 属性，表示 <code>JS</code> 文件下载和解析不会阻塞渲染。</li>
</ul>
<h3 id="21-4-重绘（Repaint）和回流（Reflow）"><a href="#21-4-重绘（Repaint）和回流（Reflow）" class="headerlink" title="21.4 重绘（Repaint）和回流（Reflow）"></a>21.4 重绘（Repaint）和回流（Reflow）</h3><blockquote>
<p>重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。</p>
</blockquote>
<ul>
<li>重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘</li>
<li>回流是布局或者几何属性需要改变就称为回流。</li>
<li>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</li>
</ul>
<p><strong>以下几个动作可能会导致性能问题</strong>：</p>
<ul>
<li>改变 <code>window</code> 大小</li>
<li>改变字体</li>
<li>添加或删除样式</li>
<li>文字改变</li>
<li>定位或者浮动</li>
<li>盒模型</li>
</ul>
<blockquote>
<p>并且很多人不知道的是，重绘和回流其实也和 <code>Eventloop</code> 有关。</p>
</blockquote>
<ul>
<li>当 <code>Eventloop</code> 执行完 <code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新，因为浏览器是 <code>60Hz</code> 的刷新率，每 <code>16.6ms</code> 才会更新一次。</li>
<li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> 事件，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code> 才会触发一次，并且自带节流功能。</li>
<li>判断是否触发了 <code>media query</code></li>
<li>更新动画并且发送事件</li>
<li>判断是否有全屏操作事件</li>
<li>执行 <code>requestAnimationFrame</code>回调</li>
<li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好<br>更新界面</li>
<li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code>回调</li>
</ul>
<h3 id="21-5-减少重绘和回流"><a href="#21-5-减少重绘和回流" class="headerlink" title="21.5 减少重绘和回流"></a>21.5 减少重绘和回流</h3><ol>
<li>使用 <code>transform</code> 替代 <code>top</code></li>
</ol>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>test<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">
  <span class="token selector"><span class="token class">.test</span> </span><span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
    <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 引起回流</span>
    document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.test'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token string">'100px'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li>使用 <code>visibility</code> 替换<code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li>
<li>不要把节点的属性值放在一个循环里当成循环里的变量</li>
</ol>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.test'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>offsetTop<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="4">
<li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局</li>
<li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li>
<li><code>CSS</code> 选择符从右往左匹配查找，避免节点层级过多</li>
<li>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 <code>video</code> 标签来说，浏览器会自动将该节点变为图层。</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/3/29/1626fb6f33a6f9d7" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>设置节点为图层的方式有很多，我们可以通过以下几个常用属性可以生成新图层</p>
</blockquote>
<ul>
<li><code>will-change</code></li>
<li><code>video</code>、<code>iframe</code> 标签</li>
</ul>
<h2 id="22-安全防范"><a href="#22-安全防范" class="headerlink" title="22 安全防范"></a>22 安全防范</h2><h3 id="22-1-XSS"><a href="#22-1-XSS" class="headerlink" title="22.1 XSS"></a>22.1 XSS</h3><blockquote>
<p>涉及面试题：什么是 <code>XSS</code> 攻击？如何防范 <code>XSS</code> 攻击？什么是 <code>CSP</code>？</p>
</blockquote>
<ul>
<li><code>XSS</code> 简单点来说，就是攻击者想尽一切办法将可以执行的代码注入到网页中。</li>
<li><code>XSS</code> 可以分为多种类型，但是总体上我认为分为两类：持久型和非持久型。</li>
<li>持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。</li>
</ul>
<blockquote>
<p>举个例子，对于评论功能来说，就得防范持久型 <code>XSS</code> 攻击，因为我可以在评论中输入以下内容</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload-images.jianshu.io/upload_images/1480597-4d0534470dcfe615.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure>
<ul>
<li>这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。</li>
<li>非持久型相比于前者危害就小的多了，一般通过修改 <code>URL</code> 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。</li>
</ul>
<blockquote>
<p>举个例子，如果页面需要从 <code>URL</code> 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行</p>
</blockquote>
<pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- http://www.domain.com?name=&lt;script>alert(1)&lt;/script> --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                                                  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>但是对于这种攻击方式来说，如果用户使用 <code>Chrome</code> 这类浏览器的话，浏览器就能自动帮助用户防御攻击。但是我们不能因此就不防御此类攻击了，因为我不能确保用户都使用了该类浏览器。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/2/1676d5e1a09c8367" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>对于 <code>XSS</code> 攻击来说，通常有两种方式可以用来防御。</p>
</blockquote>
<ol>
<li><strong>转义字符</strong></li>
</ol>
<blockquote>
<p>首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">escape</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&amp;/g</span><span class="token punctuation">,</span> <span class="token string">'&amp;amp;'</span><span class="token punctuation">)</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&lt;/g</span><span class="token punctuation">,</span> <span class="token string">'&amp;lt;'</span><span class="token punctuation">)</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/>/g</span><span class="token punctuation">,</span> <span class="token string">'&amp;gt;'</span><span class="token punctuation">)</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/"/g</span><span class="token punctuation">,</span> <span class="token string">'&amp;quto;'</span><span class="token punctuation">)</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token operator">/</span><span class="token string">'/g, '</span><span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span>'<span class="token punctuation">)</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/`/g</span><span class="token punctuation">,</span> <span class="token string">'&amp;#96;'</span><span class="token punctuation">)</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\//g</span><span class="token punctuation">,</span> <span class="token string">'&amp;#x2F;'</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> str
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>通过转义可以将攻击代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 变成</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// -> &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;</span>
<span class="token function">escape</span><span class="token punctuation">(</span><span class="token string">'&lt;script>alert(1)&lt;/script>'</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> xss <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'xss'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> html <span class="token operator">=</span> <span class="token function">xss</span><span class="token punctuation">(</span><span class="token string">'&lt;h1 id="title">XSS Demo&lt;/h1>&lt;script>alert("xss");&lt;/script>'</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// -> &lt;h1>XSS Demo&lt;/h1>&amp;lt;script&amp;gt;alert("xss");&amp;lt;/script&amp;gt;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>以上示例使用了 <code>js-xss</code> 来实现，可以看到在输出中保留了 <code>h1</code> 标签且过滤了 <code>script</code>标签</p>
</blockquote>
<ol start="2">
<li><strong>CSP</strong></li>
</ol>
<blockquote>
<p><code>CSP</code> 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 <code>XSS</code> 攻击。</p>
</blockquote>
<p><strong>通常可以通过两种方式来开启 CSP</strong>：</p>
<ul>
<li>设置 <code>HTTP Header</code> 中的 <code>Content-Security-Policy</code></li>
<li>设置 <code>meta</code> 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li>
</ul>
<p>这里以设置 <code>HTTP Header</code> 来举例</p>
<p><strong>只允许加载本站资源</strong></p>
<pre><code>Content-Security-Policy: default-src ‘self’
</code></pre><p><strong>只允许加载 HTTPS 协议图片</strong></p>
<pre><code>Content-Security-Policy: img-src https://*
</code></pre><p><strong>允许加载任何来源框架</strong></p>
<pre><code>Content-Security-Policy: child-src &#39;none&#39;
</code></pre><blockquote>
<p>当然可以设置的属性远不止这些，你可以通过查阅 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank" rel="noopener">文档</a> 的方式来学习，这里就不过多赘述其他的属性了。</p>
</blockquote>
<blockquote>
<p>对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 <code>CSP</code> 的兼容性也不错。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/2/1676d8215a3d1f5b" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="22-2-CSRF"><a href="#22-2-CSRF" class="headerlink" title="22.2 CSRF"></a>22.2 CSRF</h3><blockquote>
<p>涉及面试题：什么是 <code>CSRF</code> 攻击？如何防范 <code>CSRF</code> 攻击？</p>
</blockquote>
<blockquote>
<p><code>CSRF</code> 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。</p>
</blockquote>
<p>举个例子，假设网站中有一个通过 <code>GET</code> 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口</p>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.domain.com/xxx?comment<span class="token punctuation">=</span><span class="token punctuation">'</span>attack<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>那么你是否会想到使用 <code>POST</code> 方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交 <code>POST</code> 请求。</p>
</blockquote>
<p><strong>如何防御</strong></p>
<ul>
<li><code>Get</code> 请求不对数据进行修改</li>
<li>不让第三方网站访问到用户 <code>Cookie</code></li>
<li>阻止第三方网站请求接口</li>
<li>请求时附带验证信息，比如验证码或者 <code>Token</code></li>
</ul>
<p><strong>SameSite</strong></p>
<blockquote>
<p>可以对 <code>Cookie</code> 设置 <code>SameSite</code> 属性。该属性表示 <code>Cookie</code> 不随着跨域请求发送，可以很大程度减少 <code>CSRF</code> 的攻击，但是该属性目前并不是所有浏览器都兼容。</p>
</blockquote>
<p><strong>验证 Referer</strong></p>
<blockquote>
<p>对于需要防范 <code>CSRF</code> 的请求，我们可以通过验证 <code>Referer</code> 来判断该请求是否为第三方网站发起的。</p>
</blockquote>
<p><strong>Token</strong></p>
<blockquote>
<p>服务器下发一个随机 <code>Token</code>，每次发起请求时将 <code>Token</code> 携带上，服务器验证 <code>Token</code> 是否有效</p>
</blockquote>
<h3 id="22-3-点击劫持"><a href="#22-3-点击劫持" class="headerlink" title="22.3 点击劫持"></a>22.3 点击劫持</h3><blockquote>
<p>涉及面试题：什么是点击劫持？如何防范点击劫持？</p>
</blockquote>
<blockquote>
<p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 <code>iframe</code> 嵌套的方式嵌入自己的网页中，并将 <code>iframe</code> 设置为透明，在页面中透出一个按钮诱导用户点击</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload-images.jianshu.io/upload_images/1480597-e2fd2624a105fce7.png" alt="image.png" title>
                </div>
                <div class="image-caption">image.png</div>
            </figure>
<blockquote>
<p>对于这种攻击方式，推荐防御的方法有两种</p>
</blockquote>
<p><strong>1. X-FRAME-OPTIONS</strong></p>
<blockquote>
<p><code>X-FRAME-OPTIONS</code> 是一个 <code>HTTP</code> 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用<code>iframe</code> 嵌套的点击劫持攻击。</p>
</blockquote>
<blockquote>
<p>该响应头有三个值可选，分别是</p>
</blockquote>
<ul>
<li><code>DENY</code>，表示页面不允许通过 <code>iframe</code> 的方式展示</li>
<li><code>SAMEORIGIN</code>，表示页面可以在相同域名下通过 <code>iframe</code> 的方式展示</li>
<li><code>ALLOW-FROM</code>，表示页面可以在指定来源的 <code>iframe</code> 中展示</li>
</ul>
<p><strong>2. JS 防御</strong></p>
<blockquote>
<p>对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。</p>
</blockquote>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>click-jack<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">
    <span class="token selector">html </span><span class="token punctuation">{</span>
      <span class="token property">display</span><span class="token punctuation">:</span> none <span class="token important">!important</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    <span class="token keyword">if</span> <span class="token punctuation">(</span>self <span class="token operator">==</span> top<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> style <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'click-jack'</span><span class="token punctuation">)</span>
      document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>style<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      top<span class="token punctuation">.</span>location <span class="token operator">=</span> self<span class="token punctuation">.</span>location
    <span class="token punctuation">}</span>
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>以上代码的作用就是当通过 <code>iframe</code> 的方式加载页面时，攻击者的网页直接不显示所有内容了</p>
</blockquote>
<h2 id="23-从-V8-中看-JS-性能优化"><a href="#23-从-V8-中看-JS-性能优化" class="headerlink" title="23 从 V8 中看 JS 性能优化"></a>23 从 V8 中看 JS 性能优化</h2><blockquote>
<p>注意：该知识点属于性能优化领域。</p>
</blockquote>
<h3 id="23-1-测试性能工具"><a href="#23-1-测试性能工具" class="headerlink" title="23.1 测试性能工具"></a>23.1 测试性能工具</h3><blockquote>
<p><code>Chrome</code> 已经提供了一个大而全的性能测试工具 <code>Audits</code></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/3/16772c479b194d48" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>点我们点击 <code>Audits</code> 后，可以看到如下的界面</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/3/16772c52e83d97c7" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>在这个界面中，我们可以选择想测试的功能然后点击 <code>Run audits</code> ，工具就会自动运行帮助我们测试问题并且给出一个完整的报告</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/3/16772ca3d13a68ab" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>上图是给掘金首页测试性能后给出的一个报告，可以看到报告中分别为性能、体验、SEO 都给出了打分，并且每一个指标都有详细的评估</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/3/16772cae50f7eb81" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>评估结束后，工具还提供了一些建议便于我们提高这个指标的分数</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/3/16772cbdcdaccf15" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>我们只需要一条条根据建议去优化性能即可。</p>
<blockquote>
<p>除了 <code>Audits</code> 工具之外，还有一个 <code>Performance</code>工具也可以供我们使用。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/3/16772cf78a4fa18f" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>在这张图中，我们可以详细的看到每个时间段中浏览器在处理什么事情，哪个过程最消耗时间，便于我们更加详细的了解性能瓶颈</p>
</blockquote>
<h3 id="23-2-JS-性能优化"><a href="#23-2-JS-性能优化" class="headerlink" title="23.2 JS 性能优化"></a>23.2 JS 性能优化</h3><blockquote>
<p><code>JS</code> 是编译型还是解释型语言其实并不固定。首先 <code>JS</code> 需要有引擎才能运行起来，无论是浏览器还是在 <code>Node</code> 中，这是解释型语言的特性。但是在 V8 引擎下，又引入了 <code>TurboFan</code> 编译器，他会在特定的情况下进行优化，将代码编译成执行效率更高的 <code>Machine Code</code>，当然这个编译器并不是 <code>JS</code> 必须需要的，只是为了提高代码执行性能，所以总的来说 <code>JS</code> 更偏向于解释型语言。</p>
</blockquote>
<p>那么这一小节的内容主要会针对于 <code>Chrome</code> 的 <code>V8</code> 引擎来讲解。</p>
<blockquote>
<p>在这一过程中，<code>JS</code> 代码首先会解析为抽象语法树（<code>AST</code>），然后会通过解释器或者编译器转化为 <code>Bytecode</code> 或者<code>Machine Code</code></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/3/167736409eebe688" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>从上图中我们可以发现，<code>JS</code> 会首先被解析为 <code>AST</code>，解析的过程其实是略慢的。代码越多，解析的过程也就耗费越长，这也是我们需要压缩代码的原因之一。另外一种减少解析时间的方式是预解析，会作用于未执行的函数，这个我们下面再谈</p>
</blockquote>
<p>这里需要注意一点，对于函数来说，应该尽可能避免声明嵌套函数（类也是函数），因为这样会造成函数的重复解析</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 会被重复解析</span>
  <span class="token keyword">function</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>然后 <code>Ignition</code> 负责将 <code>AST</code> 转化为 <code>Bytecode</code>，<code>TurboFan</code> 负责编译出优化后的 <code>Machine Code</code>，并且 <code>Machine Code</code> 在执行效率上优于 <code>Bytecode</code></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/3/16773b904cfb732f" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>那么我们就产生了一个疑问，什么情况下代码会编译为 <code>Machine Code</code>？</p>
</blockquote>
<blockquote>
<p><code>JS</code> 是一门动态类型的语言，并且还有一大堆的规则。简单的加法运算代码，内部就需要考虑好几种规则，比如数字相加、字符串相加、对象和字符串相加等等。这样的情况也就势必导致了内部要增加很多判断逻辑，降低运行效率。</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> x
<span class="token punctuation">}</span>

<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>对于以上代码来说，如果一个函数被多次调用并且参数一直传入 <code>number</code> 类型，那么 <code>V8</code> 就会认为该段代码可以编译为 <code>Machine Code</code>，因为你固定了类型，不需要再执行很多判断逻辑了。</li>
<li>但是如果一旦我们传入的参数类型改变，那么 <code>Machine Code</code> 就会被 <code>DeOptimized</code>为 <code>Bytecode</code>，这样就有性能上的一个损耗了。所以如果我们希望代码能多的编译为 <code>Machine Code</code> 并且 <code>DeOptimized</code>的次数减少，就应该尽可能保证传入的类型一致。</li>
<li>那么你可能会有一个疑问，到底优化前后有多少的提升呢，接下来我们就来实践测试一下到底有多少的提升</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span> performance<span class="token punctuation">,</span> PerformanceObserver <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'perf_hooks'</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> x
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// node 10 中才有 PerformanceObserver</span>
<span class="token comment" spellcheck="true">// 在这之前的 node 版本可以直接使用 performance 中的 API</span>
<span class="token keyword">const</span> obs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerformanceObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> observer<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">getEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  observer<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
obs<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">{</span> entryTypes<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'measure'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buffered<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

performance<span class="token punctuation">.</span><span class="token function">mark</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token number">10000000</span>
<span class="token comment" spellcheck="true">// 不优化代码</span>
<span class="token operator">%</span><span class="token function">NeverOptimizeFunction</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span>number<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

performance<span class="token punctuation">.</span><span class="token function">mark</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span>
performance<span class="token punctuation">.</span><span class="token function">measure</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token string">'start'</span><span class="token punctuation">,</span> <span class="token string">'end'</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>以上代码中我们使用了 <code>performance API</code>，这个 <code>API</code> 在性能测试上十分好用。不仅可以用来测量代码的执行时间，还能用来测量各种网络连接中的时间消耗等等，并且这个 API 也可以在浏览器中使</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/4/16778338eb8b7130" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>从上图中我们可以发现，优化过的代码执行时间只需要 <code>9ms</code>，但是不优化过的代码执行时间却是前者的二十倍，已经接近 <code>200ms</code> 了。在这个案例中，我相信大家已经看到了 <code>V8</code> 的性能优化到底有多强，只需要我们符合一定的规则书写代码，引擎底层就能帮助我们自动优化代码。</p>
</blockquote>
<blockquote>
<p>另外，编译器还有个骚操作 <code>Lazy-Compile</code>，当函数没有被执行的时候，会对函数进行一次预解析，直到代码被执行以后才会被解析编译。对于上述代码来说，<code>test</code> 函数需要被预解析一次，然后在调用的时候再被解析编译。但是对于这种函数马上就被调用的情况来说，预解析这个过程其实是多余的，那么有什么办法能够让代码不被预解析呢？</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> x
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>但是不可能我们为了性能优化，给所有的函数都去套上括号，并且也不是所有函数都需要这样做。我们可以通过 <code>optimize-js</code> 实现这个功能，这个库会分析一些函数的使用情况，然后给需要的函数添加括号，当然这个库很久没人维护了，如果需要使用的话，还是需要测试过相关内容的。</p>
</blockquote>
<p>其实很简单，我们只需要给函数套上括号就可以了</p>
<h2 id="24-性能优化"><a href="#24-性能优化" class="headerlink" title="24 性能优化"></a>24 性能优化</h2><blockquote>
<p>总的来说性能优化这个领域的很多内容都很碎片化，这一章节我们将来学习这些碎片化的内容。</p>
</blockquote>
<h3 id="24-1-图片优化"><a href="#24-1-图片优化" class="headerlink" title="24.1 图片优化"></a>24.1 图片优化</h3><p><strong>计算图片大小</strong></p>
<blockquote>
<p>对于一张 <code>100 * 100</code> 像素的图片来说，图像上有 <code>10000</code> 个像素点，如果每个像素的值是 <code>RGBA</code> 存储的话，那么也就是说每个像素有 <code>4</code> 个通道，每个通道 <code>1</code> 个字节（<code>8</code> 位 = <code>1</code>个字节），所以该图片大小大概为 <code>39KB</code>（<code>10000 * 1 * 4 / 1024</code>）。</p>
</blockquote>
<ul>
<li>但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。</li>
<li>了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：</li>
</ul>
<ol>
<li>减少像素点</li>
<li>减少每个像素点能够显示的颜色</li>
</ol>
<h3 id="24-2-图片加载优化"><a href="#24-2-图片加载优化" class="headerlink" title="24.2 图片加载优化"></a>24.2 图片加载优化</h3><ul>
<li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 <code>CSS</code> 去代替。</li>
<li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 <code>CDN</code> 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li>
<li>小图使用 <code>base64</code> 格式</li>
<li>将多个图标文件整合到一张图片中（雪碧图）</li>
<li>选择正确的图片格式：<ul>
<li>对于能够显示 <code>WebP</code>格式的浏览器尽量使用 <code>WebP</code> 格式。因为 <code>WebP</code> 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li>
<li>小图使用 <code>PNG</code>，其实对于大部分图标这类图片，完全可以使用 <code>SVG</code>代替</li>
<li>照片使用 <code>JPEG</code></li>
</ul>
</li>
</ul>
<h3 id="24-3-DNS-预解析"><a href="#24-3-DNS-预解析" class="headerlink" title="24.3 DNS 预解析"></a>24.3 DNS 预解析</h3><blockquote>
<p><code>DNS</code> 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 <code>IP</code>。</p>
</blockquote>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dns-prefetch<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//blog.poetries.top<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="24-4-节流"><a href="#24-4-节流" class="headerlink" title="24.4 节流"></a>24.4 节流</h3><blockquote>
<p>考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流。</p>
</blockquote>
<p>理解了节流的用途，我们就来实现下这个函数</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// func是用户传入需要防抖的函数</span>
<span class="token comment" spellcheck="true">// wait是等待时间</span>
<span class="token keyword">const</span> throttle <span class="token operator">=</span> <span class="token punctuation">(</span>func<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 上一次执行该函数的时间</span>
  <span class="token keyword">let</span> lastTime <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 当前时间</span>
    <span class="token keyword">let</span> now <span class="token operator">=</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 将当前时间和上一次执行函数时间对比</span>
    <span class="token comment" spellcheck="true">// 如果差值大于设置的等待时间就执行函数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> lastTime <span class="token operator">></span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      lastTime <span class="token operator">=</span> now
      func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">setInterval</span><span class="token punctuation">(</span>
  <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token number">1</span>
<span class="token punctuation">)</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="24-5-防抖"><a href="#24-5-防抖" class="headerlink" title="24.5 防抖"></a>24.5 防抖</h3><blockquote>
<p>考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。</p>
</blockquote>
<p>理解了防抖的用途，我们就来实现下这个函数</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// func是用户传入需要防抖的函数</span>
<span class="token comment" spellcheck="true">// wait是等待时间</span>
<span class="token keyword">const</span> debounce <span class="token operator">=</span> <span class="token punctuation">(</span>func<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 缓存一个定时器id</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token comment" spellcheck="true">// 这里返回的函数是每次用户实际调用的防抖函数</span>
  <span class="token comment" spellcheck="true">// 如果已经设定过定时器了就清空上一次的定时器</span>
  <span class="token comment" spellcheck="true">// 开始一个新的定时器，延迟执行用户传入的方法</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="24-6-预加载"><a href="#24-6-预加载" class="headerlink" title="24.6 预加载"></a>24.6 预加载</h3><ul>
<li>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</li>
<li>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</li>
</ul>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://blog.poetries.top<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p>
</blockquote>
<h3 id="24-7-预渲染"><a href="#24-7-预渲染" class="headerlink" title="24.7 预渲染"></a>24.7 预渲染</h3><blockquote>
<p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p>
</blockquote>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prerender<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://blog.poetries.top<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>预渲染虽然可以提高页面的加载速度，但是要确保该页面大概率会被用户在之后打开，否则就是白白浪费资源去渲染。</p>
</blockquote>
<h3 id="24-8-懒执行"><a href="#24-8-懒执行" class="headerlink" title="24.8 懒执行"></a>24.8 懒执行</h3><blockquote>
<p>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。</p>
</blockquote>
<h3 id="24-9-懒加载"><a href="#24-9-懒加载" class="headerlink" title="24.9 懒加载"></a>24.9 懒加载</h3><ul>
<li>懒加载就是将不关键的资源延后加载。</li>
<li>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 <code>src</code> 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 <code>src</code> 属性，这样图片就会去下载资源，实现了图片懒加载。</li>
<li>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。</li>
</ul>
<h3 id="24-10-CDN"><a href="#24-10-CDN" class="headerlink" title="24.10 CDN"></a>24.10 CDN</h3><blockquote>
<p><code>CDN</code>的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。</p>
</blockquote>
<blockquote>
<p>因此，我们可以将静态资源尽量使用 <code>CDN</code> 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 <code>CDN</code> 域名。并且对于 <code>CDN</code> 加载静态资源需要注意 <code>CDN</code>  域名要与主站不同，否则每次请求都会带上主站的 <code>Cookie</code>，平白消耗流量</p>
</blockquote>
<h2 id="25-Webpack-性能优化"><a href="#25-Webpack-性能优化" class="headerlink" title="25 Webpack 性能优化"></a>25 Webpack 性能优化</h2><blockquote>
<p>在这部分的内容中，我们会聚焦于以下两个知识点，并且每一个知识点都属于高频考点：</p>
</blockquote>
<ul>
<li>有哪些方式可以减少 <code>Webpack</code> 的打包时间</li>
<li>有哪些方式可以让 <code>Webpack</code> 打出来的包更小</li>
</ul>
<h3 id="25-1-减少-Webpack-打包时间"><a href="#25-1-减少-Webpack-打包时间" class="headerlink" title="25.1 减少 Webpack 打包时间"></a>25.1 减少 Webpack 打包时间</h3><p><strong>1. 优化 Loader</strong></p>
<blockquote>
<p>对于 <code>Loader</code> 来说，影响打包效率首当其冲必属 <code>Babel</code> 了。因为 <code>Babel</code> 会将代码转为字符串生成 <code>AST</code>，然后对 <code>AST</code> 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，我们是有办法优化的</p>
</blockquote>
<blockquote>
<p>首先我们可以优化 <code>Loader</code> 的文件搜索范围</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// js 文件才使用 babel</span>
        test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>
        loader<span class="token punctuation">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>
        <span class="token comment" spellcheck="true">// 只在 src 文件夹下查找</span>
        include<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token comment" spellcheck="true">// 不会去查找的路径</span>
        exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>对于 <code>Babel</code> 来说，我们肯定是希望只作用在 <code>JS</code>代码上的，然后 <code>node_modules</code> 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍</p>
</blockquote>
<ul>
<li>当然这样做还不够，我们还可以将 <code>Babel</code> 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js">loader<span class="token punctuation">:</span> <span class="token string">'babel-loader?cacheDirectory=true'</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>2. HappyPack</strong></p>
<blockquote>
<p>受限于 <code>Node</code> 是单线程运行的，所以 <code>Webpack</code> 在打包的过程中也是单线程的，特别是在执行<code>Loader</code> 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p>
</blockquote>
<blockquote>
<p><code>HappyPack</code> 可以将 <code>Loader</code> 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js">module<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  loaders<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>
      include<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span><span class="token punctuation">,</span>
      <span class="token comment" spellcheck="true">// id 后面的内容对应下面</span>
      loader<span class="token punctuation">:</span> <span class="token string">'happypack/loader?id=happybabel'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>
  <span class="token keyword">new</span> <span class="token class-name">HappyPack</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    id<span class="token punctuation">:</span> <span class="token string">'happybabel'</span><span class="token punctuation">,</span>
    loaders<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'babel-loader?cacheDirectory'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 开启 4 个线程</span>
    threads<span class="token punctuation">:</span> <span class="token number">4</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>3. DllPlugin</strong></p>
<blockquote>
<p><code>DllPlugin</code> 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。</p>
</blockquote>
<p>接下来我们就来学习如何使用 <code>DllPlugin</code></p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 单独配置在一个文件中</span>
<span class="token comment" spellcheck="true">// webpack.dll.conf.js</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 想统一打包的类库</span>
    vendor<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'react'</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    filename<span class="token punctuation">:</span> <span class="token string">'[name].dll.js'</span><span class="token punctuation">,</span>
    library<span class="token punctuation">:</span> <span class="token string">'[name]-[hash]'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DllPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// name 必须和 output.library 一致</span>
      name<span class="token punctuation">:</span> <span class="token string">'[name]-[hash]'</span><span class="token punctuation">,</span>
      <span class="token comment" spellcheck="true">// 该属性需要与 DllReferencePlugin 中一致</span>
      context<span class="token punctuation">:</span> __dirname<span class="token punctuation">,</span>
      path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">,</span> <span class="token string">'[name]-manifest.json'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 <code>DllReferencePlugin</code> 将依赖文件引入项目中</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// webpack.conf.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// ...省略其他配置</span>
  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DllReferencePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      context<span class="token punctuation">:</span> __dirname<span class="token punctuation">,</span>
      <span class="token comment" spellcheck="true">// manifest 就是之前打包出来的 json 文件</span>
      manifest<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./dist/vendor-manifest.json'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>4. 代码压缩</strong></p>
<blockquote>
<p>在 <code>Webpack3</code> 中，我们一般使用 <code>UglifyJS</code> 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 <code>webpack-parallel-uglify-plugin</code> 来并行运行 <code>UglifyJS</code>，从而提高效率。</p>
</blockquote>
<blockquote>
<p>在 <code>Webpack4</code> 中，我们就不需要以上这些操作了，只需要将 <code>mode</code> 设置为 <code>production</code> 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 <code>JS</code> 代码，还可以压缩 <code>HTML</code>、<code>CSS</code> 代码，并且在压缩 <code>JS</code> 代码的过程中，我们还可以通过配置实现比如删除 <code>console.log</code> 这类代码的功能。</p>
</blockquote>
<p><strong>5. 一些小的优化点</strong></p>
<blockquote>
<p>我们还可以通过一些小的优化点来加快打包速度</p>
</blockquote>
<ul>
<li><code>resolve.extensions</code>：用来表明文件后缀列表，默认查找顺序是 <code>[&#39;.js&#39;, &#39;.json&#39;]</code>，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</li>
<li><code>resolve.alias</code>：可以通过别名的方式来映射一个路径，能让 <code>Webpack</code> 更快找到路径</li>
<li><code>module.noParse</code>：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</li>
</ul>
<h3 id="25-2-减少-Webpack-打包后的文件体积"><a href="#25-2-减少-Webpack-打包后的文件体积" class="headerlink" title="25.2 减少 Webpack 打包后的文件体积"></a>25.2 减少 Webpack 打包后的文件体积</h3><p><strong>1. 按需加载</strong></p>
<blockquote>
<p>想必大家在开发 <code>SPA</code> 项目的时候，项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 <code>JS</code>文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 <code>loadash</code> 这种大型类库同样可以使用这个功能。</p>
</blockquote>
<blockquote>
<p>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 <code>Promise</code>，当 <code>Promise</code>成功以后去执行回调。</p>
</blockquote>
<p><strong>2. Scope Hoisting</strong></p>
<blockquote>
<p><code>Scope Hoisting</code> 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</p>
</blockquote>
<p>比如我们希望打包两个文件</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// test.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span>

<span class="token comment" spellcheck="true">// index.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> a <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./test.js'</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>对于这种情况，我们打包出来的代码会类似这样</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">[</span>
  <span class="token comment" spellcheck="true">/* 0 */</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> require<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">/* 1 */</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> require<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>但是如果我们使用 <code>Scope Hoisting</code> 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">[</span>
  <span class="token comment" spellcheck="true">/* 0 */</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> require<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>这样的打包方式生成的代码明显比之前的少多了。如果在 <code>Webpack4</code> 中你希望开启这个功能，只需要启用 <code>optimization.concatenateModules</code>就可以了。</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    concatenateModules<span class="token punctuation">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>3. Tree Shaking</strong></p>
<blockquote>
<p><code>Tree Shaking</code> 可以实现删除项目中未被引用的代码，比如</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// test.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">2</span>
<span class="token comment" spellcheck="true">// index.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> a <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./test.js'</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>对于以上情况，<code>test</code> 文件中的变量 <code>b</code> 如果没有在项目中使用到的话，就不会被打包到文件中。</li>
<li>如果你使用 <code>Webpack 4</code> 的话，开启生产环境就会自动启动这个优化功能。</li>
</ul>
<h2 id="26-实现小型打包工具"><a href="#26-实现小型打包工具" class="headerlink" title="26 实现小型打包工具"></a>26 实现小型打包工具</h2><blockquote>
<p>该工具可以实现以下两个功能</p>
</blockquote>
<ul>
<li>将 <code>ES6</code> 转换为 <code>ES5</code></li>
<li>支持在 <code>JS</code> 文件中 <code>import CSS</code> 文件</li>
</ul>
<blockquote>
<p>通过这个工具的实现，大家可以理解到打包工具的原理到底是什么</p>
</blockquote>
<p><strong>实现</strong></p>
<blockquote>
<p>因为涉及到 <code>ES6</code> 转 <code>ES5</code>，所以我们首先需要安装一些 <code>Babel</code> 相关的工具</p>
</blockquote>
<pre><code>yarn add babylon babel-traverse babel-core babel-preset-env  
</code></pre><p>接下来我们将这些工具引入文件中</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> babylon <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'babylon'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> traverse <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'babel-traverse'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> transformFromAst <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'babel-core'</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先，我们先来实现如何使用 <code>Babel</code> 转换代码</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">readCode</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 读取文件内容</span>
  <span class="token keyword">const</span> content <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true">// 生成 AST</span>
  <span class="token keyword">const</span> ast <span class="token operator">=</span> babylon<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    sourceType<span class="token punctuation">:</span> <span class="token string">'module'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true">// 寻找当前文件的依赖关系</span>
  <span class="token keyword">const</span> dependencies <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token function">traverse</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    ImportDeclaration<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> node <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      dependencies<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>source<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true">// 通过 AST 将代码转为 ES5</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> code <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">transformFromAst</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    presets<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'env'</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    filePath<span class="token punctuation">,</span>
    dependencies<span class="token punctuation">,</span>
    code
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>首先我们传入一个文件路径参数，然后通过 <code>fs</code> 将文件中的内容读取出来</li>
<li>接下来我们通过 <code>babylon</code> 解析代码获取 <code>AST</code>，目的是为了分析代码中是否还引入了别的文件</li>
<li>通过 <code>dependencies</code> 来存储文件中的依赖，然后再将 <code>AST</code> 转换为 <code>ES5</code> 代码</li>
<li>最后函数返回了一个对象，对象中包含了当前文件路径、当前文件依赖和当前文件转换后的代码</li>
</ul>
<blockquote>
<p>接下来我们需要实现一个函数，这个函数的功能有以下几点</p>
</blockquote>
<ul>
<li>调用 <code>readCode</code> 函数，传入入口文件</li>
<li>分析入口文件的依赖</li>
<li>识别 <code>JS</code> 和 <code>CSS</code> 文件</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getDependencies</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 读取入口文件</span>
  <span class="token keyword">const</span> entryObject <span class="token operator">=</span> <span class="token function">readCode</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span>
  <span class="token keyword">const</span> dependencies <span class="token operator">=</span> <span class="token punctuation">[</span>entryObject<span class="token punctuation">]</span>
  <span class="token comment" spellcheck="true">// 遍历所有文件依赖关系</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> asset <span class="token keyword">of</span> dependencies<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 获得文件目录</span>
    <span class="token keyword">const</span> dirname <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span>asset<span class="token punctuation">.</span>filePath<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 遍历当前文件依赖关系</span>
    asset<span class="token punctuation">.</span>dependencies<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>relativePath <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 获得绝对路径</span>
      <span class="token keyword">const</span> absolutePath <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>dirname<span class="token punctuation">,</span> relativePath<span class="token punctuation">)</span>
      <span class="token comment" spellcheck="true">// CSS 文件逻辑就是将代码插入到 `style` 标签中</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex">/\.css$/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>absolutePath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> content <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>absolutePath<span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span>
        <span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token template-string"><span class="token string">`
          const style = document.createElement('style')
          style.innerText = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\\r\\n/g</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">
          document.head.appendChild(style)
        `</span></span>
        dependencies<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          filePath<span class="token punctuation">:</span> absolutePath<span class="token punctuation">,</span>
          relativePath<span class="token punctuation">,</span>
          dependencies<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
          code
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// JS 代码需要继续查找是否有依赖关系</span>
        <span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token function">readCode</span><span class="token punctuation">(</span>absolutePath<span class="token punctuation">)</span>
        child<span class="token punctuation">.</span>relativePath <span class="token operator">=</span> relativePath
        dependencies<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> dependencies
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>首先我们读取入口文件，然后创建一个数组，该数组的目的是存储代码中涉及到的所有文件</li>
<li>接下来我们遍历这个数组，一开始这个数组中只有入口文件，在遍历的过程中，如果入口文件有依赖其他的文件，那么就会被 <code>push</code> 到这个数组中</li>
<li>在遍历的过程中，我们先获得该文件对应的目录，然后遍历当前文件的依赖关系</li>
<li>在遍历当前文件依赖关系的过程中，首先生成依赖文件的绝对路径，然后判断当前文件是 <code>CSS</code> 文件还是 <code>JS</code> 文件</li>
<li>如果是 <code>CSS</code> 文件的话，我们就不能用 <code>Babel</code> 去编译了，只需要读取 <code>CSS</code> 文件中的代码，然后创建一个 <code>style</code> 标签，将代码插入进标签并且放入 <code>head</code> 中即可</li>
<li>如果是 <code>JS</code> 文件的话，我们还需要分析 <code>JS</code> 文件是否还有别的依赖关系</li>
<li>最后将读取文件后的对象 <code>push</code> 进数组中</li>
<li>现在我们已经获取到了所有的依赖文件，接下来就是实现打包的功能了</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">bundle</span><span class="token punctuation">(</span>dependencies<span class="token punctuation">,</span> entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> modules <span class="token operator">=</span> <span class="token string">''</span>
  <span class="token comment" spellcheck="true">// 构建函数参数，生成的结构为</span>
  <span class="token comment" spellcheck="true">// { './entry.js': function(module, exports, require) { 代码 } }</span>
  dependencies<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>dep <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> filePath <span class="token operator">=</span> dep<span class="token punctuation">.</span>relativePath <span class="token operator">||</span> entry
    modules <span class="token operator">+</span><span class="token operator">=</span> <span class="token template-string"><span class="token string">`'</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>filePath<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">': (
      function (module, exports, require) { </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dep<span class="token punctuation">.</span>code<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> }
    ),`</span></span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true">// 构建 require 函数，目的是为了获取模块暴露出来的内容</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token template-string"><span class="token string">`
    (function(modules) {
      function require(id) {
        const module = { exports : {} }
        modules[id](module, module.exports, require)
        return module.exports
      }
      require('</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>entry<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">')
    })({</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>modules<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">})
  `</span></span>
  <span class="token comment" spellcheck="true">// 当生成的内容写入到文件中</span>
  fs<span class="token punctuation">.</span><span class="token function">writeFileSync</span><span class="token punctuation">(</span><span class="token string">'./bundle.js'</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>这段代码需要结合着 <code>Babel</code> 转换后的代码来看，这样大家就能理解为什么需要这样写了</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// entry.js</span>
<span class="token keyword">var</span> _a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> _a2 <span class="token operator">=</span> <span class="token function">_interopRequireDefault</span><span class="token punctuation">(</span>_a<span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">_interopRequireDefault</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">.</span>__esModule <span class="token operator">?</span> obj <span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token punctuation">:</span> obj <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_a2<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// a.js</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>exports<span class="token punctuation">,</span> <span class="token string">'__esModule'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
exports<span class="token punctuation">.</span><span class="token keyword">default</span> <span class="token operator">=</span> a
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>Babel</code> 将我们 <code>ES6</code>的模块化代码转换为了 <code>CommonJS</code>的代码，但是浏览器是不支持 <code>CommonJS</code> 的，所以如果这段代码需要在浏览器环境下运行的话，我们需要自己实现 <code>CommonJS</code> 相关的代码，这就是 <code>bundle</code> 函数做的大部分事情。</p>
</blockquote>
<p><strong>接下来我们再来逐行解析 bundle 函数</strong></p>
<ul>
<li>首先遍历所有依赖文件，构建出一个函数参数对象</li>
<li>对象的属性就是当前文件的相对路径，属性值是一个函数，函数体是当前文件下的代码，函数接受三个参数 <code>module</code>、<code>exports</code>、 <code>require</code><ul>
<li><code>module</code> 参数对应 <code>CommonJS</code> 中的 <code>module</code></li>
<li><code>exports</code> 参数对应 <code>CommonJS</code> 中的 <code>module.export</code></li>
<li><code>require</code> 参数对应我们自己创建的 <code>require</code> 函数</li>
</ul>
</li>
<li>接下来就是构造一个使用参数的函数了，函数做的事情很简单，就是内部创建一个 <code>require</code>函数，然后调用 <code>require(entry)</code>，也就是 <code>require(&#39;./entry.js&#39;)</code>，这样就会从函数参数中找到 <code>./entry.js</code> 对应的函数并执行，最后将导出的内容通过 <code>module.export</code> 的方式让外部获取到</li>
<li>最后再将打包出来的内容写入到单独的文件中</li>
</ul>
<blockquote>
<p>如果你对于上面的实现还有疑惑的话，可以阅读下打包后的部分简化代码</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>modules<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">require</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 构造一个 CommonJS 导出代码</span>
    <span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token punctuation">{</span> exports<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 去参数中获取文件对应的函数并执行</span>
    modules<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">,</span> require<span class="token punctuation">)</span>
    <span class="token keyword">return</span> module<span class="token punctuation">.</span>exports
  <span class="token punctuation">}</span>
  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./entry.js'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token string">'./entry.js'</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> require<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 这里继续通过构造的 require 去找到 a.js 文件对应的函数</span>
    <span class="token keyword">var</span> _a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_a2<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">'./a.js'</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> require<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token comment" spellcheck="true">// 将 require 函数中的变量 module 变成了这样的结构</span>
    <span class="token comment" spellcheck="true">// module.exports = 1</span>
    <span class="token comment" spellcheck="true">// 这样就能在外部取到导出的内容了</span>
    exports<span class="token punctuation">.</span><span class="token keyword">default</span> <span class="token operator">=</span> a
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 省略</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>虽然实现这个工具只写了不到 <code>100</code> 行的代码，但是打包工具的核心原理就是这些了</p>
</blockquote>
<ul>
<li>找出入口文件所有的依赖关系</li>
<li>然后通过构建 <code>CommonJS</code> 代码来获取 <code>exports</code> 导出的内容</li>
</ul>
<h2 id="27-MVVM-虚拟DOM-前端路由"><a href="#27-MVVM-虚拟DOM-前端路由" class="headerlink" title="27 MVVM/虚拟DOM/前端路由"></a>27 MVVM/虚拟DOM/前端路由</h2><h3 id="27-1-MVVM"><a href="#27-1-MVVM" class="headerlink" title="27.1 MVVM"></a>27.1 MVVM</h3><blockquote>
<p>涉及面试题：什么是 <code>MVVM</code>？比之 <code>MVC</code> 有什么区别？</p>
</blockquote>
<p><strong>首先先来说下 View 和 Model</strong></p>
<ul>
<li><code>View</code> 很简单，就是用户看到的视图</li>
<li><code>Model</code> 同样很简单，一般就是本地数据和数据库中的数据</li>
</ul>
<blockquote>
<p>基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。</p>
</blockquote>
<blockquote>
<p>传统的 <code>MVC</code> 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/20/167cad938817eb7e" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li>但是 <code>MVC</code> 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。</li>
<li>在 <code>MVVM</code> 架构中，引入了 <code>ViewModel</code> 的概念。<code>ViewModel</code> 只关心数据和业务的处理，不关心 <code>View</code> 如何处理数据，在这种情况下，<code>View</code>和 <code>Model</code> 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 <code>ViewModel</code> 中，让多个 <code>View</code> 复用这个 <code>ViewModel</code>。</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/21/167ced454926a458" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li>以 <code>Vue</code> 框架来举例，<code>ViewModel</code> 就是组件的实例。<code>View</code> 就是模板，<code>Model</code> 的话在引入 <code>Vuex</code> 的情况下是完全可以和组件分离的。</li>
<li>除了以上三个部分，其实在 <code>MVVM</code> 中还引入了一个隐式的 <code>Binder</code> 层，实现了 <code>View</code> 和 <code>ViewModel</code> 的绑定</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/12/21/167cf01bd8430243" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li>同样以 <code>Vue</code> 框架来举例，这个隐式的 <code>Binder</code> 层就是 <code>Vue</code> 通过解析模板中的插值和指令从而实现 <code>View</code> 与 <code>ViewModel</code> 的绑定。</li>
<li>对于 <code>MVVM</code>来说，其实最重要的并不是通过双向绑定或者其他的方式将 <code>View</code> 与 <code>ViewModel</code> 绑定起来，而是通过 <code>ViewModel</code> 将视图中的状态和用户的行为分离出一个抽象，这才是 <code>MVVM</code> 的精髓</li>
</ul>
<h3 id="27-2-Virtual-DOM"><a href="#27-2-Virtual-DOM" class="headerlink" title="27.2 Virtual DOM"></a>27.2 Virtual DOM</h3><blockquote>
<p>涉及面试题：什么是 <code>Virtual DOM</code>？为什么 <code>Virtual DOM</code>比原生 <code>DOM</code> 快？</p>
</blockquote>
<ul>
<li>大家都知道操作 <code>DOM</code> 是很慢的，为什么慢的原因以及在「浏览器渲染原理」章节中说过，这里就不再赘述了- 那么相较于 <code>DOM</code>来说，操作 <code>JS</code> 对象会快很多，并且我们也可以通过 <code>JS</code>来模拟 <code>DOM</code></li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> ul <span class="token operator">=</span> <span class="token punctuation">{</span>
  tag<span class="token punctuation">:</span> <span class="token string">'ul'</span><span class="token punctuation">,</span>
  props<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span><span class="token punctuation">:</span> <span class="token string">'list'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  children<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    tag<span class="token punctuation">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span>
    children<span class="token punctuation">:</span> <span class="token string">'1'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述代码对应的 <code>DOM</code> 就是</p>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>list<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>那么既然 <code>DOM</code> 可以通过 <code>JS</code> 对象来模拟，反之也可以通过 <code>JS</code> 对象来渲染出对应的 <code>DOM</code>。当然了，通过 <code>JS</code> 来模拟 <code>DOM</code> 并且渲染对应的 <code>DOM</code> 只是第一步，难点在于如何判断新旧两个 <code>JS</code> 对象的最小差异并且实现局部更新 <code>DOM</code></li>
</ul>
<blockquote>
<p>首先 <code>DOM</code> 是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 <code>O(n ^ 3)</code>，这个复杂度肯定是不能接受的。于是 <code>React</code> 团队优化了算法，实现了 <code>O(n)</code> 的复杂度来对比差异。 实现 <code>O(n)</code> 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 <code>DOM</code> 元素。 所以判断差异的算法就分为了两步</p>
</blockquote>
<ul>
<li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异</li>
<li>一旦节点有子元素，就去判断子元素是否有不同</li>
</ul>
<blockquote>
<p>在第一步算法中我们需要判断新旧节点的 <code>tagName</code> 是否相同，如果不相同的话就代表节点被替换了。如果没有更改 <code>tagName</code> 的话，就需要判断是否有子元素，有的话就进行第二步算法。</p>
</blockquote>
<blockquote>
<p>在第二步算法中，我们需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动。</p>
</blockquote>
<p>举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 假设这里模拟一个 ul，其中包含了 5 个 li</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token comment" spellcheck="true">// 这里替换上面的 li</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>从上述例子中，我们一眼就可以看出先前的 <code>ul</code> 中的第三个<code>li</code>被移除了，四五替换了位置。</p>
</blockquote>
<blockquote>
<p>那么在实际的算法中，我们如何去识别改动的是哪个节点呢？这就引入了 <code>key</code> 这个属性，想必大家在 <code>Vue</code> 或者 <code>React</code> 的列表中都用过这个属性。这个属性是用来给每一个节点打标志的，用于判断是否是同一个节点。</p>
</blockquote>
<ul>
<li>当然在判断以上差异的过程中，我们还需要判断节点的属性是否有变化等等。</li>
<li>当我们判断出以上的差异后，就可以把这些差异记录下来。当对比完两棵树以后，就可以通过差异去局部更新 <code>DOM</code>，实现性能的最优化。</li>
</ul>
<blockquote>
<p>当然了 <code>Virtual DOM</code> 提高性能是其中一个优势，其实最大的优势还是在于：</p>
</blockquote>
<ul>
<li>将 <code>Virtual DOM</code>作为一个兼容层，让我们还能对接非 <code>Web</code> 端的系统，实现跨端开发。</li>
<li>同样的，通过 <code>Virtual DOM</code>我们可以渲染到其他的平台，比如实现 <code>SSR</code>、同构渲染等等。</li>
<li>实现组件的高度抽象化</li>
</ul>
<h3 id="27-3-路由原理"><a href="#27-3-路由原理" class="headerlink" title="27.3 路由原理"></a>27.3 路由原理</h3><blockquote>
<p>涉及面试题：前端路由原理？两种实现方式有什么区别？</p>
</blockquote>
<blockquote>
<p>前端路由实现起来其实很简单，本质就是监听 <code>URL</code> 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式</p>
</blockquote>
<ul>
<li><code>Hash</code> 模式</li>
<li><code>History</code> 模式</li>
</ul>
<p><strong>1. Hash 模式</strong></p>
<blockquote>
<p><code>www.test.com/#/</code> 就是 <code>Hash URL</code>，当 <code>#</code> 后面的哈希值发生变化时，可以通过 <code>hashchange</code> 事件来监听到 <code>URL</code> 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 <code>URL</code> 请求永远是 <code>www.test.com</code></p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'hashchange'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// ... 具体逻辑</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>Hash</code> 模式相对来说更简单，并且兼容性也更好</p>
</blockquote>
<p><strong>2. History 模式</strong></p>
<blockquote>
<p><code>History</code> 模式是 <code>HTML5</code> 新推出的功能，主要使用 <code>history.pushState</code> 和 <code>history.replaceState</code> 改变 <code>URL</code></p>
</blockquote>
<ul>
<li>通过 <code>History</code> 模式改变 <code>URL</code> 同样不会引起页面的刷新，只会更新浏览器的历史记录。</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 新增历史记录</span>
history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span>stateObject<span class="token punctuation">,</span> title<span class="token punctuation">,</span> URL<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// 替换当前历史记录</span>
history<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span>stateObject<span class="token punctuation">,</span> title<span class="token punctuation">,</span> URL<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>当用户做出浏览器动作时，比如点击后退按钮时会触发 <code>popState</code> 事件</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'popstate'</span><span class="token punctuation">,</span> e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// e.state 就是 pushState(stateObject) 中的 stateObject</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>state<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>两种模式对比</strong></p>
<ul>
<li><code>Hash</code>模式只可以更改 <code>#</code> 后面的内容，<code>History</code> 模式可以通过 <code>API</code> 设置任意的同源 <code>URL</code></li>
<li><code>History</code> 模式可以通过 <code>API</code> 添加任意类型的数据到历史记录中，<code>Hash</code> 模式只能更改哈希值，也就是字符串</li>
<li><code>Hash</code> 模式无需后端配置，并且兼容性好。<code>History</code> 模式在用户手动输入地址或者刷新页面的时候会发起 <code>URL</code> 请求，后端需要配置 <code>index.html</code> 页面用于匹配不到静态资源的时候</li>
</ul>
<h3 id="27-4-Vue-和-React-之间的区别"><a href="#27-4-Vue-和-React-之间的区别" class="headerlink" title="27.4 Vue 和 React 之间的区别"></a>27.4 Vue 和 React 之间的区别</h3><ul>
<li><code>Vue</code> 的表单可以使用 <code>v-model</code> 支持双向绑定，相比于 <code>React</code> 来说开发上更加方便，当然了 <code>v-model</code> 其实就是个语法糖，本质上和 <code>React</code> 写表单的方式没什么区别</li>
<li>改变数据方式不同，<code>Vue</code> 修改状态相比来说要简单许多，<code>React</code> 需要使用 <code>setState</code> 来改变状态，并且使用这个 <code>API</code> 也有一些坑点。并且 <code>Vue</code> 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 <code>React</code> 还是需要用户手动去优化这方面的问题。</li>
<li><code>React 16</code>以后，有些钩子函数会执行多次，这是因为引入 <code>Fiber</code> 的原因</li>
<li><code>React</code> 需要使用 <code>JSX</code>，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 <code>JS</code> 来控制页面，更加的灵活。<code>Vue</code> 使用了模板语法，相比于 <code>JSX</code> 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写 <code>render</code> 函数就能在浏览器中运行。</li>
<li>在生态上来说，两者其实没多大的差距，当然 <code>React</code>的用户是远远高于<code>Vue</code> 的</li>
</ul>
<h2 id="28-Vue常考知识点"><a href="#28-Vue常考知识点" class="headerlink" title="28 Vue常考知识点"></a>28 Vue常考知识点</h2><h3 id="28-1-生命周期钩子函数"><a href="#28-1-生命周期钩子函数" class="headerlink" title="28.1 生命周期钩子函数"></a>28.1 生命周期钩子函数</h3><ul>
<li>在 <code>beforeCreate</code> 钩子函数调用的时候，是获取不到 <code>props</code> 或者 <code>data</code> 中的数据的，因为这些数据的初始化都在 <code>initState</code> 中。</li>
<li>然后会执行 <code>created</code> 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。</li>
<li>接下来会先执行 <code>beforeMount</code> 钩子函数，开始创建 <code>VDOM</code>，最后执行 <code>mounted</code> 钩子，并将 <code>VDOM</code>渲染为真实 <code>DOM</code> 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。</li>
<li>接下来是数据更新时会调用的钩子函数 <code>beforeUpdate</code> 和 <code>updated</code>，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。</li>
<li>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code>。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</li>
<li>最后就是销毁组件的钩子函数 <code>beforeDestroy</code> 和 <code>destroyed</code>。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 <code>destroyed</code> 钩子函数</li>
</ul>
<h3 id="28-2-组件通信"><a href="#28-2-组件通信" class="headerlink" title="28.2 组件通信"></a>28.2 组件通信</h3><blockquote>
<p>组件通信一般分为以下几种情况：</p>
</blockquote>
<ul>
<li>父子组件通信</li>
<li>兄弟组件通信</li>
<li>跨多层级组件通信</li>
</ul>
<blockquote>
<p>对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。</p>
</blockquote>
<p><strong>1. 父子通信</strong></p>
<ul>
<li>父组件通过 <code>props</code> 传递数据给子组件，子组件通过 <code>emit</code> 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。</li>
<li>这种父子通信方式也就是典型的单向数据流，父组件通过 <code>props</code> 传递数据，子组件不能直接修改 <code>props</code>，而是必须通过发送事件的方式告知父组件修改数据。</li>
<li>另外这两种方式还可以使用语法糖 <code>v-model</code> 来直接实现，因为 <code>v-model</code> 默认会解析成名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件。这种语法糖的方式是典型的双向绑定，常用于 <code>UI</code> 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。</li>
<li>当然我们还可以通过访问 <code>$parent</code> 或者 <code>$children</code> 对象来访问组件实例中的方法和数据。</li>
<li>另外如果你使用 Vue 2.3 及以上版本的话还可以使用 <code>$listeners</code> 和 <code>.sync</code> 这两个属性。</li>
<li><code>$listeners</code> 属性会将父组件中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器传递给子组件，子组件可以通过访问 <code>$listeners</code> 来自定义监听器。</li>
<li><code>.sync</code> 属性是个语法糖，可以很简单的实现子组件与父组件通信</li>
</ul>
<pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--父组件中--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:value.sync</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>value<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
<span class="token comment" spellcheck="true">&lt;!--以上写法等同于--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>value<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>v <span class="token punctuation">=</span><span class="token punctuation">></span> value <span class="token punctuation">=</span> v<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>comp</span><span class="token punctuation">></span></span>
<span class="token comment" spellcheck="true">&lt;!--子组件中--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'update:value'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>2. 兄弟组件通信</strong></p>
<blockquote>
<p>对于这种情况可以通过查找父组件中的子组件实现，也就是 <code>this.$parent.$children</code>，在 <code>$children</code> 中可以通过组件 <code>name</code> 查询到需要的组件实例，然后进行通信。</p>
</blockquote>
<p><strong>3. 跨多层次组件通信</strong></p>
<blockquote>
<p>对于这种情况可以使用 <code>Vue 2.2</code> 新增的 <code>API provide / inject</code>，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。</p>
</blockquote>
<p>假设有父组件 <code>A</code>，然后有一个跨多层级的子组件 <code>B</code></p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 父组件 A</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  provide<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    data<span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 子组件 B</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  inject<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 无论跨几层都能获得父组件的 data 属性</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// => 1</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>终极办法解决一切通信问题</strong></p>
<blockquote>
<p>只要你不怕麻烦，可以使用 <code>Vuex</code> 或者 <code>Event Bus</code> 解决上述所有的通信情况。</p>
</blockquote>
<h3 id="28-3-extend-能做什么"><a href="#28-3-extend-能做什么" class="headerlink" title="28.3 extend 能做什么"></a>28.3 extend 能做什么</h3><blockquote>
<p>这个 <code>API</code> 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 创建组件构造器</span>
<span class="token keyword">let</span> Component <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token punctuation">:</span> <span class="token string">'&lt;div>test&lt;/div>'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// 挂载到 #app 上</span>
<span class="token keyword">new</span> <span class="token class-name">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// 除了上面的方式，还可以用来扩展已有的组件</span>
<span class="token keyword">let</span> SuperComponent <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>Component<span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">SuperComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">SuperComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="28-4-mixin-和-mixins-区别"><a href="#28-4-mixin-和-mixins-区别" class="headerlink" title="28.4 mixin 和 mixins 区别"></a>28.4 mixin 和 mixins 区别</h3><blockquote>
<p><code>mixin</code> 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// ...逻辑</span>
        <span class="token comment" spellcheck="true">// 这种方式会影响到每个组件的 beforeCreate 钩子函数</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>虽然文档不建议我们在应用中直接使用 <code>mixin</code>，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 <code>ajax</code> 或者一些工具函数等等。</li>
<li><code>mixins</code> 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 <code>mixins</code> 混入代码，比如上拉下拉加载数据这种逻辑等等。</li>
<li>另外需要注意的是 <code>mixins</code> 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读 文档。</li>
</ul>
<h3 id="28-5-computed-和-watch-区别"><a href="#28-5-computed-和-watch-区别" class="headerlink" title="28.5 computed 和 watch 区别"></a>28.5 computed 和 watch 区别</h3><ul>
<li><code>computed</code> 是计算属性，依赖其他属性计算值，并且 <code>computed</code> 的值有缓存，只有当计算值变化才会返回内容。</li>
<li><code>watch</code> 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</li>
<li>所以一般来说需要依赖别的属性来动态获得值的时候可以使用 <code>computed</code>，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 <code>watch</code>。</li>
<li>另外 <code>computer</code> 和 <code>watch</code> 还都支持对象的写法，这种方式知道的人并不多。</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js">vm<span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token string">'obj'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 深度遍历</span>
    deep<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 立即触发</span>
    immediate<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 执行的函数</span>
    handler<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  data<span class="token punctuation">:</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    aPlus<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// this.aPlus 时触发</span>
      <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token comment" spellcheck="true">// this.aPlus = 1 时触发</span>
      <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> v <span class="token operator">-</span> <span class="token number">1</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="28-6-keep-alive-组件有什么作用"><a href="#28-6-keep-alive-组件有什么作用" class="headerlink" title="28.6 keep-alive 组件有什么作用"></a>28.6 keep-alive 组件有什么作用</h3><ul>
<li>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 <code>keep-alive</code> 组件包裹需要保存的组件。</li>
<li>对于 <code>keep-alive</code> 组件来说，它拥有两个独有的生命周期钩子函数，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</li>
</ul>
<h3 id="28-7-v-show-与-v-if-区别"><a href="#28-7-v-show-与-v-if-区别" class="headerlink" title="28.7 v-show 与 v-if 区别"></a>28.7 v-show 与 v-if 区别</h3><ul>
<li><code>v-show</code> 只是在 <code>display: none</code> 和 <code>display: block</code> 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 <code>CSS</code>，<code>DOM</code> 还是一直保留着的。所以总的来说 <code>v-show</code> 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</li>
<li><code>v-if</code> 的话就得说到 <code>Vue</code> 底层的编译了。当属性初始为 <code>false</code> 时，组件就不会被渲染，直到条件为 <code>true</code>，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。</li>
<li>并且基于 <code>v-if</code> 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</li>
</ul>
<h3 id="28-8-组件中-data-什么时候可以使用对象"><a href="#28-8-组件中-data-什么时候可以使用对象" class="headerlink" title="28.8 组件中 data 什么时候可以使用对象"></a>28.8 组件中 data 什么时候可以使用对象</h3><blockquote>
<p>这道题目其实更多考的是 JS 功底。</p>
</blockquote>
<ul>
<li>组件复用时所有组件实例都会共享 <code>data</code>，如果 <code>data</code> 是对象的话，就会造成一个组件修改 <code>data</code> 以后会影响到其他所有组件，所以需要将 <code>data</code> 写成函数，每次用到就调用一次函数获得新的数据。</li>
<li>当我们使用 <code>new Vue()</code> 的方式的时候，无论我们将 <code>data</code> 设置为对象还是函数都是可以的，因为 <code>new Vue()</code> 的方式是生成一个根组件，该组件不会复用，也就不存在共享 <code>data</code> 的情况了</li>
</ul>
<blockquote>
<p>以下是进阶部分</p>
</blockquote>
<h3 id="28-9-响应式原理"><a href="#28-9-响应式原理" class="headerlink" title="28.9 响应式原理"></a>28.9 响应式原理</h3><blockquote>
<p><code>Vue</code> 内部使用了 <code>Object.defineProperty()</code> 来实现数据响应式，通过这个函数可以监听到 <code>set</code> 和 <code>get</code> 的事件</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'poetries'</span> <span class="token punctuation">}</span>
<span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token keyword">let</span> name <span class="token operator">=</span> data<span class="token punctuation">.</span>name <span class="token comment" spellcheck="true">// -> get value</span>
data<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'yyy'</span> <span class="token comment" spellcheck="true">// -> change value</span>

<span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 判断类型</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>obj <span class="token operator">||</span> <span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 递归子属性</span>
  <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 可枚举</span>
    enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 可配置</span>
    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 自定义函数</span>
    <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get value'</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> val
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'change value'</span><span class="token punctuation">)</span>
      val <span class="token operator">=</span> newVal
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>以上代码简单的实现了如何监听数据的 <code>set</code> 和 <code>get</code> 的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，从能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集</p>
</blockquote>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>
    {{name}}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>在解析如上模板代码时，遇到 <code></code> 就会进行依赖收集。</li>
<li>接下来我们先来实现一个 <code>Dep</code> 类，用于解耦属性的依赖收集和派发更新操作</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 通过 Dep 解耦属性的依赖和更新操作</span>
<span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 添加依赖</span>
  <span class="token function">addSub</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 更新</span>
  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>sub <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      sub<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 全局属性，通过该属性配置 Watcher</span>
Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>以上的代码实现很简单，当需要依赖收集的时候调用 <code>addSub</code>，当需要派发更新的时候调用 <code>notify</code>。</p>
</blockquote>
<blockquote>
<p>接下来我们先来简单的了解下 <code>Vue</code>组件挂载时添加响应式的过程。在组件挂载时，会先对所有需要的属性调用 <code>Object.defineProperty()</code>，然后实例化 <code>Watcher</code>，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。</p>
</blockquote>
<p>因为这一小节主要目的是学习响应式原理的细节，所以接下来的代码会简略的表达触发依赖收集时的操作。</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 将 Dep.target 指向自己</span>
    <span class="token comment" spellcheck="true">// 然后触发属性的 getter 添加监听</span>
    <span class="token comment" spellcheck="true">// 最后将 Dep.target 置空</span>
    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb
    <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> obj
    <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 获得新值</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>key<span class="token punctuation">]</span>
    <span class="token comment" spellcheck="true">// 调用 update 方法更新 Dom</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>以上就是 <code>Watcher</code>的简单实现，在执行构造函数的时候将 <code>Dep.target</code>指向自身，从而使得收集到了对应的 <code>Watcher</code>，在派发更新的时候取出对应的 <code>Watcher</code> 然后执行 <code>update</code> 函数。</p>
</blockquote>
<p>接下来，需要对<code>defineReactive</code> 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 递归子属性</span>
  <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
  <span class="token keyword">let</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get value'</span><span class="token punctuation">)</span>
      <span class="token comment" spellcheck="true">// 将 Watcher 添加到订阅</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dp<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> val
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'change value'</span><span class="token punctuation">)</span>
      val <span class="token operator">=</span> newVal
      <span class="token comment" spellcheck="true">// 执行 watcher 的 update 方法</span>
      dp<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 <code>getter</code> 来实现依赖收集。</p>
</blockquote>
<p>现在我们就来测试下代码的效果，只需要把所有的代码复制到浏览器中执行，就会发现页面的内容全部被替换了</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'poetries'</span> <span class="token punctuation">}</span>
<span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText <span class="token operator">=</span> value
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 模拟解析到 `{{name}}` 触发的操作</span>
<span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// update Dom innerText</span>
data<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'yyy'</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="28-9-1-Object-defineProperty-的缺陷"><a href="#28-9-1-Object-defineProperty-的缺陷" class="headerlink" title="28.9.1 Object.defineProperty 的缺陷"></a>28.9.1 Object.defineProperty 的缺陷</h4><ul>
<li>以上已经分析完了 <code>Vue</code> 的响应式原理，接下来说一点 <code>Object.defineProperty</code> 中的缺陷。</li>
<li>如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为<code>Object.defineProperty</code> 不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 <code>Vue</code> 内部通过重写函数的方式解决了这个问题。</li>
<li>对于第一个问题，<code>Vue</code> 提供了一个 <code>API</code> 解决</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token keyword">set</span> <span class="token punctuation">(</span>target<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">></span> <span class="token operator">|</span> Object<span class="token punctuation">,</span> key<span class="token punctuation">:</span> any<span class="token punctuation">,</span> val<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">:</span> any <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 判断是否为数组且下标是否有效</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 调用 splice 函数触发派发更新</span>
    <span class="token comment" spellcheck="true">// 该函数已被重写</span>
    target<span class="token punctuation">.</span>length <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 判断 key 是否已经存在</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">.</span>__ob__
  <span class="token comment" spellcheck="true">// 如果对象不是响应式对象，就赋值返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 进行双向绑定</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>ob<span class="token punctuation">.</span>value<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true">// 手动派发更新</span>
  ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> val
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>对于数组而言，<code>Vue</code>内部重写了以下函数实现派发更新</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 获得数组原型</span>
<span class="token keyword">const</span> arrayProto <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// 重写以下函数</span>
<span class="token keyword">const</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'push'</span><span class="token punctuation">,</span>
  <span class="token string">'pop'</span><span class="token punctuation">,</span>
  <span class="token string">'shift'</span><span class="token punctuation">,</span>
  <span class="token string">'unshift'</span><span class="token punctuation">,</span>
  <span class="token string">'splice'</span><span class="token punctuation">,</span>
  <span class="token string">'sort'</span><span class="token punctuation">,</span>
  <span class="token string">'reverse'</span>
<span class="token punctuation">]</span>
methodsToPatch<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 缓存原生函数</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span>
  <span class="token comment" spellcheck="true">// 重写函数</span>
  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> mutator <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 先调用原生函数获得结果</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> original<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__
    <span class="token keyword">let</span> inserted
    <span class="token comment" spellcheck="true">// 调用以下几个函数时，监听新数据</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'push'</span><span class="token punctuation">:</span>
      <span class="token keyword">case</span> <span class="token string">'unshift'</span><span class="token punctuation">:</span>
        inserted <span class="token operator">=</span> args
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">'splice'</span><span class="token punctuation">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 手动派发更新</span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="28-9-2-编译过程"><a href="#28-9-2-编译过程" class="headerlink" title="28.9.2 编译过程"></a>28.9.2 编译过程</h4><blockquote>
<p>想必大家在使用 Vue 开发的过程中，基本都是使用模板的方式。那么你有过「模板是怎么在浏览器中运行的」这种疑虑嘛？</p>
</blockquote>
<ul>
<li>首先直接把模板丢到浏览器中肯定是不能运行的，模板只是为了方便开发者进行开发。<code>Vue</code> 会通过编译器将模板通过几个阶段最终编译为 <code>render</code> 函数，然后通过执行 <code>render</code> 函数生成 <code>Virtual DOM</code> 最终映射为真实 <code>DOM</code>。</li>
<li>接下来我们就来学习这个编译的过程，了解这个过程中大概发生了什么事情。<strong>这个过程其中又分为三个阶段</strong>，分别为：</li>
</ul>
<blockquote>
<ul>
<li>将模板解析为 <code>AST</code></li>
<li>优化 <code>AST</code></li>
<li>将 <code>AST</code>转换为 <code>render</code>函数</li>
</ul>
</blockquote>
<p>在第一个阶段中，最主要的事情还是通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 <code>AST</code>对象</p>
<pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 类型</span>
    type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 标签</span>
    tag<span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 属性列表</span>
    attrsList<span class="token punctuation">:</span> attrs<span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 属性映射</span>
    attrsMap<span class="token punctuation">:</span> <span class="token function">makeAttrsMap</span><span class="token punctuation">(</span>attrs<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 父节点</span>
    parent<span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 子节点</span>
    children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>然后会根据这个最基本的 AST 对象中的属性，进一步扩展 <code>AST</code>。</li>
<li>当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 <code>HTML5 Content Model</code>规范等等问题。</li>
<li>接下来就是优化 AST 的阶段。在当前版本下，<code>Vue</code> 进行的优化内容其实还是不多的。只是对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 <code>Virtual DOM</code>，跳过对比算法的功能。在下一个大版本中，<code>Vue</code> 会在优化 <code>AST</code> 的阶段继续发力，实现更多的优化功能，尽可能的在编译阶段压榨更多的性能，比如说提取静态的属性等等优化行为。</li>
<li>最后一个阶段就是通过 <code>AST</code> 生成 <code>render</code> 函数了。其实这一阶段虽然分支有很多，但是最主要的目的就是遍历整个 <code>AST</code>，根据不同的条件生成不同的代码罢了。</li>
</ul>
<h4 id="28-9-3-NextTick-原理分析"><a href="#28-9-3-NextTick-原理分析" class="headerlink" title="28.9.3 NextTick 原理分析"></a>28.9.3 NextTick 原理分析</h4><blockquote>
<p><code>nextTick</code> 可以让我们在下次 <code>DOM</code> 更新循环结束之后执行延迟回调，用于获得更新后的 <code>DOM</code>。</p>
</blockquote>
<ul>
<li>在 <code>Vue 2.4</code> 之前都是使用的 <code>microtasks</code>，但是<code>microtasks</code> 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 <code>macrotasks</code> 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 <code>microtasks</code>，但在特殊情况下会使用 <code>macrotasks</code>，比如 <code>v-on</code>。</li>
<li>对于实现 <code>macrotasks</code> ，会先判断是否能使用 <code>setImmediate</code> ，不能的话降级为 <code>MessageChannel</code> ，以上都不行的话就使用 <code>setTimeout</code></li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> setImmediate <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span>setImmediate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  macroTimerFunc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">setImmediate</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>
  <span class="token keyword">typeof</span> MessageChannel <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span>
  <span class="token punctuation">(</span><span class="token function">isNative</span><span class="token punctuation">(</span>MessageChannel<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token comment" spellcheck="true">// PhantomJS</span>
    MessageChannel<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object MessageChannelConstructor]'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> channel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> port <span class="token operator">=</span> channel<span class="token punctuation">.</span>port2
  channel<span class="token punctuation">.</span>port1<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> flushCallbacks
  macroTimerFunc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  macroTimerFunc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>以上代码很简单，就是判断能不能使用相应的<code>API</code></p>
</blockquote>
<h2 id="29-React常考知识点"><a href="#29-React常考知识点" class="headerlink" title="29 React常考知识点"></a>29 React常考知识点</h2><h3 id="29-1-生命周期"><a href="#29-1-生命周期" class="headerlink" title="29.1 生命周期"></a>29.1 生命周期</h3><blockquote>
<p>在 <code>V16</code> 版本中引入了 <code>Fiber</code> 机制。这个机制一定程度上的影响了部分生命周期的调用，并且也引入了新的 <code>2</code> 个 <code>API</code> 来解决问题</p>
</blockquote>
<blockquote>
<p>在之前的版本中，如果你拥有一个很复杂的复合组件，然后改动了最上层组件的 <code>state</code>，那么调用栈可能会很长</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/6/25/164358b0310f476c" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li>调用栈过长，再加上中间进行了复杂的操作，就可能导致长时间阻塞主线程，带来不好的用户体验。<code>Fiber</code> 就是为了解决该问题而生</li>
<li><code>Fiber</code> 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2018/6/25/164358f89595d56f" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li>对于如何区别优先级，<code>React</code> 有自己的一套逻辑。对于动画这种实时性很高的东西，也就是 <code>16 ms</code> 必须渲染一次保证不卡顿的情况下，<code>React</code> 会每 <code>16 ms</code>（以内） 暂停一下更新，返回来继续渲染动画</li>
<li>对于异步渲染，现在渲染有两个阶段：<code>reconciliation</code> 和 <code>commit</code> 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。</li>
</ul>
<p><strong>1. Reconciliation 阶段</strong></p>
<ul>
<li><code>componentWillMount</code></li>
<li><code>componentWillReceiveProps</code></li>
<li><code>shouldComponentUpdate</code></li>
<li><code>componentWillUpdate</code></li>
</ul>
<p><strong>2. Commit 阶段</strong></p>
<ul>
<li><code>componentDidMount</code></li>
<li><code>componentDidUpdate</code></li>
<li><code>componentWillUnmount</code></li>
</ul>
<blockquote>
<p>因为 <code>Reconciliation</code> 阶段是可以被打断的，所以 <code>Reconciliation</code> 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 <code>Bug</code>。由此对于 <code>Reconciliation</code> 阶段调用的几个函数，除了 <code>shouldComponentUpdate</code> 以外，其他都应该避免去使用，并且 <code>V16</code> 中也引入了新的 <code>API</code> 来解决这个问题。</p>
</blockquote>
<blockquote>
<p><code>getDerivedStateFromProps</code> 用于替换 <code>componentWillReceiveProps</code> ，该函数会在初始化和 <code>update</code> 时被调用</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">ExampleComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// Initialize state in constructor,</span>
  <span class="token comment" spellcheck="true">// Or with a property initializer.</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevState<span class="token punctuation">.</span>someMirroredValue <span class="token operator">!==</span> nextProps<span class="token punctuation">.</span>someValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        derivedData<span class="token punctuation">:</span> <span class="token function">computeDerivedState</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span><span class="token punctuation">,</span>
        someMirroredValue<span class="token punctuation">:</span> nextProps<span class="token punctuation">.</span>someValue
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// Return null to indicate no change to state.</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>getSnapshotBeforeUpdate</code> 用于替换 <code>componentWillUpdate</code> ，该函数会在 <code>update</code> 后 <code>DOM</code> 更新前被调用，用于读取最新的 <code>DOM</code> 数据</p>
</blockquote>
<blockquote>
<p>更多详情 <a href="http://blog.poetries.top/2018/11/18/react-lifecircle" target="_blank" rel="noopener">http://blog.poetries.top/2018/11/18/react-lifecircle</a></p>
</blockquote>
<h3 id="29-2-setState"><a href="#29-2-setState" class="headerlink" title="29.2 setState"></a>29.2 setState</h3><ul>
<li><code>setState</code> 在 <code>React</code> 中是经常使用的一个 <code>API</code>，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个 <code>API</code> 是异步的。</li>
<li>首先  <code>setState</code>   的调用并不会马上引起   <code>state</code>  的改变，并且如果你一次调用了多个   <code>setState</code>   ，那么结果可能并不如你期待的一样。</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 初始化 `count` 为 0</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -> 0</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -> 0</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>第一，两次的打印都为 <code>0</code>，因为 <code>setState</code> 是个异步 <code>API</code>，只有同步代码运行完毕才会执行。<code>setState</code> 异步的原因我认为在于，<code>setState</code> 可能会导致 <code>DOM</code> 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。</li>
<li>第一，两次的打印都为 <code>0</code>，因为 <code>setState</code> 是个异步 API，只有同步代码运行完毕才会执行。<code>setState</code> 异步的原因我认为在于，<code>setState</code> 可能会导致 <code>DOM</code> 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。</li>
</ul>
<pre class="line-numbers language-js"><code class="language-js">Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>  
  <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>当然你也可以通过以下方式来实现调用三次 <code>setState</code>使得 <code>count</code> 为 <code>3</code></p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prevState<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prevState<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prevState<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>如果你想在每次调用 <code>setState</code> 后获得正确的 <code>state</code>，可以通过如下代码实现</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prevState<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> prevState<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>更多详情 <a href="http://blog.poetries.top/2018/12/20/react-setState" target="_blank" rel="noopener">http://blog.poetries.top/2018/12/20/react-setState</a></p>
</blockquote>
<h3 id="29-3-性能优化"><a href="#29-3-性能优化" class="headerlink" title="29.3 性能优化"></a>29.3 性能优化</h3><ul>
<li>在 <code>shouldComponentUpdate</code> 函数中我们可以通过返回布尔值来决定当前组件是否需要更新。这层代码逻辑可以是简单地浅比较一下当前 <code>state</code> 和之前的 <code>state</code> 是否相同，也可以是判断某个值更新了才触发组件更新。一般来说不推荐完整地对比当前 <code>state</code> 和之前的 <code>state</code> 是否相同，因为组件更新触发可能会很频繁，这样的完整对比性能开销会有点大，可能会造成得不偿失的情况。</li>
<li>当然如果真的想完整对比当前 <code>state</code> 和之前的 <code>state</code> 是否相同，并且不影响性能也是行得通的，可以通过 <code>immutable</code> 或者 <code>immer</code> 这些库来生成不可变对象。这类库对于操作大规模的数据来说会提升不错的性能，并且一旦改变数据就会生成一个新的对象，对比前后 <code>state</code> 是否一致也就方便多了，同时也很推荐阅读下 <code>immer</code> 的源码实现</li>
<li>另外如果只是单纯的浅比较一下，可以直接使用 <code>PureComponent</code>，底层就是实现了浅比较 <code>state</code></li>
</ul>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">></span>
        PureComponent
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>这时候你可能会考虑到函数组件就不能使用这种方式了，如果你使用 <code>16.6.0</code> 之后的版本的话，可以使用 <code>React.memo</code> 来实现相同的功能</p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> Test <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">></span>
        PureComponent
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>通过这种方式我们就可以既实现了 <code>shouldComponentUpdate</code> 的浅比较，又能够使用函数组件</p>
</blockquote>
<h3 id="29-4-通信"><a href="#29-4-通信" class="headerlink" title="29.4 通信"></a>29.4 通信</h3><p><strong>1. 父子通信</strong></p>
<ul>
<li>父组件通过 <code>props</code> 传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。</li>
<li>这种父子通信方式也就是典型的单向数据流，父组件通过 <code>props</code> 传递数据，子组件不能直接修改 <code>props</code>， 而是必须通过调用父组件函数的方式告知父组件修改数据。</li>
</ul>
<p><strong>2. 兄弟组件通信</strong></p>
<blockquote>
<p>对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件</p>
</blockquote>
<p><strong>3. 跨多层次组件通信</strong></p>
<blockquote>
<p>如果你使用 <code>16.3</code> 以上版本的话，对于这种情况可以使用 <code>Context API</code></p>
</blockquote>
<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 创建 Context，可以在开始就传入值</span>
<span class="token keyword">const</span> StateContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  render <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token comment" spellcheck="true">// value 就是传入 Context 中的值</span>
      <span class="token operator">&lt;</span>StateContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token string">'yck'</span><span class="token operator">></span>
        <span class="token operator">&lt;</span>Child <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>StateContext<span class="token punctuation">.</span>Provider<span class="token operator">></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  render <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>ThemeContext<span class="token punctuation">.</span>Consumer<span class="token operator">></span>
        <span class="token comment" spellcheck="true">// 取出值</span>
        <span class="token punctuation">{</span>context <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>
          name is <span class="token punctuation">{</span> context <span class="token punctuation">}</span>
        <span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ThemeContext<span class="token punctuation">.</span>Consumer<span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>4. 任意组件</strong></p>
<blockquote>
<p>这种方式可以通过 <code>Redux</code> 或者 <code>Event Bus</code> 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况</p>
</blockquote>
<h2 id="30-监控"><a href="#30-监控" class="headerlink" title="30 监控"></a>30 监控</h2><blockquote>
<p>更新中…</p>
</blockquote>
<h2 id="31-TCP-UDP"><a href="#31-TCP-UDP" class="headerlink" title="31 TCP/UDP"></a>31 TCP/UDP</h2><blockquote>
<p>更新中…</p>
</blockquote>
<h2 id="32-HTTP-TLS"><a href="#32-HTTP-TLS" class="headerlink" title="32 HTTP/TLS"></a>32 HTTP/TLS</h2><blockquote>
<p>更新中…</p>
</blockquote>
<h2 id="33-HTTP2-0"><a href="#33-HTTP2-0" class="headerlink" title="33 HTTP2.0"></a>33 HTTP2.0</h2><blockquote>
<p>更新中…</p>
</blockquote>
<h2 id="34-输入URL到页面渲染流程"><a href="#34-输入URL到页面渲染流程" class="headerlink" title="34 输入URL到页面渲染流程"></a>34 输入URL到页面渲染流程</h2><blockquote>
<p>更新中…</p>
</blockquote>
<h2 id="35-设计模式"><a href="#35-设计模式" class="headerlink" title="35 设计模式"></a>35 设计模式</h2><blockquote>
<p>更新中…</p>
</blockquote>
<h2 id="36-常见数据结构"><a href="#36-常见数据结构" class="headerlink" title="36 常见数据结构"></a>36 常见数据结构</h2><blockquote>
<p>更新中…</p>
</blockquote>
<h2 id="37-常考算法题解析"><a href="#37-常考算法题解析" class="headerlink" title="37 常考算法题解析"></a>37 常考算法题解析</h2><blockquote>
<p>更新中…</p>
</blockquote>
<h2 id="38-css常考面试题解析"><a href="#38-css常考面试题解析" class="headerlink" title="38 css常考面试题解析"></a>38 css常考面试题解析</h2><blockquote>
<p>更新中…</p>
</blockquote>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        

        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2017/06/04/002.前端知识体系/005.精华篇/001.精华篇之高频考点知识/" target="_blank" rel="external">http://www.chenya.site/2017/06/04/002.前端知识体系/005.精华篇/001.精华篇之高频考点知识/</a>
        
    </div>
    
    <footer>
        <a href="http://www.chenya.site">
            <img src="/img/gruffalo.jpg" alt="陈亚">
            陈亚
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端知识体系/">前端知识体系</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/精华篇/">精华篇</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/高频考点/">高频考点</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.chenya.site/2017/06/04/002.前端知识体系/005.精华篇/001.精华篇之高频考点知识/&title=《精华篇-01.高频考点知识》 — 陈亚的个人主页&pic=http://www.chenya.site/img/gruffalo.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.chenya.site/2017/06/04/002.前端知识体系/005.精华篇/001.精华篇之高频考点知识/&title=《精华篇-01.高频考点知识》 — 陈亚的个人主页&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.chenya.site/2017/06/04/002.前端知识体系/005.精华篇/001.精华篇之高频考点知识/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《精华篇-01.高频考点知识》 — 陈亚的个人主页&url=http://www.chenya.site/2017/06/04/002.前端知识体系/005.精华篇/001.精华篇之高频考点知识/&via=http://www.chenya.site" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.chenya.site/2017/06/04/002.前端知识体系/005.精华篇/001.精华篇之高频考点知识/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/06/12/002.前端知识体系/006.精简篇/001.简版篇之CSS相关知识/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">简版篇-01.CSS相关知识</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/05/26/002.前端知识体系/004.通识篇/003.通识篇之计算机基础算法知识/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">通识篇-03.计算机基础算法知识</h4>
      </a>
    </div>
  
</nav>



    











    <!-- 暂时写在这里引入，之后放在全局 -->
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'true' == 'true',
            appId: "THkD2SIN9zTrX2dQQfkloGeG-gzGzoHsz",
            appKey: "2gy2cgtyylBrXjOuKclSbXXM",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
        window.onload = function () {
            $(".vhead").each(function (i,v) {
                //浏览器图标
                if($(this).find(".vsys").eq(0).text().toUpperCase().includes('CHROME')){
                    $(this).find(".vsys").eq(0).prepend('<img src="../../../../img/chrome.svg"/>');
                }else if($(this).find(".vsys").eq(0).text().toUpperCase().includes('UC')){
                    $(this).find(".vsys").eq(0).prepend('<img src="../../../../img/UC浏览器.svg"/>');
                }else if($(this).find(".vsys").eq(0).text().toUpperCase().includes('OPERA')){
                    $(this).find(".vsys").eq(0).prepend('<img src="../../../../img/opera.svg"/>');
                }
                //系统图标
                if($(this).find(".vsys").eq(1).text().toUpperCase().includes('WINDOWS')){
                    $(this).find(".vsys").eq(1).prepend('<img src="../../../../img/windows.svg"/>');
                }else if($(this).find(".vsys").eq(1).text().toUpperCase().includes('APPLE')){
                    $(this).find(".vsys").eq(1).prepend('<img src="../../../../img/apple.svg"/>');
                }else if($(this).find(".vsys").eq(1).text().toUpperCase().includes('LINUX')){
                    $(this).find(".vsys").eq(1).prepend('<img src="../../../../img/linux.svg"/>');
                }
            })
        }
    </script>
    <!-- Valine Comments end -->







</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃辣条~~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>网站内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>陈亚 &copy; 2015 - 2019</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">皖ICP备18000525号-1</a><br>
                
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.chenya.site/2017/06/04/002.前端知识体系/005.精华篇/001.精华篇之高频考点知识/&title=《精华篇-01.高频考点知识》 — 陈亚的个人主页&pic=http://www.chenya.site/img/gruffalo.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.chenya.site/2017/06/04/002.前端知识体系/005.精华篇/001.精华篇之高频考点知识/&title=《精华篇-01.高频考点知识》 — 陈亚的个人主页&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.chenya.site/2017/06/04/002.前端知识体系/005.精华篇/001.精华篇之高频考点知识/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《精华篇-01.高频考点知识》 — 陈亚的个人主页&url=http://www.chenya.site/2017/06/04/002.前端知识体系/005.精华篇/001.精华篇之高频考点知识/&via=http://www.chenya.site" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.chenya.site/2017/06/04/002.前端知识体系/005.精华篇/001.精华篇之高频考点知识/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADL0lEQVR42u3aS1IDMQwFwNz/0mHLImOeLIfKKO0VRQaP21Qh9Hk84vX8ta6+//vTqyfXu+VvzPdpLWxsbOybsJ/LtX5mfZT1M1dHX7/r6vy5BRsbG3sqO9lu/Xx1hyTgrQNYfjZsbGxs7Gq4ygNMEniq4RAbGxsbO9kuLwlVi0fJpeSBEBsbG/t72HnA6LQT+oy94hc2Njb2bHa/PPQ5X7+lv42NjY39wexnceUpxF7wyAeDOgsbGxt7EjsPAEnbda9VkIOrhaQ/zo+NjY09iH22wNQv9+f7HEtRsLGxsW/O3gtCeRu4P3aTX1DBgo2NjT2CnZeN8meq6UE+PFQNnIVhHWxsbOxB7M5F5M2A/LLyYlPhQrGxsbGHsvN/+jsBppp4VMtM0UVgY2NjD2L3j753ZdVmw6O4Nvsh2NjY2DdkdwpJe688W35KAmo0o4SNjY09gt3ZqN++7aRA5VYxNjY29mj2qVLRXkO3U9gqxCZsbGzsQeyzVZdqyrEelOzs8K/FJmxsbOwPYCeN1XxEpjpSWQ2Hx8IeNjY29gj2+qHNks0ynFQHLqtDOdF7sbGxscex85HK6lGSlCMv9+dlr0LExsbGxr45Ow8/eWLQv5S9YZ1yqwMbGxt7BDsvEuXFpmojYTOd6LSTsbGxscexO0X/PF3J31vuS1ebvtjY2Njj2J304FSDobp/67TY2NjYg9jVxm0/hfifkBYlQtjY2NhD2flITb8k1B/EyXe+7IpgY2Nj35zdb7J2hjL3LrffBsbGxsaexM63eF8zoDVAGV/x5s1hY2Nj34RdHb7Mw1h+KZ3yVjIw9OLt2NjY2OPY6x/rHCKPonsDl5sFKWxsbOyvYVf/h0+uqXO5eTP4j2vFxsbGHsF+FtfZYtBeSzj/VV3ugI2NjT2IXf3Tf6pxWw11yVhPftHY2NjY89h5epCHvSSx6YzpVBOhF2fAxsbGHsfea8FWk4roQHHboFA5W9fSsLGxsb+MnSceneSheh3lEhI2Njb2F7M7haGcerbofzgVwcbGxv5IdrU8VP2008TNA2q+MzY2NvYkdh4Aku9UC/dnmwGd0hU2Njb2Ddk/wtUWEX1m2igAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, MOON: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '(‧_‧？) 人呢？';
            clearTimeout(titleTime);
        } else {
            document.title = '●-● 你肥来啦~';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
