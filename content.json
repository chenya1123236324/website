{"meta":{"title":"陈亚的个人主页","subtitle":null,"description":null,"author":"陈亚","url":"http://www.chenya.site"},"pages":[{"title":"关于我","date":"2019-01-26T07:50:42.000Z","updated":"2019-09-16T01:57:01.508Z","comments":true,"path":"about/index.html","permalink":"http://www.chenya.site/about/index.html","excerpt":"","text":"var card = { Name: 'ChenYA', Alias: 'YAYA', Description: '前端攻城狮，对web前端情有独钟,执行力很强！', Age: '90后', Hometown: '江苏苏州', NowLocation: '上海市闵行区', QQ: '1123236324', Email: '1123236324@qq.com', TechnologyStack:['Vue.js','Node.js','Koa.js','Webpack','Element UI ','ES6','HTML5','CSS3','JavaScript ','Git','微信小程序'，'...'] LoveWebsite: [ { name:'segmentfault', url:'https://segmentfault.com' }, { name:'Where Developers Learn, Share, &amp; Build Careers', url:'https://stackoverflow.com/' }, { name:'知乎', url:'https://www.zhihu.com/' }, { name:'博客园', url:'https://www.cnblogs.com/' }, { name:'掘金', url:'https://juejin.im/' }, ], Timeline: [ { time: '2017.04 ~ 至今', company: '上海晓家网络科技有限公司', job: 'Web前端开发工程师' }, { time: '2016.09 ~ 2017.04', company: '赞同科技股份有限公司', job: 'Web前端开发工程师' }, { time: '2015.06 ~ 2016.09', company: '同程网络科技股份有限公司', job: 'Web前端开发工程师' } ] }"},{"title":"","date":"2019-09-16T01:57:01.508Z","updated":"2019-09-16T01:57:01.508Z","comments":true,"path":"categories/index.html","permalink":"http://www.chenya.site/categories/index.html","excerpt":"","text":"分类 分类"},{"title":"tags","date":"2019-01-19T05:44:17.000Z","updated":"2019-09-16T01:57:01.508Z","comments":true,"path":"tags/index.html","permalink":"http://www.chenya.site/tags/index.html","excerpt":"","text":""},{"title":"作品","date":"2018-12-20T05:10:42.000Z","updated":"2019-09-16T01:57:01.509Z","comments":true,"path":"works/index.html","permalink":"http://www.chenya.site/works/index.html","excerpt":"","text":"项目经验整理 大牛家主站 - 网站端 大牛家主站 点击查看 大牛家主站 - 移动端 大牛家主站移动端 微信扫一扫查看 大牛家企业账户版 大牛家企业账户版 点击查看 大牛家开放平台 大牛家开放平台 点击查看 大牛家信息中心 大牛家信息中心 点击查看 微信小程序 - 大牛家专家对接服务 大牛家专家对接服务 大牛家管理后台 大牛家管理后台 CRM 4.0 同程旅游 - 海外玩乐 海外玩乐 点击查看"}],"posts":[{"title":"我的作品","slug":"project","date":"2019-07-19T04:04:03.000Z","updated":"2019-09-16T01:57:01.508Z","comments":true,"path":"2019/07/19/project/","link":"","permalink":"http://www.chenya.site/2019/07/19/project/","excerpt":"","text":"项目经验整理 大牛家主站 - 网站端 大牛家主站 点击查看 大牛家主站 - 移动端 大牛家主站移动端 微信扫一扫查看 大牛家企业账户版 大牛家企业账户版 点击查看 大牛家开放平台 大牛家开放平台 点击查看 大牛家信息中心 大牛家信息中心 点击查看 微信小程序 - 大牛家专家对接服务 大牛家专家对接服务 大牛家管理后台 大牛家管理后台 CRM 4.0 CRM 同程旅游 - 海外玩乐 海外玩乐 点击查看","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"项目经验","slug":"项目经验","permalink":"http://www.chenya.site/tags/项目经验/"},{"name":"作品展示","slug":"作品展示","permalink":"http://www.chenya.site/tags/作品展示/"},{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"}]},{"title":"前端网站及资源导航","slug":"001.前端资源/001.前端网站及资源导航整理","date":"2018-06-18T04:46:25.000Z","updated":"2019-09-16T01:57:01.486Z","comments":true,"path":"2018/06/18/001.前端资源/001.前端网站及资源导航整理/","link":"","permalink":"http://www.chenya.site/2018/06/18/001.前端资源/001.前端网站及资源导航整理/","excerpt":"","text":"前端网站及资源导航这里收集整理本人喜好的前端相关网站和资源等，不断更新中。有好的资源欢迎推荐（请发邮件至：`1123236324@qq.com`或者留言评论）。更详细内容请移步 陈亚的个人主页 目录 综合 社区、博客 库、框架、资源 CDN，云服务 设计、模板 交互、体验 教程、书籍 招聘、面试 其他 综合 名称 URL 简介 W3C www.w3.org www.chinaw3c.org 万维网联盟官方网站 MDN developer.mozilla.org Mozilla Developer Network，Mozilla 开发者网络 StackOverflow stackoverflow.com 最大最全的技术问答社区 SegmentFault segmentfault.com 中国开发者社区，国内的SO GitHub github.com 源码托管协作必备 码市 coding.net 国内源码托管协作，免费版5个私有仓库 CanIUse caniuse.com 兼容性速查 REPL jsfiddle.net jsbin.com repl.it ideone.com babeljs.io/repl 在线交互式解释器环境 知乎 www.zhihu.com 每日必刷，可以关注前端开发等话题 简书 www.jianshu.com 国内最优质的创作社区，可以关注前端相关专题 InfoQ www.infoq.com www.infoq.com/cn 高质量软件开发领域知识与创新传播网站 MSDN msdn.microsoft.com/zh-cn 微软开发者网络 开源中国 www.oschina.net 国内最大的开源技术社区，开源项目速查 W3School www.w3school.com.cn 在线教程，略老 社区、博客关闭的、不怎么更新的或者质量变差的不再搜集。 中文 名称 URL 简介 w3ctech www.w3ctech.com 中国最大的前端技术社区，信息量多，但良莠不齐 V2EX v2ex.com 创意工作者们的社区 掘金 juejin.im 高手分享技术社区 阮一峰 www.ruanyifeng.com/blog 阮一峰个人博客，更新频繁，推荐 div.io div.io 高质量小圈子前端社区 前端乱炖 www.html-js.com 也有很多不错的文章 w3cplus www.w3cplus.com 大漠主办的技术博客，貌似挂了 w3cfuns www.w3cfuns.com 前端综合网站，内容较杂，闲时可以随便逛逛 CSS88 www.css88.com 有一些前端库的中文文档 @愚人码头 CNodeJS cnodejs.org 国内 Node.js 开源技术社区 AlloyTeam www.alloyteam.com 腾讯全端 AlloyTeam 团队博客 FEX fex.baidu.com 百度web前端研发部 去哪儿网UED ued.qunar.com 去哪儿网UED知识库 奇舞团 75team.com 360前端团队博客 百度EFE efe.baidu.com 百度前端技术体系博客 阿里UED www.aliued.cn 阿里UED团队博客 携程UED ued.ctrip.com 携程设计委员会 百度UED ued.baidu.com 百度UED团队博客 张鑫旭 www.zhangxinxu.com/wordpress ISUX张鑫旭个人博客，很高产 酷壳 coolshell.cn 分享技术见闻，知识，趋势的博客 朴灵 html5ify.com 阿里数据平台数据产品部资深工程师朴灵 hax johnhax.net 百姓网贺师俊 司徒正美 www.cnblogs.com/rubylouvre 去哪儿网前端老大司徒正美 叶小钗 www.cnblogs.com/yexiaochai &nbsp; Ty typeof.net USTC的大牛 CSSForest blog.cssforest.org 腾讯重构大牛 99css www.99css.com ytzong 米随随 s5s5.me 刘小超博客 博客园 www.cnblogs.com 微软系为主博客 大前端 http://www.daqianduan.com 关注前端开发 设计达人 http://www.shejidaren.com 更新较频繁，但转载也较多 Be For Web http://beforweb.com 为网而生 - 原创译文博客 前端圈 fequan.com 为广州web前端人员量身打造的生态圈，主要是主题演讲，基本停更 阿里妈妈MUX mux.alimama.com 阿里妈妈MUX团队博客，基本停更 网易UED uedc.163.com 网易UED团队博客，貌似有问题 新浪UED ued.sina.com.cn 新浪UED团队博客，很久不更新了 TID tid.tenpay.com 财付通TID团队博客，很久不更新了 TQ tqtan.com 腾讯ISUX TQ，很久不更新了 winter winter-cn.cnblogs.com 阿里winter博客，很久不更新了 qiqiboy www.qiqiboy.com 金山网络qiqiboy，很久不更新了 周爱民 blog.csdn.net/aimingoo 大道至简，很久不更新了 英文 名称 URL 简介 SmashingMagazine www.smashingmagazine.com 关于coding、design、mobile、ux等综合门户 CSS-Tricks css-tricks.com CSS技巧集合 Medium medium.com 需翻墙 DailyJS dailyjs.com js相关技术博客 Tutorialzine tutorialzine.com coolest web development tutorials and resources Codrops tympanus.net/codrops web设计、开发博客 NCZOnline www.nczonline.net Nicholas C. Zakas博客，Yahoo前端leader，牛人不解释 Addy addyosmani.com/blog Addy Osmani的博客，Chrome team大牛 Steve Souders www.stevesouders.com/blog Steve Souders的博客，web performance专家 Jake Rutter www.onerutter.com Jake Rutter的博客 库、框架、资源、工具 Awesome JavaScript Awesome Web Performance Optimization Awesome CSS Awesome React Awesome Angular Awesome Node.js Awesome Vue.js Awesome React Native Awesome Weex Awesome Ant Design JS Tips CDN、云服务 名称 URL 简介 百度CDN cdn.code.baidu.com 百度静态资源公共库 360CDN libs.useso.com 360网站卫士常用前端公共库CDN，Google那几个替换很好使 微信CDN qydev.weixin.qq.com/cdn/cdnjs.html 微信前端库CDN服务 BootCDN www.bootcdn.cn Bootstrap中文网开源项目CDN库 淘宝NPM npm.taobao.org 淘宝 NPM 镜像 阿里云 www.aliyun.com 在国内首选 七牛 www.qiniu.com 七牛云，可以存一些文件视频之类 设计、模板 名称 URL 简介 Designerslist www.designerslist.info 国外设计网站导航 NAV80 nav80.com 设计师网址导航 UISDC hao.uisdc.com 又一个设计师网址导航 dribbble dribbble.com 设计师社区 behance www.behance.net Showcase &amp; Discover Creative Work UI.PARADE www.uiparade.com UI设计灵感集合 站酷 www.zcool.com.cn 我的最爱 UI中国 www.ui.cn 前身为iconfans.com dowebok www.dowebok.com 做好网站，一些代码库和素材 优设 www.uisdc.com 优秀网页设计联盟 UIRSS www.uirss.com UI设计门户网站和垂直型社区 设计达人 www.shejidaren.com 一些设计相关的文章、素材等 Color CC color.adobe.com/zh Adobe在线配色，原Kuler 配色网 www.peise.net 配色方案和颜色搭配 找字网 www.zhaozi.cn 字体大全 Chinaz font.chinaz.com 字体素材 easyicon www.easyicon.net ICON资源 flaticon www.flaticon.com 矢量ICON资源 ICONFONT www.iconfont.cn 阿里UX矢量图标库 iconpng www.iconpng.com ICON资源 brands www.brandsoftheworld.com 世界logo大全 LOGOpond logopond.com Logo大全 Mobile Patterns www.mobile-patterns.com 移动UI设计范例 交互、体验 名称 URL 简介 ISUX isux.tencent.com 腾讯社交用户体验设计 beforweb beforweb.com ISUX C7210博客 JDC jdc.jd.com 京东用户体验设计团队 IFED ifed.me 蚂蚁金服金融体验设计团队 腾讯CDC cdc.tencent.com 腾讯用户研究与体验设计中心 腾讯MXD mxd.tencent.com 腾讯移动互联网设计团队 TGideas tgideas.qq.com 腾讯游戏专业设计团队 百度MUX mux.baidu.com 百度MUX团队 教程、书籍 名称 URL 简介 慕课网 www.imooc.com 前端技能学习平台，很多好的教程 freeCodeCamp www.freecodecamp.com 在线免费学习前端编码 百度技术沙龙 www.infoq.com/cn/zones/baidu-salon 全栈综合 腾讯大讲堂 djt.qq.com 分享产品技术和成功经验 IBM developerWorks www.ibm.com/developerworks/cn 同上 极客学院 www.jikexueyuan.com 综合课程 NODESCHOOL nodeschool.io 在线Node.js入门教学 hackr hackr.io 各种各样的在线编程教程集合 node123 github.com/youyudehexie/node123 node中文资料导航 移动开发收藏夹 github.com/hoosin/mobile-web-favorites tuts+ tutsplus.com/tutorials Tutorials, inspiration and videos to help you learn. Updated daily 免费编程书籍 github.com/vhf/free-programming-books 中文 拼吾爱 www.pin5i.com 电子书资源，有钱还是要支持正版哦 Java1234 www.java1234.com 同样电子书资源 EBOOKEE www.ebookee.net 英文电子书资源 IT-BOOKS it-ebooks.info 比较全的英文电子书 招聘、面试还在51job、智联、58等投简历和找人才么，试试下面这些吧： 名称 URL 简介 拉勾网 www.lagou.com 互联网企业招聘 看准网 www.kanzhun.com 看准网主要是公司点评和面试经验，新推出的Boss直聘效率不错 Boss直聘 www.zhipin.com 和老板聊 100offer 100offer.com 程序员拍卖 猎聘网 www.liepin.com 有猎头帮助会快一些 内推网 www.neitui.me 互联网行业「内推」「直招」 LinkedIn www.linkedin.com 领英中国，高端管理人才可以碰一碰，不过Coder很少去 哪上班 www.nashangban.com 互联网企业招聘 大街网 www.dajie.com 职业社交招聘 CSDN招聘 job.csdn.net 程序员招聘 猎上网 www.hunteron.com 比猎聘名气小，可以碰碰 51猎头 www.51lietou.com 同上 约聘网 www.51yuepin.com 互联网行业约聘模式招聘 乐职 www.lezhi.com 比较新，暂时只针对IT互联网行业技术岗位 Workspace nsworkspace.com 暂时只在北京地区为iOS、Android、前端、后端四个职位提供招聘服务 实力拍 www.shilipai.net 竞拍，同上 阿里招聘 www.alijob.com 专门为电商行业招聘人才 聘宝 www.pinbot.me 依托互联网提供专业优质的招聘服务 蚂蚁招聘 www.mayizhaopin.com 一键发布到各大招聘网站 猿圈 www.oxcoder.com 企业直接在这上面出笔试题，可完成第一轮筛选，省的让人来回跑 奔翼 prinbit.com 在线协同编码，帮助判断应聘者的基础知识，沟通能力，以及更重要的编码能力 其他 - github，博客，微博，社区，Q群，V2EX… 有诚意必成 Good luck 面试资源 前端面试笔试题收集 FEX 面试问题 饿了么 Node.js 面试问题 前端面试知识点汇总 编程之法：面试和算法心得 前端资源汇总（包括前端学习、开发资源、求职面试等） 收集的前端面试题和答案 笔试面试知识整理 其他 名称 URL 简介 IT桔子 itjuzi.com IT互联网行业公司信息披露 Worktile worktile.com 创业企业协作平台 奇云测 ce.cloud.360.cn 网站速度测试 WebPageTest www.webpagetest.org 国内访问慢些 百度应用性能监测中心 developer.baidu.com/apm 百度开放服务平台的一个服务，还有很多其他的 jsperf jsperf.com JavaScript performance playground，JS性能对比测试 ATOOL www.atool.org 在线工具集合 活跃微博 ID 公司 简介 @稀土圈 # 强烈推荐，分享一些技术文章和Github项目 @w3c中国 # 万维网联盟中国办事处官方微博 @TheFrontEnd # JavaScript技术资讯、新闻、教程、深度文章。 @前端快爆 阿里巴巴 有HTML5、CSS3、JS @HTML5中国 # 中国www.html5cn.org官方微博 @GitHubDaily # 专注于分享 GitHub 最新的优质开源项目:sparkles: 持续更新中…..","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端社区","slug":"前端社区","permalink":"http://www.chenya.site/tags/前端社区/"},{"name":"前端网站","slug":"前端网站","permalink":"http://www.chenya.site/tags/前端网站/"},{"name":"前端博客","slug":"前端博客","permalink":"http://www.chenya.site/tags/前端博客/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"}]},{"title":"Vue源码学习 - event","slug":"005.vue源码学习/006.扩展/002.event","date":"2018-06-08T02:25:09.000Z","updated":"2019-09-16T01:57:01.508Z","comments":true,"path":"2018/06/08/005.vue源码学习/006.扩展/002.event/","link":"","permalink":"http://www.chenya.site/2018/06/08/005.vue源码学习/006.扩展/002.event/","excerpt":"","text":"event我们平时开发工作中，处理组件间的通讯，原生的交互，都离不开事件。对于一个组件元素，我们不仅仅可以绑定原生的 DOM 事件，还可以绑定自定义事件，非常灵活和方便。那么接下来我们从源码角度来看看它的实现原理。 为了更加直观，我们通过一个例子来分析它的实现： let Child = { template: '&lt;button @click=\"clickHandler($event)\">' + 'click me' + '&lt;/button>', methods: { clickHandler(e) { console.log('Button clicked!', e) this.$emit('select') } } } let vm = new Vue({ el: '#app', template: '&lt;div>' + '&lt;child @select=\"selectHandler\" @click.native.prevent=\"clickHandler\">&lt;/child>' + '&lt;/div>', methods: { clickHandler() { console.log('Child clicked!') }, selectHandler() { console.log('Child select!') } }, components: { Child } }) 编译先从编译阶段开始看起，在 parse 阶段，会执行 processAttrs 方法，它的定义在 src/compiler/parser/index.js 中： export const onRE = /^@|^v-on:/ export const dirRE = /^v-|^@|^:/ export const bindRE = /^:|^v-bind:/ function processAttrs (el) { const list = el.attrsList let i, l, name, rawName, value, modifiers, isProp for (i = 0, l = list.length; i &lt; l; i++) { name = rawName = list[i].name value = list[i].value if (dirRE.test(name)) { el.hasBindings = true modifiers = parseModifiers(name) if (modifiers) { name = name.replace(modifierRE, '') } if (bindRE.test(name)) { // .. } else if (onRE.test(name)) { name = name.replace(onRE, '') addHandler(el, name, value, modifiers, false, warn) } else { // ... } } else { // ... } } } function parseModifiers (name: string): Object | void { const match = name.match(modifierRE) if (match) { const ret = {} match.forEach(m => { ret[m.slice(1)] = true }) return ret } } 在对标签属性的处理过程中，判断如果是指令，首先通过 parseModifiers 解析出修饰符，然后判断如果事件的指令，则执行 addHandler(el, name, value, modifiers, false, warn) 方法，它的定义在 src/compiler/helpers.js 中： export function addHandler ( el: ASTElement, name: string, value: string, modifiers: ?ASTModifiers, important?: boolean, warn?: Function ) { modifiers = modifiers || emptyObject // warn prevent and passive modifier /* istanbul ignore if */ if ( process.env.NODE_ENV !== 'production' &amp;&amp; warn &amp;&amp; modifiers.prevent &amp;&amp; modifiers.passive ) { warn( 'passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.' ) } // check capture modifier if (modifiers.capture) { delete modifiers.capture name = '!' + name // mark the event as captured } if (modifiers.once) { delete modifiers.once name = '~' + name // mark the event as once } /* istanbul ignore if */ if (modifiers.passive) { delete modifiers.passive name = '&amp;' + name // mark the event as passive } // normalize click.right and click.middle since they don't actually fire // this is technically browser-specific, but at least for now browsers are // the only target envs that have right/middle clicks. if (name === 'click') { if (modifiers.right) { name = 'contextmenu' delete modifiers.right } else if (modifiers.middle) { name = 'mouseup' } } let events if (modifiers.native) { delete modifiers.native events = el.nativeEvents || (el.nativeEvents = {}) } else { events = el.events || (el.events = {}) } const newHandler: any = { value: value.trim() } if (modifiers !== emptyObject) { newHandler.modifiers = modifiers } const handlers = events[name] /* istanbul ignore if */ if (Array.isArray(handlers)) { important ? handlers.unshift(newHandler) : handlers.push(newHandler) } else if (handlers) { events[name] = important ? [newHandler, handlers] : [handlers, newHandler] } else { events[name] = newHandler } el.plain = false } addHandler 函数看起来长，实际上就做了 3 件事情，首先根据 modifier 修饰符对事件名 name 做处理，接着根据 modifier.native 判断是一个纯原生事件还是普通事件，分别对应 el.nativeEvents 和 el.events，最后按照 name 对事件做归类，并把回调函数的字符串保留到对应的事件中。 在我们的例子中，父组件的 child 节点生成的 el.events 和 el.nativeEvents 如下： el.events = { select: { value: 'selectHandler' } } el.nativeEvents = { click: { value: 'clickHandler', modifiers: { prevent: true } } } 子组件的 button 节点生成的 el.events 如下： el.events = { click: { value: 'clickHandler($event)' } } 然后在 codegen 的阶段，会在 genData 函数中根据 AST 元素节点上的 events 和 nativeEvents 生成 data 数据，它的定义在 src/compiler/codegen/index.js 中： export function genData (el: ASTElement, state: CodegenState): string { let data = '{' // ... if (el.events) { data += `${genHandlers(el.events, false, state.warn)},` } if (el.nativeEvents) { data += `${genHandlers(el.nativeEvents, true, state.warn)},` } // ... return data } 对于这两个属性，会调用 genHandlers 函数，定义在 src/compiler/codegen/events.js 中： export function genHandlers ( events: ASTElementHandlers, isNative: boolean, warn: Function ): string { let res = isNative ? 'nativeOn:{' : 'on:{' for (const name in events) { res += `\"${name}\":${genHandler(name, events[name])},` } return res.slice(0, -1) + '}' } const fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/ const simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/ function genHandler ( name: string, handler: ASTElementHandler | Array&lt;ASTElementHandler> ): string { if (!handler) { return 'function(){}' } if (Array.isArray(handler)) { return `[${handler.map(handler => genHandler(name, handler)).join(',')}]` } const isMethodPath = simplePathRE.test(handler.value) const isFunctionExpression = fnExpRE.test(handler.value) if (!handler.modifiers) { if (isMethodPath || isFunctionExpression) { return handler.value } /* istanbul ignore if */ if (__WEEX__ &amp;&amp; handler.params) { return genWeexHandler(handler.params, handler.value) } return `function($event){${handler.value}}` // inline statement } else { let code = '' let genModifierCode = '' const keys = [] for (const key in handler.modifiers) { if (modifierCode[key]) { genModifierCode += modifierCode[key] // left/right if (keyCodes[key]) { keys.push(key) } } else if (key === 'exact') { const modifiers: ASTModifiers = (handler.modifiers: any) genModifierCode += genGuard( ['ctrl', 'shift', 'alt', 'meta'] .filter(keyModifier => !modifiers[keyModifier]) .map(keyModifier => `$event.${keyModifier}Key`) .join('||') ) } else { keys.push(key) } } if (keys.length) { code += genKeyFilter(keys) } // Make sure modifiers like prevent and stop get executed after key filtering if (genModifierCode) { code += genModifierCode } const handlerCode = isMethodPath ? `return ${handler.value}($event)` : isFunctionExpression ? `return (${handler.value})($event)` : handler.value /* istanbul ignore if */ if (__WEEX__ &amp;&amp; handler.params) { return genWeexHandler(handler.params, code + handlerCode) } return `function($event){${code}${handlerCode}}` } } genHandlers 方法遍历事件对象 events，对同一个事件名称的事件调用 genHandler(name, events[name]) 方法，它的内容看起来多，但实际上逻辑很简单，首先先判断如果 handler 是一个数组，就遍历它然后递归调用 genHandler 方法并拼接结果，然后判断 hanlder.value 是一个函数的调用路径还是一个函数表达式， 接着对 modifiers 做判断，对于没有 modifiers 的情况，就根据 handler.value 不同情况处理，要么直接返回，要么返回一个函数包裹的表达式；对于有 modifiers 的情况，则对各种不同的 modifer 情况做不同处理，添加相应的代码串。 那么对于我们的例子而言，父组件生成的 data 串为： { on: {\"select\": selectHandler}, nativeOn: {\"click\": function($event) { $event.preventDefault(); return clickHandler($event) } } } 子组件生成的 data 串为： { on: {\"click\": function($event) { clickHandler($event) } } } 那么到这里，编译部分完了，接下来我们来看一下运行时部分是如何实现的。其实 Vue 的事件有 2 种，一种是原生 DOM 事件，一种是用户自定义事件，我们分别来看。 DOM 事件还记得我们之前在 patch 的时候执行各种 module 的钩子函数吗，当时这部分是略过的，我们之前只分析了 DOM 是如何渲染的，而 DOM 元素相关的属性、样式、事件等都是通过这些 module 的钩子函数完成设置的。 所有和 web 相关的 module 都定义在 src/platforms/web/runtime/modules 目录下，我们这次只关注目录下的 events.js 即可。 在 patch 过程中的创建阶段和更新阶段都会执行 updateDOMListeners： let target: any function updateDOMListeners (oldVnode: VNodeWithData, vnode: VNodeWithData) { if (isUndef(oldVnode.data.on) &amp;&amp; isUndef(vnode.data.on)) { return } const on = vnode.data.on || {} const oldOn = oldVnode.data.on || {} target = vnode.elm normalizeEvents(on) updateListeners(on, oldOn, add, remove, vnode.context) target = undefined } 首先获取 vnode.data.on，这就是我们之前的生成的 data 中对应的事件对象，target 是当前 vnode 对于的 DOM 对象，normalizeEvents 主要是对 v-model 相关的处理，我们之后分析 v-model 的时候会介绍，接着调用 updateListeners(on, oldOn, add, remove, vnode.context) 方法，它的定义在 src/core/vdom/helpers/update-listeners.js 中： export function updateListeners ( on: Object, oldOn: Object, add: Function, remove: Function, vm: Component ) { let name, def, cur, old, event for (name in on) { def = cur = on[name] old = oldOn[name] event = normalizeEvent(name) /* istanbul ignore if */ if (__WEEX__ &amp;&amp; isPlainObject(def)) { cur = def.handler event.params = def.params } if (isUndef(cur)) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Invalid handler for event \"${event.name}\": got ` + String(cur), vm ) } else if (isUndef(old)) { if (isUndef(cur.fns)) { cur = on[name] = createFnInvoker(cur) } add(event.name, cur, event.once, event.capture, event.passive, event.params) } else if (cur !== old) { old.fns = cur on[name] = old } } for (name in oldOn) { if (isUndef(on[name])) { event = normalizeEvent(name) remove(event.name, oldOn[name], event.capture) } } } updateListeners 的逻辑很简单，遍历 on 去添加事件监听，遍历 oldOn 去移除事件监听，关于监听和移除事件的方法都是外部传入的，因为它既处理原生 DOM 事件的添加删除，也处理自定义事件的添加删除。 对于 on 的遍历，首先获得每一个事件名，然后做 normalizeEvent 的处理： const normalizeEvent = cached((name: string): { name: string, once: boolean, capture: boolean, passive: boolean, handler?: Function, params?: Array&lt;any> } => { const passive = name.charAt(0) === '&amp;' name = passive ? name.slice(1) : name const once = name.charAt(0) === '~' // Prefixed last, checked first name = once ? name.slice(1) : name const capture = name.charAt(0) === '!' name = capture ? name.slice(1) : name return { name, once, capture, passive } }) 根据我们的的事件名的一些特殊标识（之前在 addHandler 的时候添加上的）区分出这个事件是否有 once、capture、passive 等修饰符。 处理完事件名后，又对事件回调函数做处理，对于第一次，满足 isUndef(old) 并且 isUndef(cur.fns)，会执行 cur = on[name] = createFnInvoker(cur) 方法去创建一个回调函数，然后在执行 add(event.name, cur, event.once, event.capture, event.passive, event.params) 完成一次事件绑定。我们先看一下 createFnInvoker 的实现： export function createFnInvoker (fns: Function | Array&lt;Function>): Function { function invoker () { const fns = invoker.fns if (Array.isArray(fns)) { const cloned = fns.slice() for (let i = 0; i &lt; cloned.length; i++) { cloned[i].apply(null, arguments) } } else { return fns.apply(null, arguments) } } invoker.fns = fns return invoker } 这里定义了 invoker 方法并返回，由于一个事件可能会对应多个回调函数，所以这里做了数组的判断，多个回调函数就依次调用。注意最后的赋值逻辑， invoker.fns = fns，每一次执行 invoker 函数都是从 invoker.fns 里取执行的回调函数，回到 updateListeners，当我们第二次执行该函数的时候，判断如果 cur !== old，那么只需要更改 old.fns = cur 把之前绑定的 involer.fns 赋值为新的回调函数即可，并且 通过 on[name] = old 保留引用关系，这样就保证了事件回调只添加一次，之后仅仅去修改它的回调函数的引用。 updateListeners 函数的最后遍历 oldOn 拿到事件名称，判断如果满足 isUndef(on[name])，则执行 remove(event.name, oldOn[name], event.capture) 去移除事件回调。 了解了 updateListeners 的实现后，我们来看一下在原生 DOM 事件中真正添加回调和移除回调函数的实现，它们的定义都在 src/platforms/web/runtime/modules/event.js 中： function add ( event: string, handler: Function, once: boolean, capture: boolean, passive: boolean ) { handler = withMacroTask(handler) if (once) handler = createOnceHandler(handler, event, capture) target.addEventListener( event, handler, supportsPassive ? { capture, passive } : capture ) } function remove ( event: string, handler: Function, capture: boolean, _target?: HTMLElement ) { (_target || target).removeEventListener( event, handler._withTask || handler, capture ) } add 和 remove 的逻辑很简单，就是实际上调用原生 addEventListener 和 removeEventListener，并根据参数传递一些配置，注意这里的 hanlder 会用 withMacroTask(hanlder) 包裹一下，它的定义在 src/core/util/next-tick.js 中： export function withMacroTask (fn: Function): Function { return fn._withTask || (fn._withTask = function () { useMacroTask = true const res = fn.apply(null, arguments) useMacroTask = false return res }) } 实际上就是强制在 DOM 事件的回调函数执行期间如果修改了数据，那么这些数据更改推入的队列会被当做 macroTask 在 nextTick 后执行。 自定义事件除了原生 DOM 事件，Vue 还支持了自定义事件，并且自定义事件只能作用在组件上，如果在组件上使用原生事件，需要加 .native 修饰符，普通元素上使用 .native 修饰符无效，接下来我们就来分析它的实现。 在 render 阶段，如果是一个组件节点，则通过 createComponent 创建一个组件 vnode，我们再来回顾这个方法，定义在 src/core/vdom/create-component.js 中： export function createComponent ( Ctor: Class&lt;Component> | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array&lt;VNode>, tag?: string ): VNode | Array&lt;VNode> | void { // ... const listeners = data.on data.on = data.nativeOn // ... const name = Ctor.options.name || tag const vnode = new VNode( `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`, data, undefined, undefined, undefined, context, { Ctor, propsData, listeners, tag, children }, asyncFactory ) return vnode } 我们只关注事件相关的逻辑，可以看到，它把 data.on 赋值给了 listeners，把 data.nativeOn 赋值给了 data.on，这样所有的原生 DOM 事件处理跟我们刚才介绍的一样，它是在当前组件环境中处理的。而对于自定义事件，我们把 listeners 作为 vnode 的 componentOptions 传入，它是在子组件初始化阶段中处理的，所以它的处理环境是子组件。 然后在子组件的初始化的时候，会执行 initInternalComponent 方法，它的定义在 src/core/instance/init.js 中： export function initInternalComponent (vm: Component, options: InternalComponentOptions) { const opts = vm.$options = Object.create(vm.constructor.options) // .... const vnodeComponentOptions = parentVnode.componentOptions opts._parentListeners = vnodeComponentOptions.listeners // ... } 这里拿到了父组件传入的 listeners，然后在执行 initEvents 的过程中，会处理这个 listeners，定义在 src/core/instance/events.js 中： export function initEvents (vm: Component) { vm._events = Object.create(null) vm._hasHookEvent = false // init parent attached events const listeners = vm.$options._parentListeners if (listeners) { updateComponentListeners(vm, listeners) } } 拿到 listeners 后，执行 updateComponentListeners(vm, listeners) 方法： let target: any export function updateComponentListeners ( vm: Component, listeners: Object, oldListeners: ?Object ) { target = vm updateListeners(listeners, oldListeners || {}, add, remove, vm) target = undefined } updateListeners 我们之前介绍过，所以对于自定义事件和原生 DOM 事件处理的差异就在事件添加和删除的实现上，来看一下自定义事件 add 和 remove 的实现： function add (event, fn, once) { if (once) { target.$once(event, fn) } else { target.$on(event, fn) } } function remove (event, fn) { target.$off(event, fn) } 实际上是利用 Vue 定义的事件中心，简单分析一下它的实现： export function eventsMixin (Vue: Class&lt;Component>) { const hookRE = /^hook:/ Vue.prototype.$on = function (event: string | Array&lt;string>, fn: Function): Component { const vm: Component = this if (Array.isArray(event)) { for (let i = 0, l = event.length; i &lt; l; i++) { this.$on(event[i], fn) } } else { (vm._events[event] || (vm._events[event] = [])).push(fn) // optimize hook:event cost by using a boolean flag marked at registration // instead of a hash lookup if (hookRE.test(event)) { vm._hasHookEvent = true } } return vm } Vue.prototype.$once = function (event: string, fn: Function): Component { const vm: Component = this function on () { vm.$off(event, on) fn.apply(vm, arguments) } on.fn = fn vm.$on(event, on) return vm } Vue.prototype.$off = function (event?: string | Array&lt;string>, fn?: Function): Component { const vm: Component = this // all if (!arguments.length) { vm._events = Object.create(null) return vm } // array of events if (Array.isArray(event)) { for (let i = 0, l = event.length; i &lt; l; i++) { this.$off(event[i], fn) } return vm } // specific event const cbs = vm._events[event] if (!cbs) { return vm } if (!fn) { vm._events[event] = null return vm } if (fn) { // specific handler let cb let i = cbs.length while (i--) { cb = cbs[i] if (cb === fn || cb.fn === fn) { cbs.splice(i, 1) break } } } return vm } Vue.prototype.$emit = function (event: string): Component { const vm: Component = this if (process.env.NODE_ENV !== 'production') { const lowerCaseEvent = event.toLowerCase() if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) { tip( `Event \"${lowerCaseEvent}\" is emitted in component ` + `${formatComponentName(vm)} but the handler is registered for \"${event}\". ` + `Note that HTML attributes are case-insensitive and you cannot use ` + `v-on to listen to camelCase events when using in-DOM templates. ` + `You should probably use \"${hyphenate(event)}\" instead of \"${event}\".` ) } } let cbs = vm._events[event] if (cbs) { cbs = cbs.length > 1 ? toArray(cbs) : cbs const args = toArray(arguments, 1) for (let i = 0, l = cbs.length; i &lt; l; i++) { try { cbs[i].apply(vm, args) } catch (e) { handleError(e, vm, `event handler for \"${event}\"`) } } } return vm } } 非常经典的事件中心的实现，把所有的事件用 vm._events 存储起来，当执行 vm.$on(event,fn) 的时候，按事件的名称 event 把回调函数 fn 存储起来 vm._events[event].push(fn)。当执行 vm.$emit(event) 的时候，根据事件名 event 找到所有的回调函数 let cbs = vm._events[event]，然后遍历执行所有的回调函数。当执行 vm.$off(event,fn) 的时候会移除指定事件名 event 和指定的 fn 当执行 vm.$once(event,fn) 的时候，内部就是执行 vm.$on，并且当回调函数执行一次后再通过 vm.$off 移除事件的回调，这样就确保了回调函数只执行一次。 所以对于用户自定义的事件添加和删除就是利用了这几个事件中心的 API。需要注意的事一点，vm.$emit 是给当前的 vm 上派发的实例，之所以我们常用它做父子组件通讯，是因为它的回调函数的定义是在父组件中，对于我们这个例子而言，当子组件的 button 被点击了，它通过 this.$emit(&#39;select&#39;) 派发事件，那么子组件的实例就监听到了这个 select 事件，并执行它的回调函数——定义在父组件中的 selectHandler 方法，这样就相当于完成了一次父子组件的通讯。 总结那么至此我们对 Vue 的事件实现有了进一步的了解，Vue 支持 2 种事件类型，原生 DOM 事件和自定义事件，它们主要的区别在于添加和删除事件的方式不一样，并且自定义事件的派发是往当前实例上派发，但是可以利用在父组件环境定义回调函数来实现父子组件的通讯。另外要注意一点，只有组件节点才可以添加自定义事件，并且添加原生 DOM 事件需要使用 native 修饰符；而普通元素使用 .native 修饰符是没有作用的，也只能添加原生 DOM 事件。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - 扩展介绍","slug":"005.vue源码学习/006.扩展/001.介绍","date":"2018-06-05T01:01:52.000Z","updated":"2019-09-16T01:57:01.507Z","comments":true,"path":"2018/06/05/005.vue源码学习/006.扩展/001.介绍/","link":"","permalink":"http://www.chenya.site/2018/06/05/005.vue源码学习/006.扩展/001.介绍/","excerpt":"","text":"扩展前面几章我们分析了 Vue 的核心以及编译过程，除此之外，Vue 还提供了很多好用的 feature 如 event、v-model、slot、keep-alive、transition 等等。对他们的理解有助于我们在平时开发中更好地应用这些 feature，即使出现 bug 我们也可以很从容地应对。 这一章是一个可扩展的章节，除了已分析的这些 feature 外，未来我们可能会扩展更多的内容。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - codegen","slug":"005.vue源码学习/005.编译/005.codegen","date":"2018-05-26T12:24:09.000Z","updated":"2019-09-16T01:57:01.507Z","comments":true,"path":"2018/05/26/005.vue源码学习/005.编译/005.codegen/","link":"","permalink":"http://www.chenya.site/2018/05/26/005.vue源码学习/005.编译/005.codegen/","excerpt":"","text":"codegen编译的最后一步就是把优化后的 AST 树转换成可执行的代码，这部分内容也比较多，我并不打算把所有的细节都讲了，了解整体流程即可。部分细节我们会在之后的章节配合一个具体 case 去详细讲。 为了方便理解，我们还是用之前的例子： &lt;ul :class=\"bindCls\" class=\"list\" v-if=\"isShow\"> &lt;li v-for=\"(item,index) in data\" @click=\"clickItem(index)\">{{item}}:{{index}}&lt;/li> &lt;/ul> 它经过编译，执行 const code = generate(ast, options)，生成的 render 代码串如下： with(this){ return (isShow) ? _c('ul', { staticClass: \"list\", class: bindCls }, _l((data), function(item, index) { return _c('li', { on: { \"click\": function($event) { clickItem(index) } } }, [_v(_s(item) + \":\" + _s(index))]) }) ) : _e() } 这里的 _c 函数定义在 src/core/instance/render.js 中。 vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false) 而 _l、_v 定义在 src/core/instance/render-helpers/index.js 中： export function installRenderHelpers (target: any) { target._o = markOnce target._n = toNumber target._s = toString target._l = renderList target._t = renderSlot target._q = looseEqual target._i = looseIndexOf target._m = renderStatic target._f = resolveFilter target._k = checkKeyCodes target._b = bindObjectProps target._v = createTextVNode target._e = createEmptyVNode target._u = resolveScopedSlots target._g = bindObjectListeners } 顾名思义，_c 就是执行 createElement 去创建 VNode，而 _l 对应 renderList 渲染列表；_v 对应 createTextVNode 创建文本 VNode；_e 对于 createEmptyVNode创建空的 VNode。 在 compileToFunctions 中，会把这个 render 代码串转换成函数，它的定义在 src/compler/to-function.js 中： const compiled = compile(template, options) res.render = createFunction(compiled.render, fnGenErrors) function createFunction (code, errors) { try { return new Function(code) } catch (err) { errors.push({ err, code }) return noop } } 实际上就是把 render 代码串通过 new Function 的方式转换成可执行的函数，赋值给 vm.options.render，这样当组件通过 vm._render 的时候，就会执行这个 render 函数。那么接下来我们就重点关注一下这个 render 代码串的生成过程。 generateconst code = generate(ast, options) generate 函数的定义在 src/compiler/codegen/index.js 中： export function generate ( ast: ASTElement | void, options: CompilerOptions ): CodegenResult { const state = new CodegenState(options) const code = ast ? genElement(ast, state) : '_c(\"div\")' return { render: `with(this){return ${code}}`, staticRenderFns: state.staticRenderFns } } generate 函数首先通过 genElement(ast, state) 生成 code，再把 code 用 with(this){return ${code}}} 包裹起来。这里的 state 是 CodegenState 的一个实例，稍后我们在用到它的时候会介绍它。先来看一下 genElement： export function genElement (el: ASTElement, state: CodegenState): string { if (el.staticRoot &amp;&amp; !el.staticProcessed) { return genStatic(el, state) } else if (el.once &amp;&amp; !el.onceProcessed) { return genOnce(el, state) } else if (el.for &amp;&amp; !el.forProcessed) { return genFor(el, state) } else if (el.if &amp;&amp; !el.ifProcessed) { return genIf(el, state) } else if (el.tag === 'template' &amp;&amp; !el.slotTarget) { return genChildren(el, state) || 'void 0' } else if (el.tag === 'slot') { return genSlot(el, state) } else { // component or element let code if (el.component) { code = genComponent(el.component, el, state) } else { const data = el.plain ? undefined : genData(el, state) const children = el.inlineTemplate ? null : genChildren(el, state, true) code = `_c('${el.tag}'${ data ? `,${data}` : '' // data }${ children ? `,${children}` : '' // children })` } // module transforms for (let i = 0; i &lt; state.transforms.length; i++) { code = state.transforms[i](el, code) } return code } } 基本就是判断当前 AST 元素节点的属性执行不同的代码生成函数，在我们的例子中，我们先了解一下 genFor 和 genIf。 genIfexport function genIf ( el: any, state: CodegenState, altGen?: Function, altEmpty?: string ): string { el.ifProcessed = true // avoid recursion return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty) } function genIfConditions ( conditions: ASTIfConditions, state: CodegenState, altGen?: Function, altEmpty?: string ): string { if (!conditions.length) { return altEmpty || '_e()' } const condition = conditions.shift() if (condition.exp) { return `(${condition.exp})?${ genTernaryExp(condition.block) }:${ genIfConditions(conditions, state, altGen, altEmpty) }` } else { return `${genTernaryExp(condition.block)}` } // v-if with v-once should generate code like (a)?_m(0):_m(1) function genTernaryExp (el) { return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state) } } genIf 主要是通过执行 genIfConditions，它是依次从 conditions 获取第一个 condition，然后通过对 condition.exp 去生成一段三元运算符的代码，: 后是递归调用 genIfConditions，这样如果有多个 conditions，就生成多层三元运算逻辑。这里我们暂时不考虑 v-once 的情况，所以genTernaryExp 最终是调用了 genElement。 在我们的例子中，只有一个 condition，exp 为 isShow，因此生成如下伪代码： return (isShow) ? genElement(el, state) : _e() genForexport function genFor ( el: any, state: CodegenState, altGen?: Function, altHelper?: string ): string { const exp = el.for const alias = el.alias const iterator1 = el.iterator1 ? `,${el.iterator1}` : '' const iterator2 = el.iterator2 ? `,${el.iterator2}` : '' if (process.env.NODE_ENV !== 'production' &amp;&amp; state.maybeComponent(el) &amp;&amp; el.tag !== 'slot' &amp;&amp; el.tag !== 'template' &amp;&amp; !el.key ) { state.warn( `&lt;${el.tag} v-for=\"${alias} in ${exp}\">: component lists rendered with ` + `v-for should have explicit keys. ` + `See https://vuejs.org/guide/list.html#key for more info.`, true /* tip */ ) } el.forProcessed = true // avoid recursion return `${altHelper || '_l'}((${exp}),` + `function(${alias}${iterator1}${iterator2}){` + `return ${(altGen || genElement)(el, state)}` + '})' } genFor 的逻辑很简单，首先 AST 元素节点中获取了和 for 相关的一些属性，然后返回了一个代码字符串。 在我们的例子中，exp 是 data，alias 是 item，iterator1 ，因此生成如下伪代码： _l((data), function(item, index) { return genElememt(el, state) }) genData &amp; genChildren再次回顾我们的例子，它的最外层是 ul，首先执行 genIf，它最终调用了 genElement(el, state) 去生成子节点，注意，这里的 el 仍然指向的是 ul 对应的 AST 节点，但是此时的 el.ifProcessed 为 true，所以命中最后一个 else 逻辑： // component or element let code if (el.component) { code = genComponent(el.component, el, state) } else { const data = el.plain ? undefined : genData(el, state) const children = el.inlineTemplate ? null : genChildren(el, state, true) code = `_c('${el.tag}'${ data ? `,${data}` : '' // data }${ children ? `,${children}` : '' // children })` } // module transforms for (let i = 0; i &lt; state.transforms.length; i++) { code = state.transforms[i](el, code) } return code 这里我们只关注 2 个逻辑，genData 和 genChildren： genData export function genData (el: ASTElement, state: CodegenState): string { let data = '{' // directives first. // directives may mutate the el's other properties before they are generated. const dirs = genDirectives(el, state) if (dirs) data += dirs + ',' // key if (el.key) { data += `key:${el.key},` } // ref if (el.ref) { data += `ref:${el.ref},` } if (el.refInFor) { data += `refInFor:true,` } // pre if (el.pre) { data += `pre:true,` } // record original tag name for components using \"is\" attribute if (el.component) { data += `tag:\"${el.tag}\",` } // module data generation functions for (let i = 0; i &lt; state.dataGenFns.length; i++) { data += state.dataGenFns[i](el) } // attributes if (el.attrs) { data += `attrs:{${genProps(el.attrs)}},` } // DOM props if (el.props) { data += `domProps:{${genProps(el.props)}},` } // event handlers if (el.events) { data += `${genHandlers(el.events, false, state.warn)},` } if (el.nativeEvents) { data += `${genHandlers(el.nativeEvents, true, state.warn)},` } // slot target // only for non-scoped slots if (el.slotTarget &amp;&amp; !el.slotScope) { data += `slot:${el.slotTarget},` } // scoped slots if (el.scopedSlots) { data += `${genScopedSlots(el.scopedSlots, state)},` } // component v-model if (el.model) { data += `model:{value:${ el.model.value },callback:${ el.model.callback },expression:${ el.model.expression }},` } // inline-template if (el.inlineTemplate) { const inlineTemplate = genInlineTemplate(el, state) if (inlineTemplate) { data += `${inlineTemplate},` } } data = data.replace(/,$/, '') + '}' // v-bind data wrap if (el.wrapData) { data = el.wrapData(data) } // v-on data wrap if (el.wrapListeners) { data = el.wrapListeners(data) } return data } genData 函数就是根据 AST 元素节点的属性构造出一个 data 对象字符串，这个在后面创建 VNode 的时候的时候会作为参数传入。 之前我们提到了 CodegenState 的实例 state，这里有一段关于 state 的逻辑： for (let i = 0; i &lt; state.dataGenFns.length; i++) { data += state.dataGenFns[i](el) } state.dataGenFns 的初始化在它的构造器中。 export class CodegenState { constructor (options: CompilerOptions) { // ... this.dataGenFns = pluckModuleFunction(options.modules, 'genData') // ... } } 实际上就是获取所有 modules 中的 genData 函数，其中，class module 和 style module 定义了 genData 函数。比如定义在 src/platforms/web/compiler/modules/class.js 中的 genData 方法： function genData (el: ASTElement): string { let data = '' if (el.staticClass) { data += `staticClass:${el.staticClass},` } if (el.classBinding) { data += `class:${el.classBinding},` } return data } 在我们的例子中，ul AST 元素节点定义了 el.staticClass 和 el.classBinding，因此最终生成的 data 字符串如下： { staticClass: \"list\", class: bindCls } genChildren 接下来我们再来看一下 genChildren，它的定义在 src/compiler/codegen/index.js 中： export function genChildren ( el: ASTElement, state: CodegenState, checkSkip?: boolean, altGenElement?: Function, altGenNode?: Function ): string | void { const children = el.children if (children.length) { const el: any = children[0] if (children.length === 1 &amp;&amp; el.for &amp;&amp; el.tag !== 'template' &amp;&amp; el.tag !== 'slot' ) { return (altGenElement || genElement)(el, state) } const normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0 const gen = altGenNode || genNode return `[${children.map(c => gen(c, state)).join(',')}]${ normalizationType ? `,${normalizationType}` : '' }` } } 在我们的例子中，li AST 元素节点是 ul AST 元素节点的 children 之一，满足 (children.length === 1 &amp;&amp; el.for &amp;&amp; el.tag !== &#39;template&#39; &amp;&amp; el.tag !== &#39;slot&#39;) 条件，因此通过 genElement(el, state) 生成 li AST元素节点的代码，也就回到了我们之前调用 genFor 生成的代码，把它们拼在一起生成的伪代码如下： return (isShow) ? _c('ul', { staticClass: \"list\", class: bindCls }, _l((data), function(item, index) { return genElememt(el, state) }) ) : _e() 在我们的例子中，在执行 genElememt(el, state) 的时候，el 还是 li AST 元素节点，el.forProcessed 已为 true，所以会继续执行 genData 和 genChildren 的逻辑。由于 el.events 不为空，在执行 genData 的时候，会执行 如下逻辑： if (el.events) { data += `${genHandlers(el.events, false, state.warn)},` } genHandlers 的定义在 src/compiler/codegen/events.js 中： export function genHandlers ( events: ASTElementHandlers, isNative: boolean, warn: Function ): string { let res = isNative ? 'nativeOn:{' : 'on:{' for (const name in events) { res += `\"${name}\":${genHandler(name, events[name])},` } return res.slice(0, -1) + '}' } genHandler 的逻辑就不介绍了，很大部分都是对修饰符 modifier 的处理，感兴趣同学可以自己看，对于我们的例子，它最终 genData 生成的 data 字符串如下： { on: { \"click\": function($event) { clickItem(index) } } } genChildren 的时候，会执行到如下逻辑： export function genChildren ( el: ASTElement, state: CodegenState, checkSkip?: boolean, altGenElement?: Function, altGenNode?: Function ): string | void { // ... const normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0 const gen = altGenNode || genNode return `[${children.map(c => gen(c, state)).join(',')}]${ normalizationType ? `,${normalizationType}` : '' }` } function genNode (node: ASTNode, state: CodegenState): string { if (node.type === 1) { return genElement(node, state) } if (node.type === 3 &amp;&amp; node.isComment) { return genComment(node) } else { return genText(node) } } genChildren 的就是遍历 children，然后执行 genNode 方法，根据不同的 type 执行具体的方法。在我们的例子中，li AST 元素节点的 children 是 type 为 2 的表达式 AST 元素节点，那么会执行到 genText(node) 逻辑。 export function genText (text: ASTText | ASTExpression): string { return `_v(${text.type === 2 ? text.expression : transformSpecialNewlines(JSON.stringify(text.text)) })` } 因此在我们的例子中，genChildren 生成的代码串如下： [_v(_s(item) + \":\" + _s(index))] 和之前拼在一起，最终生成的 code 如下： return (isShow) ? _c('ul', { staticClass: \"list\", class: bindCls }, _l((data), function(item, index) { return _c('li', { on: { \"click\": function($event) { clickItem(index) } } }, [_v(_s(item) + \":\" + _s(index))]) }) ) : _e() 总结这一节通过例子配合解析，我们对从 ast -&gt; code 这一步有了一些了解，编译后生成的代码就是在运行时执行的代码。由于 genCode 的内容有很多，所以我对大家的建议是没必要把所有的细节都一次性看完，我们应该根据具体一个 case，走完一条主线即可。 在之后的章节我们会对 slot 的实现做解析，我们会重新复习编译的章节，针对具体问题做具体分析，有利于我们排除干扰，对编译过程的学习有更深入的理解。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - optimize","slug":"005.vue源码学习/005.编译/004.optimize","date":"2018-05-24T15:21:15.000Z","updated":"2019-09-16T01:57:01.507Z","comments":true,"path":"2018/05/24/005.vue源码学习/005.编译/004.optimize/","link":"","permalink":"http://www.chenya.site/2018/05/24/005.vue源码学习/005.编译/004.optimize/","excerpt":"","text":"optimize当我们的模板 template 经过 parse 过程后，会输出生成 AST 树，那么接下来我们需要对这颗树做优化，optimize 的逻辑是远简单于 parse 的逻辑，所以理解起来会轻松很多。 为什么要有优化过程，因为我们知道 Vue 是数据驱动，是响应式的，但是我们的模板并不是所有数据都是响应式的，也有很多数据是首次渲染后就永远不会变化的，那么这部分数据生成的 DOM 也不会变化，我们可以在 patch 的过程跳过对他们的比对。 来看一下 optimize 方法的定义，在 src/compiler/optimizer.js 中： /** * Goal of the optimizer: walk the generated template AST tree * and detect sub-trees that are purely static, i.e. parts of * the DOM that never needs to change. * * Once we detect these sub-trees, we can: * * 1. Hoist them into constants, so that we no longer need to * create fresh nodes for them on each re-render; * 2. Completely skip them in the patching process. */ export function optimize (root: ?ASTElement, options: CompilerOptions) { if (!root) return isStaticKey = genStaticKeysCached(options.staticKeys || '') isPlatformReservedTag = options.isReservedTag || no // first pass: mark all non-static nodes. markStatic(root) // second pass: mark static roots. markStaticRoots(root, false) } function genStaticKeys (keys: string): Function { return makeMap( 'type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : '') ) } 我们在编译阶段可以把一些 AST 节点优化成静态节点，所以整个 optimize 的过程实际上就干 2 件事情，markStatic(root) 标记静态节点 ，markStaticRoots(root, false) 标记静态根。 标记静态节点function markStatic (node: ASTNode) { node.static = isStatic(node) if (node.type === 1) { // do not make component slot content static. this avoids // 1. components not able to mutate slot nodes // 2. static slot content fails for hot-reloading if ( !isPlatformReservedTag(node.tag) &amp;&amp; node.tag !== 'slot' &amp;&amp; node.attrsMap['inline-template'] == null ) { return } for (let i = 0, l = node.children.length; i &lt; l; i++) { const child = node.children[i] markStatic(child) if (!child.static) { node.static = false } } if (node.ifConditions) { for (let i = 1, l = node.ifConditions.length; i &lt; l; i++) { const block = node.ifConditions[i].block markStatic(block) if (!block.static) { node.static = false } } } } } function isStatic (node: ASTNode): boolean { if (node.type === 2) { // expression return false } if (node.type === 3) { // text return true } return !!(node.pre || ( !node.hasBindings &amp;&amp; // no dynamic bindings !node.if &amp;&amp; !node.for &amp;&amp; // not v-if or v-for or v-else !isBuiltInTag(node.tag) &amp;&amp; // not a built-in isPlatformReservedTag(node.tag) &amp;&amp; // not a component !isDirectChildOfTemplateFor(node) &amp;&amp; Object.keys(node).every(isStaticKey) )) } 首先执行 node.static = isStatic(node) isStatic 是对一个 AST 元素节点是否是静态的判断，如果是表达式，就是非静态；如果是纯文本，就是静态；对于一个普通元素，如果有 pre 属性，那么它使用了 v-pre 指令，是静态，否则要同时满足以下条件：没有使用 v-if、v-for，没有使用其它指令（不包括 v-once），非内置组件，是平台保留的标签，非带有 v-for 的 template 标签的直接子节点，节点的所有属性的 key 都满足静态 key；这些都满足则这个 AST 节点是一个静态节点。 如果这个节点是一个普通元素，则遍历它的所有 children，递归执行 markStatic。因为所有的 elseif 和 else 节点都不在 children 中， 如果节点的 ifConditions 不为空，则遍历 ifConditions 拿到所有条件中的 block，也就是它们对应的 AST 节点，递归执行 markStatic。在这些递归过程中，一旦子节点有不是 static 的情况，则它的父节点的 static 均变成 false。 标记静态根function markStaticRoots (node: ASTNode, isInFor: boolean) { if (node.type === 1) { if (node.static || node.once) { node.staticInFor = isInFor } // For a node to qualify as a static root, it should have children that // are not just static text. Otherwise the cost of hoisting out will // outweigh the benefits and it's better off to just always render it fresh. if (node.static &amp;&amp; node.children.length &amp;&amp; !( node.children.length === 1 &amp;&amp; node.children[0].type === 3 )) { node.staticRoot = true return } else { node.staticRoot = false } if (node.children) { for (let i = 0, l = node.children.length; i &lt; l; i++) { markStaticRoots(node.children[i], isInFor || !!node.for) } } if (node.ifConditions) { for (let i = 1, l = node.ifConditions.length; i &lt; l; i++) { markStaticRoots(node.ifConditions[i].block, isInFor) } } } } markStaticRoots 第二个参数是 isInFor，对于已经是 static 的节点或者是 v-once 指令的节点，node.staticInFor = isInFor。接着就是对于 staticRoot 的判断逻辑，从注释中我们可以看到，对于有资格成为 staticRoot 的节点，除了本身是一个静态节点外，必须满足拥有 children，并且 children 不能只是一个文本节点，不然的话把它标记成静态根节点的收益就很小了。 接下来和标记静态节点的逻辑一样，遍历 children 以及 ifConditions，递归执行 markStaticRoots。 回归我们之前的例子，经过 optimize 后，AST 树变成了如下： ast = { 'type': 1, 'tag': 'ul', 'attrsList': [], 'attrsMap': { ':class': 'bindCls', 'class': 'list', 'v-if': 'isShow' }, 'if': 'isShow', 'ifConditions': [{ 'exp': 'isShow', 'block': // ul ast element }], 'parent': undefined, 'plain': false, 'staticClass': 'list', 'classBinding': 'bindCls', 'static': false, 'staticRoot': false, 'children': [{ 'type': 1, 'tag': 'li', 'attrsList': [{ 'name': '@click', 'value': 'clickItem(index)' }], 'attrsMap': { '@click': 'clickItem(index)', 'v-for': '(item,index) in data' }, 'parent': // ul ast element 'plain': false, 'events': { 'click': { 'value': 'clickItem(index)' } }, 'hasBindings': true, 'for': 'data', 'alias': 'item', 'iterator1': 'index', 'static': false, 'staticRoot': false, 'children': [ 'type': 2, 'expression': '_s(item)+\":\"+_s(index)' 'text': '{{item}}:{{index}}', 'tokens': [ {'@binding':'item'}, ':', {'@binding':'index'} ], 'static': false ] }] } 我们发现每一个 AST 元素节点都多了 staic 属性，并且 type 为 1 的普通元素 AST 节点多了 staticRoot 属性。 总结那么至此我们分析完了 optimize 的过程，就是深度遍历这个 AST 树，去检测它的每一颗子树是不是静态节点，如果是静态节点则它们生成 DOM 永远不需要改变，这对运行时对模板的更新起到极大的优化作用。 我们通过 optimize 我们把整个 AST 树中的每一个 AST 元素节点标记了 static 和 staticRoot，它会影响我们接下来执行代码生成的过程。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - parse","slug":"005.vue源码学习/005.编译/003.parse","date":"2018-05-22T03:33:09.000Z","updated":"2019-09-16T01:57:01.507Z","comments":true,"path":"2018/05/22/005.vue源码学习/005.编译/003.parse/","link":"","permalink":"http://www.chenya.site/2018/05/22/005.vue源码学习/005.编译/003.parse/","excerpt":"","text":"编译过程首先就是对模板做解析，生成 AST，它是一种抽象语法树，是对源代码的抽象语法结构的树状表现形式。在很多编译技术中，如 babel 编译 ES6 的代码都会先生成 AST。 这个过程是比较复杂的，它会用到大量正则表达式对字符串解析，如果对正则不是很了解，建议先去补习正则表达式的知识。为了直观地演示 parse 的过程，我们先来看一个例子： &lt;ul :class=\"bindCls\" class=\"list\" v-if=\"isShow\"> &lt;li v-for=\"(item,index) in data\" @click=\"clickItem(index)\">{{item}}:{{index}}&lt;/li> &lt;/ul> 经过 parse 过程后，生成的 AST 如下： ast = { 'type': 1, 'tag': 'ul', 'attrsList': [], 'attrsMap': { ':class': 'bindCls', 'class': 'list', 'v-if': 'isShow' }, 'if': 'isShow', 'ifConditions': [{ 'exp': 'isShow', 'block': // ul ast element }], 'parent': undefined, 'plain': false, 'staticClass': 'list', 'classBinding': 'bindCls', 'children': [{ 'type': 1, 'tag': 'li', 'attrsList': [{ 'name': '@click', 'value': 'clickItem(index)' }], 'attrsMap': { '@click': 'clickItem(index)', 'v-for': '(item,index) in data' }, 'parent': // ul ast element 'plain': false, 'events': { 'click': { 'value': 'clickItem(index)' } }, 'hasBindings': true, 'for': 'data', 'alias': 'item', 'iterator1': 'index', 'children': [ 'type': 2, 'expression': '_s(item)+\":\"+_s(index)' 'text': '{{item}}:{{index}}', 'tokens': [ {'@binding':'item'}, ':', {'@binding':'index'} ] ] }] } 可以看到，生成的 AST 是一个树状结构，每一个节点都是一个 ast element，除了它自身的一些属性，还维护了它的父子关系，如 parent 指向它的父节点，children 指向它的所有子节点。先对 AST 有一些直观的印象，那么接下来我们来分析一下这个 AST 是如何得到的。 整体流程首先来看一下 parse 的定义，在 src/compiler/parser/index.js 中： export function parse ( template: string, options: CompilerOptions ): ASTElement | void { getFnsAndConfigFromOptions(options) parseHTML(template, { // options ... start (tag, attrs, unary) { let element = createASTElement(tag, attrs) processElement(element) treeManagement() }, end () { treeManagement() closeElement() }, chars (text: string) { handleText() createChildrenASTOfText() }, comment (text: string) { createChildrenASTOfComment() } }) return astRootElement } parse 函数的代码很长，贴一遍对同学的理解没有好处，我先把它拆成伪代码的形式，方便同学们对整体流程先有一个大致的了解。接下来我们就来分解分析每段伪代码的作用。 从 options 中获取方法和配置对应伪代码： getFnsAndConfigFromOptions(options) parse 函数的输入是 template 和 options，输出是 AST 的根节点。template 就是我们的模板字符串，而 options 实际上是和平台相关的一些配置，它的定义在 src/platforms/web/compiler/options 中： import { isPreTag, mustUseProp, isReservedTag, getTagNamespace } from '../util/index' import modules from './modules/index' import directives from './directives/index' import { genStaticKeys } from 'shared/util' import { isUnaryTag, canBeLeftOpenTag } from './util' export const baseOptions: CompilerOptions = { expectHTML: true, modules, directives, isPreTag, isUnaryTag, mustUseProp, canBeLeftOpenTag, isReservedTag, getTagNamespace, staticKeys: genStaticKeys(modules) } 这些属性和方法之所以放到 platforms 目录下是因为它们在不同的平台（web 和 weex）的实现是不同的。 我们用伪代码 getFnsAndConfigFromOptions 表示了这一过程，它的实际代码如下： warn = options.warn || baseWarn platformIsPreTag = options.isPreTag || no platformMustUseProp = options.mustUseProp || no platformGetTagNamespace = options.getTagNamespace || no transforms = pluckModuleFunction(options.modules, 'transformNode') preTransforms = pluckModuleFunction(options.modules, 'preTransformNode') postTransforms = pluckModuleFunction(options.modules, 'postTransformNode') delimiters = options.delimiters 这些方法和配置都是后续解析时候需要的，可以不用去管它们的具体作用，我们先往后看。 解析 HTML 模板对应伪代码： parseHTML(template, options) 对于 template 模板的解析主要是通过 parseHTML 函数，它的定义在 src/compiler/parser/html-parser 中： export function parseHTML (html, options) { let lastTag while (html) { if (!lastTag || !isPlainTextElement(lastTag)){ let textEnd = html.indexOf('&lt;') if (textEnd === 0) { if(matchComment) { advance(commentLength) continue } if(matchDoctype) { advance(doctypeLength) continue } if(matchEndTag) { advance(endTagLength) parseEndTag() continue } if(matchStartTag) { parseStartTag() handleStartTag() continue } } handleText() advance(textLength) } else { handlePlainTextElement() parseEndTag() } } } 由于 parseHTML 的逻辑也非常复杂，因此我也用了伪代码的方式表达，整体来说它的逻辑就是循环解析 template ，用正则做各种匹配，对于不同情况分别进行不同的处理，直到整个 template 被解析完毕。在匹配的过程中会利用 advance 函数不断前进整个模板字符串，直到字符串末尾。 function advance (n) { index += n html = html.substring(n) } 为了更加直观地说明 advance 的作用，可以通过一副图表示： advance-1 调用 advance 函数： advance(4) 得到结果： advance-2 匹配的过程中主要利用了正则表达式，如下： const attribute = /^\\s*([^\\s\"'&lt;>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=&lt;>`]+)))?/ const ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*' const qnameCapture = `((?:${ncname}\\\\:)?${ncname})` const startTagOpen = new RegExp(`^&lt;${qnameCapture}`) const startTagClose = /^\\s*(\\/?)>/ const endTag = new RegExp(`^&lt;\\\\/${qnameCapture}[^>]*>`) const doctype = /^&lt;!DOCTYPE [^>]+>/i const comment = /^&lt;!\\--/ const conditionalComment = /^&lt;!\\[/ 通过这些正则表达式，我们可以匹配注释节点、文档类型节点、开始闭合标签等。 注释节点、文档类型节点 对于注释节点和文档类型节点的匹配，如果匹配到我们仅仅做的是做前进即可。 if (comment.test(html)) { const commentEnd = html.indexOf('-->') if (commentEnd >= 0) { if (options.shouldKeepComment) { options.comment(html.substring(4, commentEnd)) } advance(commentEnd + 3) continue } } if (conditionalComment.test(html)) { const conditionalEnd = html.indexOf(']>') if (conditionalEnd >= 0) { advance(conditionalEnd + 2) continue } } const doctypeMatch = html.match(doctype) if (doctypeMatch) { advance(doctypeMatch[0].length) continue } 对于注释和条件注释节点，前进至它们的末尾位置；对于文档类型节点，则前进它自身长度的距离。 开始标签 const startTagMatch = parseStartTag() if (startTagMatch) { handleStartTag(startTagMatch) if (shouldIgnoreFirstNewline(lastTag, html)) { advance(1) } continue } 首先通过 parseStartTag 解析开始标签： function parseStartTag () { const start = html.match(startTagOpen) if (start) { const match = { tagName: start[1], attrs: [], start: index } advance(start[0].length) let end, attr while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) { advance(attr[0].length) match.attrs.push(attr) } if (end) { match.unarySlash = end[1] advance(end[0].length) match.end = index return match } } } 对于开始标签，除了标签名之外，还有一些标签相关的属性。函数先通过正则表达式 startTagOpen 匹配到开始标签，然后定义了 match 对象，接着循环去匹配开始标签中的属性并添加到 match.attrs 中，直到匹配的开始标签的闭合符结束。如果匹配到闭合符，则获取一元斜线符，前进到闭合符尾，并把当前索引赋值给 match.end。 parseStartTag 对开始标签解析拿到 match 后，紧接着会执行 handleStartTag 对 match 做处理： function handleStartTag (match) { const tagName = match.tagName const unarySlash = match.unarySlash if (expectHTML) { if (lastTag === 'p' &amp;&amp; isNonPhrasingTag(tagName)) { parseEndTag(lastTag) } if (canBeLeftOpenTag(tagName) &amp;&amp; lastTag === tagName) { parseEndTag(tagName) } } const unary = isUnaryTag(tagName) || !!unarySlash const l = match.attrs.length const attrs = new Array(l) for (let i = 0; i &lt; l; i++) { const args = match.attrs[i] if (IS_REGEX_CAPTURING_BROKEN &amp;&amp; args[0].indexOf('\"\"') === -1) { if (args[3] === '') { delete args[3] } if (args[4] === '') { delete args[4] } if (args[5] === '') { delete args[5] } } const value = args[3] || args[4] || args[5] || '' const shouldDecodeNewlines = tagName === 'a' &amp;&amp; args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines attrs[i] = { name: args[1], value: decodeAttr(value, shouldDecodeNewlines) } } if (!unary) { stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs }) lastTag = tagName } if (options.start) { options.start(tagName, attrs, unary, match.start, match.end) } } handleStartTag 的核心逻辑很简单，先判断开始标签是否是一元标签，类似 &lt;img&gt;、&lt;br/&gt; 这样，接着对 match.attrs 遍历并做了一些处理，最后判断如果非一元标签，则往 stack 里 push 一个对象，并且把 tagName 赋值给 lastTag。至于 stack 的作用，稍后我会介绍。 最后调用了 options.start 回调函数，并传入一些参数，这个回调函数的作用稍后我会详细介绍。 闭合标签 const endTagMatch = html.match(endTag) if (endTagMatch) { const curIndex = index advance(endTagMatch[0].length) parseEndTag(endTagMatch[1], curIndex, index) continue } 先通过正则 endTag 匹配到闭合标签，然后前进到闭合标签末尾，然后执行 parseEndTag 方法对闭合标签做解析。 function parseEndTag (tagName, start, end) { let pos, lowerCasedTagName if (start == null) start = index if (end == null) end = index if (tagName) { lowerCasedTagName = tagName.toLowerCase() } if (tagName) { for (pos = stack.length - 1; pos >= 0; pos--) { if (stack[pos].lowerCasedTag === lowerCasedTagName) { break } } } else { pos = 0 } if (pos >= 0) { for (let i = stack.length - 1; i >= pos; i--) { if (process.env.NODE_ENV !== 'production' &amp;&amp; (i > pos || !tagName) &amp;&amp; options.warn ) { options.warn( `tag &lt;${stack[i].tag}> has no matching end tag.` ) } if (options.end) { options.end(stack[i].tag, start, end) } } stack.length = pos lastTag = pos &amp;&amp; stack[pos - 1].tag } else if (lowerCasedTagName === 'br') { if (options.start) { options.start(tagName, [], true, start, end) } } else if (lowerCasedTagName === 'p') { if (options.start) { options.start(tagName, [], false, start, end) } if (options.end) { options.end(tagName, start, end) } } } parseEndTag 的核心逻辑很简单，在介绍之前我们回顾一下在执行 handleStartTag 的时候，对于非一元标签（有 endTag）我们都把它构造成一个对象压入到 stack 中，如图所示： stack 那么对于闭合标签的解析，就是倒序 stack，找到第一个和当前 endTag 匹配的元素。如果是正常的标签匹配，那么 stack 的最后一个元素应该和当前的 endTag 匹配，但是考虑到如下错误情况： &lt;div>&lt;span>&lt;/div> 这个时候当 endTag 为 &lt;/div&gt; 的时候，从 stack 尾部找到的标签是 &lt;span&gt;，就不能匹配，因此这种情况会报警告。匹配后把栈到 pos 位置的都弹出，并从 stack 尾部拿到 lastTag。 最后调用了 options.end 回调函数，并传入一些参数，这个回调函数的作用稍后我会详细介绍。 文本 let text, rest, next if (textEnd >= 0) { rest = html.slice(textEnd) while ( !endTag.test(rest) &amp;&amp; !startTagOpen.test(rest) &amp;&amp; !comment.test(rest) &amp;&amp; !conditionalComment.test(rest) ) { next = rest.indexOf('&lt;', 1) if (next &lt; 0) break textEnd += next rest = html.slice(textEnd) } text = html.substring(0, textEnd) advance(textEnd) } if (textEnd &lt; 0) { text = html html = '' } if (options.chars &amp;&amp; text) { options.chars(text) } 接下来判断 textEnd 是否大于等于 0 的，满足则说明到从当前位置到 textEnd 位置都是文本，并且如果 &lt; 是纯文本中的字符，就继续找到真正的文本结束的位置，然后前进到结束的位置。 再继续判断 textEnd 小于 0 的情况，则说明整个 template 解析完毕了，把剩余的 html 都赋值给了 text。 最后调用了 options.chars 回调函数，并传 text 参数，这个回调函数的作用稍后我会详细介绍。 因此，在循环解析整个 template 的过程中，会根据不同的情况，去执行不同的回调函数，下面我们来看看这些回调函数的作用。 处理开始标签对应伪代码： start (tag, attrs, unary) { let element = createASTElement(tag, attrs) processElement(element) treeManagement() } 当解析到开始标签的时候，最后会执行 start 回调函数，函数主要就做 3 件事情，创建 AST 元素，处理 AST 元素，AST 树管理。下面我们来分别来看这几个过程。 创建 AST 元素 // check namespace. // inherit parent ns if there is one const ns = (currentParent &amp;&amp; currentParent.ns) || platformGetTagNamespace(tag) // handle IE svg bug /* istanbul ignore if */ if (isIE &amp;&amp; ns === 'svg') { attrs = guardIESVGBug(attrs) } let element: ASTElement = createASTElement(tag, attrs, currentParent) if (ns) { element.ns = ns } export function createASTElement ( tag: string, attrs: Array&lt;Attr>, parent: ASTElement | void ): ASTElement { return { type: 1, tag, attrsList: attrs, attrsMap: makeAttrsMap(attrs), parent, children: [] } } 通过 createASTElement 方法去创建一个 AST 元素，并添加了 namespace。可以看到，每一个 AST 元素就是一个普通的 JavaScript 对象，其中，type 表示 AST 元素类型，tag 表示标签名，attrsList 表示属性列表，attrsMap 表示属性映射表，parent 表示父的 AST 元素，children 表示子 AST 元素集合。 处理 AST 元素 if (isForbiddenTag(element) &amp;&amp; !isServerRendering()) { element.forbidden = true process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + `&lt;${tag}>` + ', as they will not be parsed.' ) } // apply pre-transforms for (let i = 0; i &lt; preTransforms.length; i++) { element = preTransforms[i](element, options) || element } if (!inVPre) { processPre(element) if (element.pre) { inVPre = true } } if (platformIsPreTag(element.tag)) { inPre = true } if (inVPre) { processRawAttrs(element) } else if (!element.processed) { // structural directives processFor(element) processIf(element) processOnce(element) // element-scope stuff processElement(element, options) } 首先是对模块 preTransforms 的调用，其实所有模块的 preTransforms、 transforms 和 postTransforms 的定义都在 src/platforms/web/compiler/modules 目录中，这部分我们暂时不会介绍，之后会结合具体的例子说。接着判断 element 是否包含各种指令通过 processXXX 做相应的处理，处理的结果就是扩展 AST 元素的属性。这里我并不会一一介绍所有的指令处理，而是结合我们当前的例子，我们来看一下 processFor 和 processIf： export function processFor (el: ASTElement) { let exp if ((exp = getAndRemoveAttr(el, 'v-for'))) { const res = parseFor(exp) if (res) { extend(el, res) } else if (process.env.NODE_ENV !== 'production') { warn( `Invalid v-for expression: ${exp}` ) } } } export const forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/ export const forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/ const stripParensRE = /^\\(|\\)$/g export function parseFor (exp: string): ?ForParseResult { const inMatch = exp.match(forAliasRE) if (!inMatch) return const res = {} res.for = inMatch[2].trim() const alias = inMatch[1].trim().replace(stripParensRE, '') const iteratorMatch = alias.match(forIteratorRE) if (iteratorMatch) { res.alias = alias.replace(forIteratorRE, '') res.iterator1 = iteratorMatch[1].trim() if (iteratorMatch[2]) { res.iterator2 = iteratorMatch[2].trim() } } else { res.alias = alias } return res } processFor 就是从元素中拿到 v-for 指令的内容，然后分别解析出 for、alias、iterator1、iterator2 等属性的值添加到 AST 的元素上。就我们的示例 v-for=&quot;(item,index) in data&quot; 而言，解析出的的 for 是 data，alias 是 item，iterator1 是 index，没有 iterator2。 function processIf (el) { const exp = getAndRemoveAttr(el, 'v-if') if (exp) { el.if = exp addIfCondition(el, { exp: exp, block: el }) } else { if (getAndRemoveAttr(el, 'v-else') != null) { el.else = true } const elseif = getAndRemoveAttr(el, 'v-else-if') if (elseif) { el.elseif = elseif } } } export function addIfCondition (el: ASTElement, condition: ASTIfCondition) { if (!el.ifConditions) { el.ifConditions = [] } el.ifConditions.push(condition) } processIf 就是从元素中拿 v-if 指令的内容，如果拿到则给 AST 元素添加 if 属性和 ifConditions 属性；否则尝试拿 v-else 指令及 v-else-if 指令的内容，如果拿到则给 AST 元素分别添加 else 和 elseif 属性。 AST 树管理 我们在处理开始标签的时候为每一个标签创建了一个 AST 元素，在不断解析模板创建 AST 元素的时候，我们也要为它们建立父子关系，就像 DOM 元素的父子关系那样。 AST 树管理相关代码如下： function checkRootConstraints (el) { if (process.env.NODE_ENV !== 'production') { if (el.tag === 'slot' || el.tag === 'template') { warnOnce( `Cannot use &lt;${el.tag}> as component root element because it may ` + 'contain multiple nodes.' ) } if (el.attrsMap.hasOwnProperty('v-for')) { warnOnce( 'Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.' ) } } } // tree management if (!root) { root = element checkRootConstraints(root) } else if (!stack.length) { // allow root elements with v-if, v-else-if and v-else if (root.if &amp;&amp; (element.elseif || element.else)) { checkRootConstraints(element) addIfCondition(root, { exp: element.elseif, block: element }) } else if (process.env.NODE_ENV !== 'production') { warnOnce( `Component template should contain exactly one root element. ` + `If you are using v-if on multiple elements, ` + `use v-else-if to chain them instead.` ) } } if (currentParent &amp;&amp; !element.forbidden) { if (element.elseif || element.else) { processIfConditions(element, currentParent) } else if (element.slotScope) { // scoped slot currentParent.plain = false const name = element.slotTarget || '\"default\"' ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element } else { currentParent.children.push(element) element.parent = currentParent } } if (!unary) { currentParent = element stack.push(element) } else { closeElement(element) } AST 树管理的目标是构建一颗 AST 树，本质上它要维护 root 根节点和当前父节点 currentParent。为了保证元素可以正确闭合，这里也利用了 stack 栈的数据结构，和我们之前解析模板时用到的 stack 类似。 当我们在处理开始标签的时候，判断如果有 currentParent，会把当前 AST 元素 push 到 currentParent.chilldren 中，同时把 AST 元素的 parent 指向 currentParent。 接着就是更新 currentParent 和 stack ，判断当前如果不是一个一元标签，我们要把它生成的 AST 元素 push 到 stack 中，并且把当前的 AST 元素赋值给 currentParent。 stack 和 currentParent 除了在处理开始标签的时候会变化，在处理闭合标签的时候也会变化，因此整个 AST 树管理要结合闭合标签的处理逻辑看。 处理闭合标签对应伪代码： end () { treeManagement() closeElement() } 当解析到闭合标签的时候，最后会执行 end 回调函数： // remove trailing whitespace const element = stack[stack.length - 1] const lastNode = element.children[element.children.length - 1] if (lastNode &amp;&amp; lastNode.type === 3 &amp;&amp; lastNode.text === ' ' &amp;&amp; !inPre) { element.children.pop() } // pop stack stack.length -= 1 currentParent = stack[stack.length - 1] closeElement(element) 首先处理了尾部空格的情况，然后把 stack 的元素弹一个出栈，并把 stack 最后一个元素赋值给 currentParent，这样就保证了当遇到闭合标签的时候，可以正确地更新 stack 的长度以及 currentParent 的值，这样就维护了整个 AST 树。 最后执行了 closeElement(elment)： function closeElement (element) { // check pre state if (element.pre) { inVPre = false } if (platformIsPreTag(element.tag)) { inPre = false } // apply post-transforms for (let i = 0; i &lt; postTransforms.length; i++) { postTransforms[i](element, options) } } closeElement 逻辑很简单，就是更新一下 inVPre 和 inPre 的状态，以及执行 postTransforms 函数，这些我们暂时都不必了解。 处理文本内容对应伪代码： chars (text: string) { handleText() createChildrenASTOfText() } 除了处理开始标签和闭合标签，我们还会在解析模板的过程中去处理一些文本内容： const children = currentParent.children text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text) // only preserve whitespace if its not right after a starting tag : preserveWhitespace &amp;&amp; children.length ? ' ' : '' if (text) { let res if (!inVPre &amp;&amp; text !== ' ' &amp;&amp; (res = parseText(text, delimiters))) { children.push({ type: 2, expression: res.expression, tokens: res.tokens, text }) } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') { children.push({ type: 3, text }) } } 文本构造的 AST 元素有 2 种类型，一种是有表达式的，type 为 2，一种是纯文本，type 为 3。在我们的例子中，文本就是 :，是个表达式，通过执行 parseText(text, delimiters) 对文本解析，它的定义在 src/compiler/parser/text-parsre.js 中： const defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g const regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g const buildRegex = cached(delimiters => { const open = delimiters[0].replace(regexEscapeRE, '\\\\$&amp;') const close = delimiters[1].replace(regexEscapeRE, '\\\\$&amp;') return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g') }) export function parseText ( text: string, delimiters?: [string, string] ): TextParseResult | void { const tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE if (!tagRE.test(text)) { return } const tokens = [] const rawTokens = [] let lastIndex = tagRE.lastIndex = 0 let match, index, tokenValue while ((match = tagRE.exec(text))) { index = match.index // push text token if (index > lastIndex) { rawTokens.push(tokenValue = text.slice(lastIndex, index)) tokens.push(JSON.stringify(tokenValue)) } // tag token const exp = parseFilters(match[1].trim()) tokens.push(`_s(${exp})`) rawTokens.push({ '@binding': exp }) lastIndex = index + match[0].length } if (lastIndex &lt; text.length) { rawTokens.push(tokenValue = text.slice(lastIndex)) tokens.push(JSON.stringify(tokenValue)) } return { expression: tokens.join('+'), tokens: rawTokens } } parseText 首先根据分隔符（默认是双大括号）构造了文本匹配的正则表达式，然后再循环匹配文本，遇到普通文本就 push 到 rawTokens 和 tokens 中，如果是表达式就转换成 _s(${exp}) push 到 tokens 中，以及转换成 {@binding:exp} push 到 rawTokens 中。 对于我们的例子 :，tokens 就是 [_s(item),&#39;&quot;:&quot;&#39;,_s(index)]；rawTokens 就是 [{&#39;@binding&#39;:&#39;item&#39;},&#39;:&#39;,{&#39;@binding&#39;:&#39;index&#39;}]。那么返回的对象如下： return { expression: '_s(item)+\":\"+_s(index)', tokens: [{'@binding':'item'},':',{'@binding':'index'}] } 流程图 parse 总结那么至此，parse 的过程就分析完了，看似复杂，但我们可以抛开细节理清它的整体流程。parse 的目标是把 template 模板字符串转换成 AST 树，它是一种用 JavaScript 对象的形式来描述整个模板。那么整个 parse 的过程是利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的回调函数，来达到构造 AST 树的目的。 AST 元素节点总共有 3 种类型，type 为 1 表示是普通元素，为 2 表示是表达式，为 3 表示是纯文本。其实这里我觉得源码写的不够友好，这种是典型的魔术数字，如果转换成用常量表达会更利于源码阅读。 当 AST 树构造完毕，下一步就是 optimize 优化这颗树。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - 编译入口","slug":"005.vue源码学习/005.编译/002.编译入口","date":"2018-05-19T02:25:55.000Z","updated":"2019-09-16T01:57:01.507Z","comments":true,"path":"2018/05/19/005.vue源码学习/005.编译/002.编译入口/","link":"","permalink":"http://www.chenya.site/2018/05/19/005.vue源码学习/005.编译/002.编译入口/","excerpt":"","text":"编译入口当我们使用 Runtime + Compiler 的 Vue.js，它的入口是 src/platforms/web/entry-runtime-with-compiler.js，看一下它对 $mount 函数的定义： const mount = Vue.prototype.$mount Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean ): Component { el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Do not mount Vue to &lt;html> or &lt;body> - mount to normal elements instead.` ) return this } const options = this.$options // resolve template/el and convert to render function if (!options.render) { let template = options.template if (template) { if (typeof template === 'string') { if (template.charAt(0) === '#') { template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) { warn( `Template element not found or is empty: ${options.template}`, this ) } } } else if (template.nodeType) { template = template.innerHTML } else { if (process.env.NODE_ENV !== 'production') { warn('invalid template option:' + template, this) } return this } } else if (el) { template = getOuterHTML(el) } if (template) { /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { mark('compile') } const { render, staticRenderFns } = compileToFunctions(template, { shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments }, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { mark('compile end') measure(`vue ${this._name} compile`, 'compile', 'compile end') } } } return mount.call(this, el, hydrating) } 这段函数逻辑之前分析过，关于编译的入口就是在这里： const { render, staticRenderFns } = compileToFunctions(template, { shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments }, this) options.render = render options.staticRenderFns = staticRenderFns compileToFunctions 方法就是把模板 template 编译生成 render 以及 staticRenderFns，它的定义在 src/platforms/web/compiler/index.js 中： import { baseOptions } from './options' import { createCompiler } from 'compiler/index' const { compile, compileToFunctions } = createCompiler(baseOptions) export { compile, compileToFunctions } 可以看到 compileToFunctions 方法实际上是 createCompiler 方法的返回值，该方法接收一个编译配置参数，接下来我们来看一下 createCompiler 方法的定义，在 src/compiler/index.js 中： // `createCompilerCreator` allows creating compilers that use alternative // parser/optimizer/codegen, e.g the SSR optimizing compiler. // Here we just export a default compiler using the default parts. export const createCompiler = createCompilerCreator(function baseCompile ( template: string, options: CompilerOptions ): CompiledResult { const ast = parse(template.trim(), options) if (options.optimize !== false) { optimize(ast, options) } const code = generate(ast, options) return { ast, render: code.render, staticRenderFns: code.staticRenderFns } }) createCompiler 方法实际上是通过调用 createCompilerCreator 方法返回的，该方法传入的参数是一个函数，真正的编译过程都在这个 baseCompile 函数里执行，那么 createCompilerCreator 又是什么呢，它的定义在 src/compiler/create-compiler.js 中： export function createCompilerCreator (baseCompile: Function): Function { return function createCompiler (baseOptions: CompilerOptions) { function compile ( template: string, options?: CompilerOptions ): CompiledResult { const finalOptions = Object.create(baseOptions) const errors = [] const tips = [] finalOptions.warn = (msg, tip) => { (tip ? tips : errors).push(msg) } if (options) { // merge custom modules if (options.modules) { finalOptions.modules = (baseOptions.modules || []).concat(options.modules) } // merge custom directives if (options.directives) { finalOptions.directives = extend( Object.create(baseOptions.directives || null), options.directives ) } // copy other options for (const key in options) { if (key !== 'modules' &amp;&amp; key !== 'directives') { finalOptions[key] = options[key] } } } const compiled = baseCompile(template, finalOptions) if (process.env.NODE_ENV !== 'production') { errors.push.apply(errors, detectErrors(compiled.ast)) } compiled.errors = errors compiled.tips = tips return compiled } return { compile, compileToFunctions: createCompileToFunctionFn(compile) } } } 可以看到该方法返回了一个 createCompiler 的函数，它接收一个 baseOptions 的参数，返回的是一个对象，包括 compile 方法属性和 compileToFunctions 属性，这个 compileToFunctions 对应的就是 $mount 函数调用的 compileToFunctions 方法，它是调用 createCompileToFunctionFn 方法的返回值，我们接下来看一下 createCompileToFunctionFn 方法，它的定义在 src/compiler/to-function/js 中： export function createCompileToFunctionFn (compile: Function): Function { const cache = Object.create(null) return function compileToFunctions ( template: string, options?: CompilerOptions, vm?: Component ): CompiledFunctionResult { options = extend({}, options) const warn = options.warn || baseWarn delete options.warn /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production') { // detect possible CSP restriction try { new Function('return 1') } catch (e) { if (e.toString().match(/unsafe-eval|CSP/)) { warn( 'It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.' ) } } } // check cache const key = options.delimiters ? String(options.delimiters) + template : template if (cache[key]) { return cache[key] } // compile const compiled = compile(template, options) // check compilation errors/tips if (process.env.NODE_ENV !== 'production') { if (compiled.errors &amp;&amp; compiled.errors.length) { warn( `Error compiling template:\\n\\n${template}\\n\\n` + compiled.errors.map(e => `- ${e}`).join('\\n') + '\\n', vm ) } if (compiled.tips &amp;&amp; compiled.tips.length) { compiled.tips.forEach(msg => tip(msg, vm)) } } // turn code into functions const res = {} const fnGenErrors = [] res.render = createFunction(compiled.render, fnGenErrors) res.staticRenderFns = compiled.staticRenderFns.map(code => { return createFunction(code, fnGenErrors) }) // check function generation errors. // this should only happen if there is a bug in the compiler itself. // mostly for codegen development use /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production') { if ((!compiled.errors || !compiled.errors.length) &amp;&amp; fnGenErrors.length) { warn( `Failed to generate render function:\\n\\n` + fnGenErrors.map(({ err, code }) => `${err.toString()} in\\n\\n${code}\\n`).join('\\n'), vm ) } } return (cache[key] = res) } } 至此我们总算找到了 compileToFunctions 的最终定义，它接收 3 个参数、编译模板 template，编译配置 options 和 Vue 实例 vm。核心的编译过程就一行代码： const compiled = compile(template, options) compile 函数在执行 createCompileToFunctionFn 的时候作为参数传入，它是 createCompiler 函数中定义的 compile 函数，如下： function compile ( template: string, options?: CompilerOptions ): CompiledResult { const finalOptions = Object.create(baseOptions) const errors = [] const tips = [] finalOptions.warn = (msg, tip) => { (tip ? tips : errors).push(msg) } if (options) { // merge custom modules if (options.modules) { finalOptions.modules = (baseOptions.modules || []).concat(options.modules) } // merge custom directives if (options.directives) { finalOptions.directives = extend( Object.create(baseOptions.directives || null), options.directives ) } // copy other options for (const key in options) { if (key !== 'modules' &amp;&amp; key !== 'directives') { finalOptions[key] = options[key] } } } const compiled = baseCompile(template, finalOptions) if (process.env.NODE_ENV !== 'production') { errors.push.apply(errors, detectErrors(compiled.ast)) } compiled.errors = errors compiled.tips = tips return compiled } compile 函数执行的逻辑是先处理配置参数，真正执行编译过程就一行代码： const compiled = baseCompile(template, finalOptions) baseCompile 在执行 createCompilerCreator 方法时作为参数传入，如下： export const createCompiler = createCompilerCreator(function baseCompile ( template: string, options: CompilerOptions ): CompiledResult { const ast = parse(template.trim(), options) optimize(ast, options) const code = generate(ast, options) return { ast, render: code.render, staticRenderFns: code.staticRenderFns } }) 所以编译的入口我们终于找到了，它主要就是执行了如下几个逻辑： 解析模板字符串生成 AST const ast = parse(template.trim(), options) 优化语法树 optimize(ast, options) 生成代码 const code = generate(ast, options) 那么接下来的章节我会带大家去逐步分析这几个过程。 总结编译入口逻辑之所以这么绕，是因为 Vue.js 在不同的平台下都会有编译的过程，因此编译过程中的依赖的配置 baseOptions 会有所不同。而编译过程会多次执行，但这同一个平台下每一次的编译过程配置又是相同的，为了不让这些配置在每次编译过程都通过参数传入，Vue.js 利用了函数柯里化的技巧很好的实现了 baseOptions 的参数保留。同样，Vue.js 也是利用函数柯里化技巧把基础的编译过程函数抽出来，通过 createCompilerCreator(baseCompile) 的方式把真正编译的过程和其它逻辑如对编译配置处理、缓存处理等剥离开，这样的设计还是非常巧妙的。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - 编译介绍","slug":"005.vue源码学习/005.编译/001.编译介绍","date":"2018-05-16T03:02:18.000Z","updated":"2019-09-16T01:57:01.507Z","comments":true,"path":"2018/05/16/005.vue源码学习/005.编译/001.编译介绍/","link":"","permalink":"http://www.chenya.site/2018/05/16/005.vue源码学习/005.编译/001.编译介绍/","excerpt":"","text":"编译之前我们分析过模板到真实 DOM 渲染的过程，中间有一个环节是把模板编译成 render 函数，这个过程我们把它称作编译。 虽然我们可以直接为组件编写 render 函数，但是编写 template 模板更加直观，也更符合我们的开发习惯。 Vue.js 提供了 2 个版本，一个是 Runtime + Compiler 的，一个是 Runtime only 的，前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，需要借助 webpack 的 vue-loader 事先把模板编译成 render函数。 这一章我们就来分析编译的过程，对编译过程的了解会让我们对 Vue 的指令、内置组件等有更好的理解。不过由于编译的过程是一个相对复杂的过程，我们只要求理解整体的流程、输入和输出即可，对于细节我们不必抠太细。有些细节比如对于 slot 的处理我们可以在之后去分析插槽实现的时候再详细分析。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - 原理图","slug":"005.vue源码学习/004.响应式原理/009.原理图","date":"2018-05-12T03:26:42.000Z","updated":"2019-09-16T01:57:01.506Z","comments":true,"path":"2018/05/12/005.vue源码学习/004.响应式原理/009.原理图/","link":"","permalink":"http://www.chenya.site/2018/05/12/005.vue源码学习/004.响应式原理/009.原理图/","excerpt":"","text":"原理图","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - 组件更新","slug":"005.vue源码学习/004.响应式原理/008.组件更新","date":"2018-04-22T02:59:10.000Z","updated":"2019-09-16T01:57:01.506Z","comments":true,"path":"2018/04/22/005.vue源码学习/004.响应式原理/008.组件更新/","link":"","permalink":"http://www.chenya.site/2018/04/22/005.vue源码学习/004.响应式原理/008.组件更新/","excerpt":"","text":"组件更新在组件化章节，我们介绍了 Vue 的组件化实现过程，不过我们只讲了 Vue 组件的创建过程，并没有涉及到组件数据发生变化，更新组件的过程。而通过我们这一章对数据响应式原理的分析，了解到当数据发生变化的时候，会触发渲染 watcher 的回调函数，进而执行组件的更新过程，接下来我们来详细分析这一过程。 updateComponent = () => { vm._update(vm._render(), hydrating) } new Watcher(vm, updateComponent, noop, { before () { if (vm._isMounted) { callHook(vm, 'beforeUpdate') } } }, true /* isRenderWatcher */) 组件的更新还是调用了 vm._update 方法，我们再回顾一下这个方法，它的定义在 src/core/instance/lifecycle.js 中： Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) { const vm: Component = this // ... const prevVnode = vm._vnode if (!prevVnode) { // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) } else { // updates vm.$el = vm.__patch__(prevVnode, vnode) } // ... } 组件更新的过程，会执行 vm.$el = vm.__patch__(prevVnode, vnode)，它仍然会调用 patch 函数，在 src/core/vdom/patch.js 中定义： return function patch (oldVnode, vnode, hydrating, removeOnly) { if (isUndef(vnode)) { if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return } let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) { // empty mount (likely as component), create new root element isInitialPatch = true createElm(vnode, insertedVnodeQueue) } else { const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) { // patch existing root node patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) } else { if (isRealElement) { // ... } // replacing existing element const oldElm = oldVnode.elm const parentElm = nodeOps.parentNode(oldElm) // create new node createElm( vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a // leaving transition. Only happens when combining transition + // keep-alive + HOCs. (#4590) oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) // update parent placeholder node element, recursively if (isDef(vnode.parent)) { let ancestor = vnode.parent const patchable = isPatchable(vnode) while (ancestor) { for (let i = 0; i &lt; cbs.destroy.length; ++i) { cbs.destroy[i](ancestor) } ancestor.elm = vnode.elm if (patchable) { for (let i = 0; i &lt; cbs.create.length; ++i) { cbs.create[i](emptyNode, ancestor) } // #6513 // invoke insert hooks that may have been merged by create hooks. // e.g. for directives that uses the \"inserted\" hook. const insert = ancestor.data.hook.insert if (insert.merged) { // start at index 1 to avoid re-invoking component mounted hook for (let i = 1; i &lt; insert.fns.length; i++) { insert.fns[i]() } } } else { registerRef(ancestor) } ancestor = ancestor.parent } } // destroy old node if (isDef(parentElm)) { removeVnodes(parentElm, [oldVnode], 0, 0) } else if (isDef(oldVnode.tag)) { invokeDestroyHook(oldVnode) } } } invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch) return vnode.elm } 这里执行 patch 的逻辑和首次渲染是不一样的，因为 oldVnode 不为空，并且它和 vnode 都是 VNode 类型，接下来会通过 sameVNode(oldVnode, vnode) 判断它们是否是相同的 VNode 来决定走不同的更新逻辑： function sameVnode (a, b) { return ( a.key === b.key &amp;&amp; ( ( a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) ) || ( isTrue(a.isAsyncPlaceholder) &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; isUndef(b.asyncFactory.error) ) ) ) } sameVnode 的逻辑非常简单，如果两个 vnode 的 key 不相等，则是不同的；否则继续判断对于同步组件，则判断 isComment、data、input 类型等是否相同，对于异步组件，则判断 asyncFactory 是否相同。 所以根据新旧 vnode 是否为 sameVnode，会走到不同的更新逻辑，我们先来说一下不同的情况。 新旧节点不同如果新旧 vnode 不同，那么更新的逻辑非常简单，它本质上是要替换已存在的节点，大致分为 3 步 创建新节点 const oldElm = oldVnode.elm const parentElm = nodeOps.parentNode(oldElm) // create new node createElm( vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a // leaving transition. Only happens when combining transition + // keep-alive + HOCs. (#4590) oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) 以当前旧节点为参考节点，创建新的节点，并插入到 DOM 中，createElm 的逻辑我们之前分析过。 更新父的占位符节点 // update parent placeholder node element, recursively if (isDef(vnode.parent)) { let ancestor = vnode.parent const patchable = isPatchable(vnode) while (ancestor) { for (let i = 0; i &lt; cbs.destroy.length; ++i) { cbs.destroy[i](ancestor) } ancestor.elm = vnode.elm if (patchable) { for (let i = 0; i &lt; cbs.create.length; ++i) { cbs.create[i](emptyNode, ancestor) } // #6513 // invoke insert hooks that may have been merged by create hooks. // e.g. for directives that uses the \"inserted\" hook. const insert = ancestor.data.hook.insert if (insert.merged) { // start at index 1 to avoid re-invoking component mounted hook for (let i = 1; i &lt; insert.fns.length; i++) { insert.fns[i]() } } } else { registerRef(ancestor) } ancestor = ancestor.parent } } 我们只关注主要逻辑即可，找到当前 vnode 的父的占位符节点，先执行各个 module 的 destroy 的钩子函数，如果当前占位符是一个可挂载的节点，则执行 module 的 create 钩子函数。对于这些钩子函数的作用，在之后的章节会详细介绍。 删除旧节点 // destroy old node if (isDef(parentElm)) { removeVnodes(parentElm, [oldVnode], 0, 0) } else if (isDef(oldVnode.tag)) { invokeDestroyHook(oldVnode) } 把 oldVnode 从当前 DOM 树中删除，如果父节点存在，则执行 removeVnodes 方法： function removeVnodes (parentElm, vnodes, startIdx, endIdx) { for (; startIdx &lt;= endIdx; ++startIdx) { const ch = vnodes[startIdx] if (isDef(ch)) { if (isDef(ch.tag)) { removeAndInvokeRemoveHook(ch) invokeDestroyHook(ch) } else { // Text node removeNode(ch.elm) } } } } function removeAndInvokeRemoveHook (vnode, rm) { if (isDef(rm) || isDef(vnode.data)) { let i const listeners = cbs.remove.length + 1 if (isDef(rm)) { // we have a recursively passed down rm callback // increase the listeners count rm.listeners += listeners } else { // directly removing rm = createRmCb(vnode.elm, listeners) } // recursively invoke hooks on child component root node if (isDef(i = vnode.componentInstance) &amp;&amp; isDef(i = i._vnode) &amp;&amp; isDef(i.data)) { removeAndInvokeRemoveHook(i, rm) } for (i = 0; i &lt; cbs.remove.length; ++i) { cbs.remove[i](vnode, rm) } if (isDef(i = vnode.data.hook) &amp;&amp; isDef(i = i.remove)) { i(vnode, rm) } else { rm() } } else { removeNode(vnode.elm) } } function invokeDestroyHook (vnode) { let i, j const data = vnode.data if (isDef(data)) { if (isDef(i = data.hook) &amp;&amp; isDef(i = i.destroy)) i(vnode) for (i = 0; i &lt; cbs.destroy.length; ++i) cbs.destroy[i](vnode) } if (isDef(i = vnode.children)) { for (j = 0; j &lt; vnode.children.length; ++j) { invokeDestroyHook(vnode.children[j]) } } } 删除节点逻辑很简单，就是遍历待删除的 vnodes 做删除，其中 removeAndInvokeRemoveHook 的作用是从 DOM 中移除节点并执行 module 的 remove 钩子函数，并对它的子节点递归调用 removeAndInvokeRemoveHook 函数；invokeDestroyHook 是执行 module 的 destory 钩子函数以及 vnode 的 destory 钩子函数，并对它的子 vnode 递归调用 invokeDestroyHook 函数；removeNode 就是调用平台的 DOM API 去把真正的 DOM 节点移除。 在之前介绍组件生命周期的时候提到 beforeDestroy &amp; destroyed 这两个生命周期钩子函数，它们就是在执行 invokeDestroyHook 过程中，执行了 vnode 的 destory 钩子函数，它的定义在 src/core/vdom/create-component.js 中： const componentVNodeHooks = { destroy (vnode: MountedComponentVNode) { const { componentInstance } = vnode if (!componentInstance._isDestroyed) { if (!vnode.data.keepAlive) { componentInstance.$destroy() } else { deactivateChildComponent(componentInstance, true /* direct */) } } } } 当组件并不是 keepAlive 的时候，会执行 componentInstance.$destroy() 方法，然后就会执行 beforeDestroy &amp; destroyed 两个钩子函数。 新旧节点相同对于新旧节点不同的情况，这种创建新节点 -&gt; 更新占位符节点 -&gt; 删除旧节点的逻辑是很容易理解的。还有一种组件 vnode 的更新情况是新旧节点相同，它会调用 patchVNode 方法，它的定义在 src/core/vdom/patch.js 中： function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) { if (oldVnode === vnode) { return } const elm = vnode.elm = oldVnode.elm if (isTrue(oldVnode.isAsyncPlaceholder)) { if (isDef(vnode.asyncFactory.resolved)) { hydrate(oldVnode.elm, vnode, insertedVnodeQueue) } else { vnode.isAsyncPlaceholder = true } return } // reuse element for static trees. // note we only do this if the vnode is cloned - // if the new node is not cloned it means the render functions have been // reset by the hot-reload-api and we need to do a proper re-render. if (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce)) ) { vnode.componentInstance = oldVnode.componentInstance return } let i const data = vnode.data if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) { i(oldVnode, vnode) } const oldCh = oldVnode.children const ch = vnode.children if (isDef(data) &amp;&amp; isPatchable(vnode)) { for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode) } if (isUndef(vnode.text)) { if (isDef(oldCh) &amp;&amp; isDef(ch)) { if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) } else if (isDef(ch)) { if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '') addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) } else if (isDef(oldCh)) { removeVnodes(elm, oldCh, 0, oldCh.length - 1) } else if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, '') } } else if (oldVnode.text !== vnode.text) { nodeOps.setTextContent(elm, vnode.text) } if (isDef(data)) { if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode) } } patchVnode 的作用就是把新的 vnode patch 到旧的 vnode 上，这里我们只关注关键的核心逻辑，我把它拆成四步骤： 执行 prepatch 钩子函数 let i const data = vnode.data if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) { i(oldVnode, vnode) } 当更新的 vnode 是一个组件 vnode 的时候，会执行 prepatch 的方法，它的定义在 src/core/vdom/create-component.js 中： const componentVNodeHooks = { prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) { const options = vnode.componentOptions const child = vnode.componentInstance = oldVnode.componentInstance updateChildComponent( child, options.propsData, // updated props options.listeners, // updated listeners vnode, // new parent vnode options.children // new children ) } } prepatch 方法就是拿到新的 vnode 的组件配置以及组件实例，去执行 updateChildComponent 方法，它的定义在 src/core/instance/lifecycle.js 中： export function updateChildComponent ( vm: Component, propsData: ?Object, listeners: ?Object, parentVnode: MountedComponentVNode, renderChildren: ?Array&lt;VNode> ) { if (process.env.NODE_ENV !== 'production') { isUpdatingChildComponent = true } // determine whether component has slot children // we need to do this before overwriting $options._renderChildren const hasChildren = !!( renderChildren || // has new static slots vm.$options._renderChildren || // has old static slots parentVnode.data.scopedSlots || // has new scoped slots vm.$scopedSlots !== emptyObject // has old scoped slots ) vm.$options._parentVnode = parentVnode vm.$vnode = parentVnode // update vm's placeholder node without re-render if (vm._vnode) { // update child tree's parent vm._vnode.parent = parentVnode } vm.$options._renderChildren = renderChildren // update $attrs and $listeners hash // these are also reactive so they may trigger child update if the child // used them during render vm.$attrs = parentVnode.data.attrs || emptyObject vm.$listeners = listeners || emptyObject // update props if (propsData &amp;&amp; vm.$options.props) { toggleObserving(false) const props = vm._props const propKeys = vm.$options._propKeys || [] for (let i = 0; i &lt; propKeys.length; i++) { const key = propKeys[i] const propOptions: any = vm.$options.props // wtf flow? props[key] = validateProp(key, propOptions, propsData, vm) } toggleObserving(true) // keep a copy of raw propsData vm.$options.propsData = propsData } // update listeners listeners = listeners || emptyObject const oldListeners = vm.$options._parentListeners vm.$options._parentListeners = listeners updateComponentListeners(vm, listeners, oldListeners) // resolve slots + force update if has children if (hasChildren) { vm.$slots = resolveSlots(renderChildren, parentVnode.context) vm.$forceUpdate() } if (process.env.NODE_ENV !== 'production') { isUpdatingChildComponent = false } } updateChildComponent 的逻辑也非常简单，由于更新了 vnode，那么 vnode 对应的实例 vm 的一系列属性也会发生变化，包括占位符 vm.$vnode 的更新、slot 的更新，listeners 的更新，props 的更新等等。 执行 update 钩子函数 if (isDef(data) &amp;&amp; isPatchable(vnode)) { for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode) } 回到 patchVNode 函数，在执行完新的 vnode 的 prepatch 钩子函数，会执行所有 module 的 update 钩子函数以及用户自定义 update 钩子函数，对于 module 的钩子函数，之后我们会有具体的章节针对一些具体的 case 分析。 完成 patch 过程 const oldCh = oldVnode.children const ch = vnode.children if (isDef(data) &amp;&amp; isPatchable(vnode)) { for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode) } if (isUndef(vnode.text)) { if (isDef(oldCh) &amp;&amp; isDef(ch)) { if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) } else if (isDef(ch)) { if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '') addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) } else if (isDef(oldCh)) { removeVnodes(elm, oldCh, 0, oldCh.length - 1) } else if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, '') } } else if (oldVnode.text !== vnode.text) { nodeOps.setTextContent(elm, vnode.text) } 如果 vnode 是个文本节点且新旧文本不相同，则直接替换文本内容。如果不是文本节点，则判断它们的子节点，并分了几种情况处理： oldCh 与 ch 都存在且不相同时，使用 updateChildren 函数来更新子节点，这个后面重点讲。 2.如果只有 ch 存在，表示旧节点不需要了。如果旧的节点是文本节点则先将节点的文本清除，然后通过 addVnodes 将 ch 批量插入到新节点 elm 下。 3.如果只有 oldCh 存在，表示更新的是空节点，则需要将旧的节点通过 removeVnodes 全部清除。 4.当只有旧节点是文本节点的时候，则清除其节点文本内容。 执行 postpatch 钩子函数 if (isDef(data)) { if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode) } 再执行完 patch 过程后，会执行 postpatch 钩子函数，它是组件自定义的钩子函数，有则执行。 那么在整个 pathVnode 过程中，最复杂的就是 updateChildren 方法了，下面我们来单独介绍它。 updateChildrenfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) { let oldStartIdx = 0 let newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx, idxInOld, vnodeToMove, refElm // removeOnly is a special flag used only by &lt;transition-group> // to ensure removed elements stay in correct relative positions // during leaving transitions const canMove = !removeOnly if (process.env.NODE_ENV !== 'production') { checkDuplicateKeys(newCh) } while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) { if (isUndef(oldStartVnode)) { oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left } else if (isUndef(oldEndVnode)) { oldEndVnode = oldCh[--oldEndIdx] } else if (sameVnode(oldStartVnode, newStartVnode)) { patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] } else if (sameVnode(oldEndVnode, newEndVnode)) { patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] } else { if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) if (isUndef(idxInOld)) { // New element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) } else { vnodeToMove = oldCh[idxInOld] if (sameVnode(vnodeToMove, newStartVnode)) { patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue) oldCh[idxInOld] = undefined canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) } else { // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) } } newStartVnode = newCh[++newStartIdx] } } if (oldStartIdx > oldEndIdx) { refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue) } else if (newStartIdx > newEndIdx) { removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) } } updateChildren 的逻辑比较复杂，直接读源码比较晦涩，我们可以通过一个具体的示例来分析它。 &lt;template> &lt;div id=\"app\"> &lt;div> &lt;ul> &lt;li v-for=\"item in items\" :key=\"item.id\">{{ item.val }}&lt;/li> &lt;/ul> &lt;/div> &lt;button @click=\"change\">change&lt;/button> &lt;/div> &lt;/template> &lt;script> export default { name: 'App', data() { return { items: [ {id: 0, val: 'A'}, {id: 1, val: 'B'}, {id: 2, val: 'C'}, {id: 3, val: 'D'} ] } }, methods: { change() { this.items.reverse().push({id: 4, val: 'E'}) } } } &lt;/script> 当我们点击 change 按钮去改变数据，最终会执行到 updateChildren 去更新 li 部分的列表数据，我们通过图的方式来描述一下它的更新过程： 第一步： 第一步 第二步： 第二步 第三步： 第三步 第四步： 第四步 第五步： 第五步 第六步： 第六步 总结组件更新的过程核心就是新旧 vnode diff，对新旧节点相同以及不同的情况分别做不同的处理。新旧节点不同的更新流程是创建新节点-&gt;更新父占位符节点-&gt;删除旧节点；而新旧节点相同的更新流程是去获取它们的 children，根据不同情况做不同的更新逻辑。最复杂的情况是新旧节点相同且它们都存在子节点，那么会执行 updateChildren 逻辑，这块儿可以借助画图的方式配合理解。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - 计算属性 VS 侦听属性","slug":"005.vue源码学习/004.响应式原理/007.计算属性 VS 侦听属性","date":"2018-04-16T03:39:54.000Z","updated":"2019-09-16T01:57:01.506Z","comments":true,"path":"2018/04/16/005.vue源码学习/004.响应式原理/007.计算属性 VS 侦听属性/","link":"","permalink":"http://www.chenya.site/2018/04/16/005.vue源码学习/004.响应式原理/007.计算属性 VS 侦听属性/","excerpt":"","text":"计算属性 VS 侦听属性Vue 的组件对象支持了计算属性 computed 和侦听属性 watch 2 个选项，很多同学不了解什么时候该用 computed 什么时候该用 watch。先不回答这个问题，我们接下来从源码实现的角度来分析它们两者有什么区别。 computed计算属性的初始化是发生在 Vue 实例初始化阶段的 initState 函数中，执行了 if (opts.computed) initComputed(vm, opts.computed)，initComputed 的定义在 src/core/instance/state.js 中： const computedWatcherOptions = { computed: true } function initComputed (vm: Component, computed: Object) { // $flow-disable-line const watchers = vm._computedWatchers = Object.create(null) // computed properties are just getters during SSR const isSSR = isServerRendering() for (const key in computed) { const userDef = computed[key] const getter = typeof userDef === 'function' ? userDef : userDef.get if (process.env.NODE_ENV !== 'production' &amp;&amp; getter == null) { warn( `Getter is missing for computed property \"${key}\".`, vm ) } if (!isSSR) { // create internal watcher for the computed property. watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions ) } // component-defined computed properties are already defined on the // component prototype. We only need to define computed properties defined // at instantiation here. if (!(key in vm)) { defineComputed(vm, key, userDef) } else if (process.env.NODE_ENV !== 'production') { if (key in vm.$data) { warn(`The computed property \"${key}\" is already defined in data.`, vm) } else if (vm.$options.props &amp;&amp; key in vm.$options.props) { warn(`The computed property \"${key}\" is already defined as a prop.`, vm) } } } } 函数首先创建 vm._computedWatchers 为一个空对象，接着对 computed 对象做遍历，拿到计算属性的每一个 userDef，然后尝试获取这个 userDef 对应的 getter 函数，拿不到则在开发环境下报警告。接下来为每一个 getter 创建一个 watcher，这个 watcher 和渲染 watcher 有一点很大的不同，它是一个 computed watcher，因为 const computedWatcherOptions = { computed: true }。computed watcher 和普通 watcher 的差别我稍后会介绍。最后对判断如果 key 不是 vm 的属性，则调用 defineComputed(vm, key, userDef)，否则判断计算属性对于的 key 是否已经被 data 或者 prop 所占用，如果是的话则在开发环境报相应的警告。 那么接下来需要重点关注 defineComputed 的实现： export function defineComputed ( target: any, key: string, userDef: Object | Function ) { const shouldCache = !isServerRendering() if (typeof userDef === 'function') { sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef sharedPropertyDefinition.set = noop } else { sharedPropertyDefinition.get = userDef.get ? shouldCache &amp;&amp; userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop sharedPropertyDefinition.set = userDef.set ? userDef.set : noop } if (process.env.NODE_ENV !== 'production' &amp;&amp; sharedPropertyDefinition.set === noop) { sharedPropertyDefinition.set = function () { warn( `Computed property \"${key}\" was assigned to but it has no setter.`, this ) } } Object.defineProperty(target, key, sharedPropertyDefinition) } 这段逻辑很简单，其实就是利用 Object.defineProperty 给计算属性对应的 key 值添加 getter 和 setter，setter 通常是计算属性是一个对象，并且拥有 set 方法的时候才有，否则是一个空函数。在平时的开发场景中，计算属性有 setter 的情况比较少，我们重点关注一下 getter 部分，缓存的配置也先忽略，最终 getter 对应的是 createComputedGetter(key) 的返回值，来看一下它的定义： function createComputedGetter (key) { return function computedGetter () { const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key] if (watcher) { watcher.depend() return watcher.evaluate() } } } createComputedGetter 返回一个函数 computedGetter，它就是计算属性对应的 getter。 整个计算属性的初始化过程到此结束，我们知道计算属性是一个 computed watcher，它和普通的 watcher 有什么区别呢，为了更加直观，接下来来我们来通过一个例子来分析 computed watcher 的实现。 var vm = new Vue({ data: { firstName: 'Foo', lastName: 'Bar' }, computed: { fullName: function () { return this.firstName + ' ' + this.lastName } } }) 当初始化这个 computed watcher 实例的时候，构造函数部分逻辑稍有不同： constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean ) { // ... if (this.computed) { this.value = undefined this.dep = new Dep() } else { this.value = this.get() } } 可以发现 computed watcher 会并不会立刻求值，同时持有一个 dep 实例。 然后当我们的 render 函数执行访问到 this.fullName 的时候，就触发了计算属性的 getter，它会拿到计算属性对应的 watcher，然后执行 watcher.depend()，来看一下它的定义： /** * Depend on this watcher. Only for computed property watchers. */ depend () { if (this.dep &amp;&amp; Dep.target) { this.dep.depend() } } 注意，这时候的 Dep.target 是渲染 watcher，所以 this.dep.depend() 相当于渲染 watcher 订阅了这个 computed watcher 的变化。 然后再执行 watcher.evaluate() 去求值，来看一下它的定义： /** * Evaluate and return the value of the watcher. * This only gets called for computed property watchers. */ evaluate () { if (this.dirty) { this.value = this.get() this.dirty = false } return this.value } evaluate 的逻辑非常简单，判断 this.dirty，如果为 true 则通过 this.get() 求值，然后把 this.dirty 设置为 false。在求值过程中，会执行 value = this.getter.call(vm, vm)，这实际上就是执行了计算属性定义的 getter 函数，在我们这个例子就是执行了 return this.firstName + &#39; &#39; + this.lastName。 这里需要特别注意的是，由于 this.firstName 和 this.lastName 都是响应式对象，这里会触发它们的 getter，根据我们之前的分析，它们会把自身持有的 dep 添加到当前正在计算的 watcher 中，这个时候 Dep.target 就是这个 computed watcher。 最后通过 return this.value 拿到计算属性对应的值。我们知道了计算属性的求值过程，那么接下来看一下它依赖的数据变化后的逻辑。 一旦我们对计算属性依赖的数据做修改，则会触发 setter 过程，通知所有订阅它变化的 watcher 更新，执行 watcher.update() 方法： /* istanbul ignore else */ if (this.computed) { // A computed property watcher has two modes: lazy and activated. // It initializes as lazy by default, and only becomes activated when // it is depended on by at least one subscriber, which is typically // another computed property or a component's render function. if (this.dep.subs.length === 0) { // In lazy mode, we don't want to perform computations until necessary, // so we simply mark the watcher as dirty. The actual computation is // performed just-in-time in this.evaluate() when the computed property // is accessed. this.dirty = true } else { // In activated mode, we want to proactively perform the computation // but only notify our subscribers when the value has indeed changed. this.getAndInvoke(() => { this.dep.notify() }) } } else if (this.sync) { this.run() } else { queueWatcher(this) } 那么对于计算属性这样的 computed watcher，它实际上是有 2 种模式，lazy 和 active。如果 this.dep.subs.length === 0 成立，则说明没有人去订阅这个 computed watcher 的变化，仅仅把 this.dirty = true，只有当下次再访问这个计算属性的时候才会重新求值。在我们的场景下，渲染 watcher 订阅了这个 computed watcher 的变化，那么它会执行： this.getAndInvoke(() => { this.dep.notify() }) getAndInvoke (cb: Function) { const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) { // set new value const oldValue = this.value this.value = value this.dirty = false if (this.user) { try { cb.call(this.vm, value, oldValue) } catch (e) { handleError(e, this.vm, `callback for watcher \"${this.expression}\"`) } } else { cb.call(this.vm, value, oldValue) } } } getAndInvoke 函数会重新计算，然后对比新旧值，如果变化了则执行回调函数，那么这里这个回调函数是 this.dep.notify()，在我们这个场景下就是触发了渲染 watcher 重新渲染。 通过以上的分析，我们知道计算属性本质上就是一个 computed watcher，也了解了它的创建过程和被访问触发 getter 以及依赖更新的过程，其实这是最新的计算属性的实现，之所以这么设计是因为 Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化才会触发渲染 watcher 重新渲染，本质上是一种优化。 接下来我们来分析一下侦听属性 watch 是怎么实现的。 watch侦听属性的初始化也是发生在 Vue 的实例初始化阶段的 initState 函数中，在 computed 初始化之后，执行了： if (opts.watch &amp;&amp; opts.watch !== nativeWatch) { initWatch(vm, opts.watch) } 来看一下 initWatch 的实现，它的定义在 src/core/instance/state.js 中： function initWatch (vm: Component, watch: Object) { for (const key in watch) { const handler = watch[key] if (Array.isArray(handler)) { for (let i = 0; i &lt; handler.length; i++) { createWatcher(vm, key, handler[i]) } } else { createWatcher(vm, key, handler) } } } 这里就是对 watch 对象做遍历，拿到每一个 handler，因为 Vue 是支持 watch 的同一个 key 对应多个 handler，所以如果 handler 是一个数组，则遍历这个数组，调用 createWatcher 方法，否则直接调用 createWatcher： function createWatcher ( vm: Component, expOrFn: string | Function, handler: any, options?: Object ) { if (isPlainObject(handler)) { options = handler handler = handler.handler } if (typeof handler === 'string') { handler = vm[handler] } return vm.$watch(expOrFn, handler, options) } 这里的逻辑也很简单，首先对 hanlder 的类型做判断，拿到它最终的回调函数，最后调用 vm.$watch(keyOrFn, handler, options) 函数，$watch 是 Vue 原型上的方法，它是在执行 stateMixin 的时候定义的： Vue.prototype.$watch = function ( expOrFn: string | Function, cb: any, options?: Object ): Function { const vm: Component = this if (isPlainObject(cb)) { return createWatcher(vm, expOrFn, cb, options) } options = options || {} options.user = true const watcher = new Watcher(vm, expOrFn, cb, options) if (options.immediate) { cb.call(vm, watcher.value) } return function unwatchFn () { watcher.teardown() } } 也就是说，侦听属性 watch 最终会调用 $watch 方法，这个方法首先判断 cb 如果是一个对象，则调用 createWatcher 方法，这是因为 $watch 方法是用户可以直接调用的，它可以传递一个对象，也可以传递函数。接着执行 const watcher = new Watcher(vm, expOrFn, cb, options) 实例化了一个 watcher，这里需要注意一点这是一个 user watcher，因为 options.user = true。通过实例化 watcher 的方式，一旦我们 watch 的数据发送变化，它最终会执行 watcher 的 run 方法，执行回调函数 cb，并且如果我们设置了 immediate 为 true，则直接会执行回调函数 cb。最后返回了一个 unwatchFn 方法，它会调用 teardown 方法去移除这个 watcher。 所以本质上侦听属性也是基于 Watcher 实现的，它是一个 user watcher。其实 Watcher 支持了不同的类型，下面我们梳理一下它有哪些类型以及它们的作用。 Watcher optionsWatcher 的构造函数对 options 做的了处理，代码如下： if (options) { this.deep = !!options.deep this.user = !!options.user this.computed = !!options.computed this.sync = !!options.sync // ... } else { this.deep = this.user = this.computed = this.sync = false } 所以 watcher 总共有 4 种类型，我们来一一分析它们，看看不同的类型执行的逻辑有哪些差别。 deep watcher通常，如果我们想对一下对象做深度观测的时候，需要设置这个属性为 true，考虑到这种情况： var vm = new Vue({ data() { a: { b: 1 } }, watch: { a: { handler(newVal) { console.log(newVal) } } } }) vm.a.b = 2 这个时候是不会 log 任何数据的，因为我们是 watch 了 a 对象，只触发了 a 的 getter，并没有触发 a.b 的 getter，所以并没有订阅它的变化，导致我们对 vm.a.b = 2 赋值的时候，虽然触发了 setter，但没有可通知的对象，所以也并不会触发 watch 的回调函数了。 而我们只需要对代码做稍稍修改，就可以观测到这个变化了 watch: { a: { deep: true, handler(newVal) { console.log(newVal) } } } 这样就创建了一个 deep watcher 了，在 watcher 执行 get 求值的过程中有一段逻辑： get() { let value = this.getter.call(vm, vm) // ... if (this.deep) { traverse(value) } } 在对 watch 的表达式或者函数求值后，会调用 traverse 函数，它的定义在 src/core/observer/traverse.js 中： import { _Set as Set, isObject } from '../util/index' import type { SimpleSet } from '../util/index' import VNode from '../vdom/vnode' const seenObjects = new Set() /** * Recursively traverse an object to evoke all converted * getters, so that every nested property inside the object * is collected as a \"deep\" dependency. */ export function traverse (val: any) { _traverse(val, seenObjects) seenObjects.clear() } function _traverse (val: any, seen: SimpleSet) { let i, keys const isA = Array.isArray(val) if ((!isA &amp;&amp; !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) { return } if (val.__ob__) { const depId = val.__ob__.dep.id if (seen.has(depId)) { return } seen.add(depId) } if (isA) { i = val.length while (i--) _traverse(val[i], seen) } else { keys = Object.keys(val) i = keys.length while (i--) _traverse(val[keys[i]], seen) } } traverse 的逻辑也很简单，它实际上就是对一个对象做深层递归遍历，因为遍历过程中就是对一个子对象的访问，会触发它们的 getter 过程，这样就可以收集到依赖，也就是订阅它们变化的 watcher，这个函数实现还有一个小的优化，遍历过程中会把子响应式对象通过它们的 dep id 记录到 seenObjects，避免以后重复访问。 那么在执行了 traverse 后，我们再对 watch 的对象内部任何一个值做修改，也会调用 watcher 的回调函数了。 对 deep watcher 的理解非常重要，今后工作中如果大家观测了一个复杂对象，并且会改变对象内部深层某个值的时候也希望触发回调，一定要设置 deep 为 true，但是因为设置了 deep 后会执行 traverse 函数，会有一定的性能开销，所以一定要根据应用场景权衡是否要开启这个配置。 user watcher前面我们分析过，通过 vm.$watch 创建的 watcher 是一个 user watcher，其实它的功能很简单，在对 watcher 求值以及在执行回调函数的时候，会处理一下错误，如下： get() { if (this.user) { handleError(e, vm, `getter for watcher \"${this.expression}\"`) } else { throw e } }, getAndInvoke() { // ... if (this.user) { try { this.cb.call(this.vm, value, oldValue) } catch (e) { handleError(e, this.vm, `callback for watcher \"${this.expression}\"`) } } else { this.cb.call(this.vm, value, oldValue) } } handleError 在 Vue 中是一个错误捕获并且暴露给用户的一个利器。 computed watchercomputed watcher 几乎就是为计算属性量身定制的，我们刚才已经对它做了详细的分析，这里不再赘述了。 sync watcher在我们之前对 setter 的分析过程知道，当响应式数据发送变化后，触发了 watcher.update()，只是把这个 watcher 推送到一个队列中，在 nextTick 后才会真正执行 watcher 的回调函数。而一旦我们设置了 sync，就可以在当前 Tick 中同步执行 watcher 的回调函数。 update () { if (this.computed) { // ... } else if (this.sync) { this.run() } else { queueWatcher(this) } } 只有当我们需要 watch 的值的变化到执行 watcher 的回调函数是一个同步过程的时候才会去设置该属性为 true。 总结通过这一小节的分析我们对计算属性和侦听属性的实现有了深入的了解，计算属性本质上是 computed watcher，而侦听属性本质上是 user watcher。就应用场景而言，计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。 同时我们又了解了 watcher 的 4 个 options，通常我们会在创建 user watcher 的时候配置 deep 和 sync，可以根据不同的场景做相应的配置。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - 检测变化的注意事项","slug":"005.vue源码学习/004.响应式原理/006.检测变化的注意事项","date":"2018-04-14T03:04:45.000Z","updated":"2019-09-16T01:57:01.506Z","comments":true,"path":"2018/04/14/005.vue源码学习/004.响应式原理/006.检测变化的注意事项/","link":"","permalink":"http://www.chenya.site/2018/04/14/005.vue源码学习/004.响应式原理/006.检测变化的注意事项/","excerpt":"","text":"检测变化的注意事项通过前面几节的分析，我们对响应式数据对象以及它的 getter 和 setter 部分做了了解，但是对于一些特殊情况是需要注意的，接下来我们就从源码的角度来看 Vue 是如何处理这些特殊情况的。 对象添加属性对于使用 Object.defineProperty 实现响应式的对象，当我们去给这个对象添加一个新的属性的时候，是不能够触发它的 setter 的，比如： var vm = new Vue({ data:{ a:1 } }) // vm.b 是非响应的 vm.b = 2 但是添加新属性的场景我们在平时开发中会经常遇到，那么 Vue 为了解决这个问题，定义了一个全局 API Vue.set 方法，它在 src/core/global-api/index.js 中初始化： Vue.set = set 这个 set 方法的定义在 src/core/observer/index.js 中： /** * Set a property on an object. Adds the new property and * triggers change notification if the property doesn't * already exist. */ export function set (target: Array&lt;any> | Object, key: any, val: any): any { if (process.env.NODE_ENV !== 'production' &amp;&amp; (isUndef(target) || isPrimitive(target)) ) { warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`) } if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) { target.length = Math.max(target.length, key) target.splice(key, 1, val) return val } if (key in target &amp;&amp; !(key in Object.prototype)) { target[key] = val return val } const ob = (target: any).__ob__ if (target._isVue || (ob &amp;&amp; ob.vmCount)) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.' ) return val } if (!ob) { target[key] = val return val } defineReactive(ob.value, key, val) ob.dep.notify() return val } set 方法接收 3个参数，target 可能是数组或者是普通对象，key 代表的是数组的下标或者是对象的键值，val 代表添加的值。首先判断如果 target 是数组且 key 是一个合法的下标，则之前通过 splice 去添加进数组然后返回，这里的 splice 其实已经不仅仅是原生数组的 splice 了，稍后我会详细介绍数组的逻辑。接着又判断 key 已经存在于 target 中，则直接赋值返回，因为这样的变化是可以观测到了。接着再获取到 target.__ob__ 并赋值给 ob，之前分析过它是在 Observer 的构造函数执行的时候初始化的，表示 Observer 的一个实例，如果它不存在，则说明 target 不是一个响应式的对象，则直接赋值并返回。最后通过 defineReactive(ob.value, key, val) 把新添加的属性变成响应式对象，然后再通过 ob.dep.notify() 手动的触发依赖通知，还记得我们在给对象添加 getter 的时候有这么一段逻辑： export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean ) { // ... let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { const value = getter ? getter.call(obj) : val if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, // ... }) } 在 getter 过程中判断了 childOb，并调用了 childOb.dep.depend() 收集了依赖，这就是为什么执行 Vue.set 的时候通过 ob.dep.notify() 能够通知到 watcher，从而让添加新的属性到对象也可以检测到变化。这里如果 value 是个数组，那么就通过 dependArray 把数组每个元素也去做依赖收集。 数组接着说一下数组的情况，Vue 也是不能检测到以下变动的数组： 1.当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue 2.当你修改数组的长度时，例如：vm.items.length = newLength 对于第一种情况，可以使用：Vue.set(example1.items, indexOfItem, newValue)；而对于第二种情况，可以使用 vm.items.splice(newLength)。 我们刚才也分析到，对于 Vue.set 的实现，当 target 是数组的时候，也是通过 target.splice(key, 1, val) 来添加的，那么这里的 splice 到底有什么黑魔法，能让添加的对象变成响应式的呢。 其实之前我们也分析过，在通过 observe 方法去观察对象的时候会实例化 Observer，在它的构造函数中是专门对数组做了处理，它的定义在 src/core/observer/index.js 中。 export class Observer { constructor (value: any) { this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) { const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) } else { // ... } } } 这里我们只需要关注 value 是 Array 的情况，首先获取 augment，这里的 hasProto 实际上就是判断对象中是否存在 __proto__，如果存在则 augment 指向 protoAugment， 否则指向 copyAugment，来看一下这两个函数的定义： /** * Augment an target Object or Array by intercepting * the prototype chain using __proto__ */ function protoAugment (target, src: Object, keys: any) { /* eslint-disable no-proto */ target.__proto__ = src /* eslint-enable no-proto */ } /** * Augment an target Object or Array by defining * hidden properties. */ /* istanbul ignore next */ function copyAugment (target: Object, src: Object, keys: Array&lt;string>) { for (let i = 0, l = keys.length; i &lt; l; i++) { const key = keys[i] def(target, key, src[key]) } } protoAugment 方法是直接把 target.__proto__ 原型直接修改为 src，而 copyAugment 方法是遍历 keys，通过 def，也就是 Object.defineProperty 去定义它自身的属性值。对于大部分现代浏览器都会走到 protoAugment，那么它实际上就把 value 的原型指向了 arrayMethods，arrayMethods 的定义在 src/core/observer/array.js 中： import { def } from '../util/index' const arrayProto = Array.prototype export const arrayMethods = Object.create(arrayProto) const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse' ] /** * Intercept mutating methods and emit events */ methodsToPatch.forEach(function (method) { // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) { const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) { case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break } if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result }) }) 可以看到，arrayMethods 首先继承了 Array，然后对数组中所有能改变数组自身的方法，如 push、pop 等这些方法进行重写。重写后的方法会先执行它们本身原有的逻辑，并对能增加数组长度的 3 个方法 push、unshift、splice 方法做了判断，获取到插入的值，然后把新添加的值变成一个响应式对象，并且再调用 ob.dep.notify() 手动触发依赖通知，这就很好地解释了之前的示例中调用 vm.items.splice(newLength) 方法可以检测到变化。 总结通过这一节的分析，我们对响应式对象又有了更全面的认识，如果在实际工作中遇到了这些特殊情况，我们就可以知道如何把它们也变成响应式的对象。其实对于对象属性的删除也会用同样的问题，Vue 同样提供了 Vue.del 的全局 API，它的实现和 Vue.set 大同小异，甚至还要更简单一些，这里我就不去分析了，感兴趣的同学可以自行去了解。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"上传文件简单实现","slug":"004.koa学习/001.基础篇/007.文件上传/002.上传文件简单实现","date":"2018-04-11T15:15:19.000Z","updated":"2019-09-16T01:57:01.500Z","comments":true,"path":"2018/04/11/004.koa学习/001.基础篇/007.文件上传/002.上传文件简单实现/","link":"","permalink":"http://www.chenya.site/2018/04/11/004.koa学习/001.基础篇/007.文件上传/002.上传文件简单实现/","excerpt":"","text":"上传文件简单实现依赖模块安装依赖npm install --save busboy busboy 是用来解析出请求中文件流 例子源码demo源码 upload 封装上传文件到写入服务的方法const inspect = require('util').inspect const path = require('path') const os = require('os') const fs = require('fs') const Busboy = require('busboy') /** * 同步创建文件目录 * @param {string} dirname 目录绝对地址 * @return {boolean} 创建目录结果 */ function mkdirsSync( dirname ) { if (fs.existsSync( dirname )) { return true } else { if (mkdirsSync( path.dirname(dirname)) ) { fs.mkdirSync( dirname ) return true } } } /** * 获取上传文件的后缀名 * @param {string} fileName 获取上传文件的后缀名 * @return {string} 文件后缀名 */ function getSuffixName( fileName ) { let nameList = fileName.split('.') return nameList[nameList.length - 1] } /** * 上传文件 * @param {object} ctx koa上下文 * @param {object} options 文件上传参数 fileType文件类型， path文件存放路径 * @return {promise} */ function uploadFile( ctx, options) { let req = ctx.req let res = ctx.res let busboy = new Busboy({headers: req.headers}) // 获取类型 let fileType = options.fileType || 'common' let filePath = path.join( options.path, fileType) let mkdirResult = mkdirsSync( filePath ) return new Promise((resolve, reject) => { console.log('文件上传中...') let result = { success: false, formData: {}, } // 解析请求文件事件 busboy.on('file', function(fieldname, file, filename, encoding, mimetype) { let fileName = Math.random().toString(16).substr(2) + '.' + getSuffixName(filename) let _uploadFilePath = path.join( filePath, fileName ) let saveTo = path.join(_uploadFilePath) // 文件保存到制定路径 file.pipe(fs.createWriteStream(saveTo)) // 文件写入事件结束 file.on('end', function() { result.success = true result.message = '文件上传成功' console.log('文件上传成功！') resolve(result) }) }) // 解析表单中其他字段信息 busboy.on('field', function(fieldname, val, fieldnameTruncated, valTruncated, encoding, mimetype) { console.log('表单字段数据 [' + fieldname + ']: value: ' + inspect(val)); result.formData[fieldname] = inspect(val); }); // 解析结束事件 busboy.on('finish', function( ) { console.log('文件上结束') resolve(result) }) // 解析错误事件 busboy.on('error', function(err) { console.log('文件上出错') reject(result) }) req.pipe(busboy) }) } module.exports = { uploadFile } 入口文件const Koa = require('koa') const path = require('path') const app = new Koa() // const bodyParser = require('koa-bodyparser') const { uploadFile } = require('./util/upload') // app.use(bodyParser()) app.use( async ( ctx ) => { if ( ctx.url === '/' &amp;&amp; ctx.method === 'GET' ) { // 当GET请求时候返回表单页面 let html = ` &lt;h1>koa2 upload demo&lt;/h1> &lt;form method=\"POST\" action=\"/upload.json\" enctype=\"multipart/form-data\"> &lt;p>file upload&lt;/p> &lt;span>picName:&lt;/span>&lt;input name=\"picName\" type=\"text\" />&lt;br/> &lt;input name=\"file\" type=\"file\" />&lt;br/>&lt;br/> &lt;button type=\"submit\">submit&lt;/button> &lt;/form> ` ctx.body = html } else if ( ctx.url === '/upload.json' &amp;&amp; ctx.method === 'POST' ) { // 上传文件请求处理 let result = { success: false } let serverFilePath = path.join( __dirname, 'upload-files' ) // 上传文件事件 result = await uploadFile( ctx, { fileType: 'album', // common or album path: serverFilePath }) ctx.body = result } else { // 其他请求显示404 ctx.body = '&lt;h1>404！！！ o(╯□╰)o&lt;/h1>' } }) app.listen(3000, () => { console.log('[demo] upload-simple is starting at port 3000') }) 运行结果 upload-simple-result upload-simple-result upload-simple-result upload-simple-result","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"busboy模块","slug":"004.koa学习/001.基础篇/007.文件上传/001.busboy模块","date":"2018-04-08T11:32:29.000Z","updated":"2019-09-16T01:57:01.500Z","comments":true,"path":"2018/04/08/004.koa学习/001.基础篇/007.文件上传/001.busboy模块/","link":"","permalink":"http://www.chenya.site/2018/04/08/004.koa学习/001.基础篇/007.文件上传/001.busboy模块/","excerpt":"","text":"busboy模块快速开始安装npm install --save busboy 模块简介busboy 模块是用来解析POST请求，node原生req中的文件流。 开始使用const inspect = require('util').inspect const path = require('path') const fs = require('fs') const Busboy = require('busboy') // req 为node原生请求 const busboy = new Busboy({ headers: req.headers }) // ... // 监听文件解析事件 busboy.on('file', function(fieldname, file, filename, encoding, mimetype) { console.log(`File [${fieldname}]: filename: ${filename}`) // 文件保存到特定路径 file.pipe(fs.createWriteStream('./upload')) // 开始解析文件流 file.on('data', function(data) { console.log(`File [${fieldname}] got ${data.length} bytes`) }) // 解析文件结束 file.on('end', function() { console.log(`File [${fieldname}] Finished`) }) }) // 监听请求中的字段 busboy.on('field', function(fieldname, val, fieldnameTruncated, valTruncated) { console.log(`Field [${fieldname}]: value: ${inspect(val)}`) }) // 监听结束事件 busboy.on('finish', function() { console.log('Done parsing form!') res.writeHead(303, { Connection: 'close', Location: '/' }) res.end() }) req.pipe(busboy) 更多模块信息更多详细API可以访问npm官方文档 https://www.npmjs.com/package/busboy","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"Vue源码学习 - nextTick","slug":"005.vue源码学习/004.响应式原理/005.nextTick","date":"2018-04-02T11:13:25.000Z","updated":"2019-09-16T01:57:01.506Z","comments":true,"path":"2018/04/02/005.vue源码学习/004.响应式原理/005.nextTick/","link":"","permalink":"http://www.chenya.site/2018/04/02/005.vue源码学习/004.响应式原理/005.nextTick/","excerpt":"","text":"nextTicknextTick 是 Vue 的一个核心实现，在介绍 Vue 的 nextTick 之前，为了方便大家理解，我先简单介绍一下 JS 的运行机制。 JS 运行机制JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤： （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 （3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 event-loop 主线程的执行过程就是一个 tick，而所有的异步结果都是通过 “任务队列” 来调度。 消息队列中存放的是一个个的任务（task）。 规范中规定 task 分为两大类，分别是 macro task 和 micro task，并且每个 macro task 结束后，都要清空所有的 micro task。 关于 macro task 和 micro task 的概念，这里不会细讲，简单通过一段代码演示他们的执行顺序： for (macroTask of macroTaskQueue) { // 1. Handle current MACRO-TASK handleMacroTask(); // 2. Handle all MICRO-TASK for (microTask of microTaskQueue) { handleMicroTask(microTask); } } 在浏览器环境中，常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate；常见的 micro task 有 MutationObsever 和 Promise.then。 Vue 的实现在 Vue 源码 2.5+ 后，nextTick 的实现单独有一个 JS 文件来维护它，它的源码并不多，总共也就 100 多行。接下来我们来看一下它的实现，在 src/core/util/next-tick.js 中： import { noop } from 'shared/util' import { handleError } from './error' import { isIOS, isNative } from './env' const callbacks = [] let pending = false function flushCallbacks () { pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) { copies[i]() } } // Here we have async deferring wrappers using both microtasks and (macro) tasks. // In &lt; 2.4 we used microtasks everywhere, but there are some scenarios where // microtasks have too high a priority and fire in between supposedly // sequential events (e.g. #4521, #6690) or even between bubbling of the same // event (#6566). However, using (macro) tasks everywhere also has subtle problems // when state is changed right before repaint (e.g. #6813, out-in transitions). // Here we use microtask by default, but expose a way to force (macro) task when // needed (e.g. in event handlers attached by v-on). let microTimerFunc let macroTimerFunc let useMacroTask = false // Determine (macro) task defer implementation. // Technically setImmediate should be the ideal choice, but it's only available // in IE. The only polyfill that consistently queues the callback after all DOM // events triggered in the same loop is by using MessageChannel. /* istanbul ignore if */ if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) { macroTimerFunc = () => { setImmediate(flushCallbacks) } } else if (typeof MessageChannel !== 'undefined' &amp;&amp; ( isNative(MessageChannel) || // PhantomJS MessageChannel.toString() === '[object MessageChannelConstructor]' )) { const channel = new MessageChannel() const port = channel.port2 channel.port1.onmessage = flushCallbacks macroTimerFunc = () => { port.postMessage(1) } } else { /* istanbul ignore next */ macroTimerFunc = () => { setTimeout(flushCallbacks, 0) } } // Determine microtask defer implementation. /* istanbul ignore next, $flow-disable-line */ if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) { const p = Promise.resolve() microTimerFunc = () => { p.then(flushCallbacks) // in problematic UIWebViews, Promise.then doesn't completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn't being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // \"force\" the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) } } else { // fallback to macro microTimerFunc = macroTimerFunc } /** * Wrap a function so that if any code inside triggers state change, * the changes are queued using a (macro) task instead of a microtask. */ export function withMacroTask (fn: Function): Function { return fn._withTask || (fn._withTask = function () { useMacroTask = true const res = fn.apply(null, arguments) useMacroTask = false return res }) } export function nextTick (cb?: Function, ctx?: Object) { let _resolve callbacks.push(() => { if (cb) { try { cb.call(ctx) } catch (e) { handleError(e, ctx, 'nextTick') } } else if (_resolve) { _resolve(ctx) } }) if (!pending) { pending = true if (useMacroTask) { macroTimerFunc() } else { microTimerFunc() } } // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== 'undefined') { return new Promise(resolve => { _resolve = resolve }) } } next-tick.js 申明了 microTimerFunc 和 macroTimerFunc 2 个变量，它们分别对应的是 micro task 的函数和 macro task 的函数。对于 macro task 的实现，优先检测是否支持原生 setImmediate，这是一个高版本 IE 和 Edge 才支持的特性，不支持的话再去检测是否支持原生的 MessageChannel，如果也不支持的话就会降级为 setTimeout 0；而对于 micro task 的实现，则检测浏览器是否原生支持 Promise，不支持的话直接指向 macro task 的实现。 next-tick.js 对外暴露了 2 个函数，先来看 nextTick，这就是我们在上一节执行 nextTick(flushSchedulerQueue) 所用到的函数。它的逻辑也很简单，把传入的回调函数 cb 压入 callbacks 数组，最后一次性地根据 useMacroTask 条件执行 macroTimerFunc 或者是 microTimerFunc，而它们都会在下一个 tick 执行 flushCallbacks，flushCallbacks 的逻辑非常简单，对 callbacks 遍历，然后执行相应的回调函数。 这里使用 callbacks 而不是直接在 nextTick 中执行回调函数的原因是保证在同一个 tick 内多次执行 nextTick，不会开启多个异步任务，而把这些异步任务都压成一个同步任务，在下一个 tick 执行完毕。 nextTick 函数最后还有一段逻辑： if (!cb &amp;&amp; typeof Promise !== 'undefined') { return new Promise(resolve => { _resolve = resolve }) } 这是当 nextTick 不传 cb 参数的时候，提供一个 Promise 化的调用，比如： nextTick().then(() => {}) 当 _resolve 函数执行，就会跳到 then 的逻辑中。 next-tick.js 还对外暴露了 withMacroTask 函数，它是对函数做一层包装，确保函数执行过程中对数据任意的修改，触发变化执行 nextTick 的时候强制走 macroTimerFunc。比如对于一些 DOM 交互事件，如 v-on 绑定的事件回调函数的处理，会强制走 macro task。 总结通过这一节对 nextTick 的分析，并结合上一节的 setter 分析，我们了解到数据的变化到 DOM 的重新渲染是一个异步过程，发生在下一个 tick。这就是我们平时在开发的过程中，比如从服务端接口去获取数据的时候，数据做了修改，如果我们的某些方法去依赖了数据修改后的 DOM 变化，我们就必须在 nextTick 后执行。比如下面的伪代码： getData(res).then(()=>{ this.xxx = res.data this.$nextTick(() => { // 这里我们可以获取变化后的 DOM }) }) Vue.js 提供了 2 种调用 nextTick 的方式，一种是全局 API Vue.nextTick，一种是实例上的方法 vm.$nextTick，无论我们使用哪一种，最后都是调用 next-tick.js 中实现的 nextTick 方法。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"ejs模板引擎","slug":"004.koa学习/001.基础篇/006.模板引擎/002.ejs模板引擎","date":"2018-04-01T00:26:03.000Z","updated":"2019-09-16T01:57:01.500Z","comments":true,"path":"2018/04/01/004.koa学习/001.基础篇/006.模板引擎/002.ejs模板引擎/","link":"","permalink":"http://www.chenya.site/2018/04/01/004.koa学习/001.基础篇/006.模板引擎/002.ejs模板引擎/","excerpt":"","text":"ejs模板引擎具体查看ejs官方文档https://github.com/mde/ejs","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"Vue源码学习 - 派发更新","slug":"005.vue源码学习/004.响应式原理/004.派发更新","date":"2018-03-28T07:45:12.000Z","updated":"2019-09-16T01:57:01.505Z","comments":true,"path":"2018/03/28/005.vue源码学习/004.响应式原理/004.派发更新/","link":"","permalink":"http://www.chenya.site/2018/03/28/005.vue源码学习/004.响应式原理/004.派发更新/","excerpt":"","text":"派发更新通过上一节分析我们了解了响应式数据依赖收集过程，收集的目的就是为了当我们修改数据的时候，可以对相关的依赖派发更新，那么这一节我们来详细分析这个过程。 我们先来回顾一下 setter 部分的逻辑： /** * Define a reactive property on an Object. */ export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean ) { const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) { return } // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) { val = obj[key] } let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, // ... set: function reactiveSetter (newVal) { const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) { customSetter() } if (setter) { setter.call(obj, newVal) } else { val = newVal } childOb = !shallow &amp;&amp; observe(newVal) dep.notify() } }) } setter 的逻辑有 2 个关键的点，一个是 childOb = !shallow &amp;&amp; observe(newVal)，如果 shallow 为 false 的情况，会对新设置的值变成一个响应式对象；另一个是 dep.notify()，通知所有的订阅者，这是本节的关键，接下来我会带大家完整的分析整个派发更新的过程。 过程分析当我们在组件中对响应的数据做了修改，就会触发 setter 的逻辑，最后调用 dep.notify() 方法，它是 Dep 的一个实例方法，定义在 src/core/observer/dep.js 中： class Dep { // ... notify () { // stabilize the subscriber list first const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update() } } } 这里的逻辑非常简单，遍历所有的 subs，也就是 Watcher 的实例数组，然后调用每一个 watcher 的 update 方法，它的定义在 src/core/observer/watcher.js 中： class Watcher { // ... update () { /* istanbul ignore else */ if (this.computed) { // A computed property watcher has two modes: lazy and activated. // It initializes as lazy by default, and only becomes activated when // it is depended on by at least one subscriber, which is typically // another computed property or a component's render function. if (this.dep.subs.length === 0) { // In lazy mode, we don't want to perform computations until necessary, // so we simply mark the watcher as dirty. The actual computation is // performed just-in-time in this.evaluate() when the computed property // is accessed. this.dirty = true } else { // In activated mode, we want to proactively perform the computation // but only notify our subscribers when the value has indeed changed. this.getAndInvoke(() => { this.dep.notify() }) } } else if (this.sync) { this.run() } else { queueWatcher(this) } } } 这里对于 Watcher 的不同状态，会执行不同的逻辑，computed 和 sync 等状态的分析我会之后抽一小节详细介绍，在一般组件数据更新的场景，会走到最后一个 queueWatcher(this) 的逻辑，queueWatcher 的定义在 src/core/observer/scheduler.js 中： const queue: Array&lt;Watcher> = [] let has: { [key: number]: ?true } = {} let waiting = false let flushing = false /** * Push a watcher into the watcher queue. * Jobs with duplicate IDs will be skipped unless it's * pushed when the queue is being flushed. */ export function queueWatcher (watcher: Watcher) { const id = watcher.id if (has[id] == null) { has[id] = true if (!flushing) { queue.push(watcher) } else { // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i > index &amp;&amp; queue[i].id > watcher.id) { i-- } queue.splice(i + 1, 0, watcher) } // queue the flush if (!waiting) { waiting = true nextTick(flushSchedulerQueue) } } } 这里引入了一个队列的概念，这也是 Vue 在做派发更新的时候的一个优化的点，它并不会每次数据改变都触发 watcher 的回调，而是把这些 watcher 先添加到一个队列里，然后在 nextTick 后执行 flushSchedulerQueue。 这里有几个细节要注意一下，首先用 has 对象保证同一个 Watcher 只添加一次；接着对 flushing 的判断，else 部分的逻辑稍后我会讲；最后通过 waiting 保证对 nextTick(flushSchedulerQueue) 的调用逻辑只有一次，另外 nextTick 的实现我之后会抽一小节专门去讲，目前就可以理解它是在下一个 tick，也就是异步的去执行 flushSchedulerQueue。 接下来我们来看 flushSchedulerQueue 的实现，它的定义在 src/core/observer/scheduler.js 中。 let flushing = false let index = 0 /** * Flush both queues and run the watchers. */ function flushSchedulerQueue () { flushing = true let watcher, id // Sort queue before flush. // This ensures that: // 1. Components are updated from parent to child. (because parent is always // created before the child) // 2. A component's user watchers are run before its render watcher (because // user watchers are created before the render watcher) // 3. If a component is destroyed during a parent component's watcher run, // its watchers can be skipped. queue.sort((a, b) => a.id - b.id) // do not cache length because more watchers might be pushed // as we run existing watchers for (index = 0; index &lt; queue.length; index++) { watcher = queue[index] if (watcher.before) { watcher.before() } id = watcher.id has[id] = null watcher.run() // in dev build, check and stop circular updates. if (process.env.NODE_ENV !== 'production' &amp;&amp; has[id] != null) { circular[id] = (circular[id] || 0) + 1 if (circular[id] > MAX_UPDATE_COUNT) { warn( 'You may have an infinite update loop ' + ( watcher.user ? `in watcher with expression \"${watcher.expression}\"` : `in a component render function.` ), watcher.vm ) break } } } // keep copies of post queues before resetting state const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() resetSchedulerState() // call component updated and activated hooks callActivatedHooks(activatedQueue) callUpdatedHooks(updatedQueue) // devtool hook /* istanbul ignore if */ if (devtools &amp;&amp; config.devtools) { devtools.emit('flush') } } 这里有几个重要的逻辑要梳理一下，对于一些分支逻辑如 keep-alive 组件相关和之前提到过的 updated 钩子函数的执行会略过。 队列排序 queue.sort((a, b) =&gt; a.id - b.id) 对队列做了从小到大的排序，这么做主要有以下要确保以下几点： 1.组件的更新由父到子；因为父组件的创建过程是先于子的，所以 watcher 的创建也是先父后子，执行顺序也应该保持先父后子。 2.用户的自定义 watcher 要优先于渲染 watcher 执行；因为用户自定义 watcher 是在渲染 watcher 之前创建的。 3.如果一个组件在父组件的 watcher 执行期间被销毁，那么它对应的 watcher 执行都可以被跳过，所以父组件的 watcher 应该先执行。 队列遍历 在对 queue 排序后，接着就是要对它做遍历，拿到对应的 watcher，执行 watcher.run()。这里需要注意一个细节，在遍历的时候每次都会对 queue.length 求值，因为在 watcher.run() 的时候，很可能用户会再次添加新的 watcher，这样会再次执行到 queueWatcher，如下： export function queueWatcher (watcher: Watcher) { const id = watcher.id if (has[id] == null) { has[id] = true if (!flushing) { queue.push(watcher) } else { // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i > index &amp;&amp; queue[i].id > watcher.id) { i-- } queue.splice(i + 1, 0, watcher) } // ... } } 可以看到，这时候 flushing 为 true，就会执行到 else 的逻辑，然后就会从后往前找，找到第一个待插入 watcher 的 id 比当前队列中 watcher 的 id 大的位置。把 watcher 按照 id的插入到队列中，因此 queue 的长度发生了变化。 状态恢复 这个过程就是执行 resetSchedulerState 函数，它的定义在 src/core/observer/scheduler.js 中。 const queue: Array&lt;Watcher> = [] let has: { [key: number]: ?true } = {} let circular: { [key: number]: number } = {} let waiting = false let flushing = false let index = 0 /** * Reset the scheduler's state. */ function resetSchedulerState () { index = queue.length = activatedChildren.length = 0 has = {} if (process.env.NODE_ENV !== 'production') { circular = {} } waiting = flushing = false } 逻辑非常简单，就是把这些控制流程状态的一些变量恢复到初始值，把 watcher 队列清空。 接下来我们继续分析 watcher.run() 的逻辑，它的定义在 src/core/observer/watcher.js 中。 class Watcher { /** * Scheduler job interface. * Will be called by the scheduler. */ run () { if (this.active) { this.getAndInvoke(this.cb) } } getAndInvoke (cb: Function) { const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) { // set new value const oldValue = this.value this.value = value this.dirty = false if (this.user) { try { cb.call(this.vm, value, oldValue) } catch (e) { handleError(e, this.vm, `callback for watcher \"${this.expression}\"`) } } else { cb.call(this.vm, value, oldValue) } } } } run 函数实际上就是执行 this.getAndInvoke 方法，并传入 watcher 的回调函数。getAndInvoke 函数逻辑也很简单，先通过 this.get() 得到它当前的值，然后做判断，如果满足新旧值不等、新值是对象类型、deep 模式任何一个条件，则执行 watcher 的回调，注意回调函数执行的时候会把第一个和第二个参数传入新值 value 和旧值 oldValue，这就是当我们添加自定义 watcher 的时候能在回调函数的参数中拿到新旧值的原因。 那么对于渲染 watcher 而言，它在执行 this.get() 方法求值的时候，会执行 getter 方法： updateComponent = () => { vm._update(vm._render(), hydrating) } 所以这就是当我们去修改组件相关的响应式数据的时候，会触发组件重新渲染的原因，接着就会重新执行 patch 的过程，但它和首次渲染有所不同，之后我们会花一小节去详细介绍。 总结通过这一节的分析，我们对 Vue 数据修改派发更新的过程也有了认识，实际上就是当数据发生变化的时候，触发 setter 逻辑，把在依赖过程中订阅的的所有观察者，也就是 watcher，都触发它们的 update 过程，这个过程又利用了队列做了进一步优化，在 nextTick 后执行所有 watcher 的 run，最后执行它们的回调函数。nextTick 是 Vue 一个比较核心的实现了，下一节我们来重点分析它的实现。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"koa2加载模板引擎","slug":"004.koa学习/001.基础篇/006.模板引擎/001.koa2加载模板引擎","date":"2018-03-27T13:12:59.000Z","updated":"2019-09-16T01:57:01.499Z","comments":true,"path":"2018/03/27/004.koa学习/001.基础篇/006.模板引擎/001.koa2加载模板引擎/","link":"","permalink":"http://www.chenya.site/2018/03/27/004.koa学习/001.基础篇/006.模板引擎/001.koa2加载模板引擎/","excerpt":"","text":"koa2加载模板引擎快速开始安装模块# 安装koa模板使用中间件 npm install --save koa-views # 安装ejs模板引擎 npm install --save ejs 使用模板引擎demo源码 ejs 文件目录├── package.json ├── index.js └── view └── index.ejs ./index.js文件const Koa = require('koa') const views = require('koa-views') const path = require('path') const app = new Koa() // 加载模板引擎 app.use(views(path.join(__dirname, './view'), { extension: 'ejs' })) app.use( async ( ctx ) => { let title = 'hello koa2' await ctx.render('index', { title, }) }) app.listen(3000) ./view/index.ejs 模板&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>&lt;%= title %>&lt;/title> &lt;/head> &lt;body> &lt;h1>&lt;%= title %>&lt;/h1> &lt;p>EJS Welcome to &lt;%= title %>&lt;/p> &lt;/body> &lt;/html>","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"Vue源码学习 - 依赖收集","slug":"005.vue源码学习/004.响应式原理/003.依赖收集","date":"2018-03-24T00:23:41.000Z","updated":"2019-09-16T01:57:01.505Z","comments":true,"path":"2018/03/24/005.vue源码学习/004.响应式原理/003.依赖收集/","link":"","permalink":"http://www.chenya.site/2018/03/24/005.vue源码学习/004.响应式原理/003.依赖收集/","excerpt":"","text":"依赖收集通过上一节的分析我们了解 Vue 会把普通对象变成响应式对象，响应式对象 getter 相关的逻辑就是做依赖收集，这一节我们来详细分析这个过程。 我们先来回顾一下 getter 部分的逻辑： export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean ) { const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) { return } // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) { val = obj[key] } let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { const value = getter ? getter.call(obj) : val if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, // ... }) } 这段代码我们只需要关注 2 个地方，一个是 const dep = new Dep() 实例化一个 Dep 的实例，另一个是在 get 函数中通过 dep.depend 做依赖收集，这里还有个对 childOb 判断的逻辑，我们之后会介绍它的作用。 DepDep 是整个 getter 依赖收集的核心，它的定义在 src/core/observer/dep.js 中： import type Watcher from './watcher' import { remove } from '../util/index' let uid = 0 /** * A dep is an observable that can have multiple * directives subscribing to it. */ export default class Dep { static target: ?Watcher; id: number; subs: Array&lt;Watcher>; constructor () { this.id = uid++ this.subs = [] } addSub (sub: Watcher) { this.subs.push(sub) } removeSub (sub: Watcher) { remove(this.subs, sub) } depend () { if (Dep.target) { Dep.target.addDep(this) } } notify () { // stabilize the subscriber list first const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update() } } } // the current target watcher being evaluated. // this is globally unique because there could be only one // watcher being evaluated at any time. Dep.target = null const targetStack = [] export function pushTarget (_target: ?Watcher) { if (Dep.target) targetStack.push(Dep.target) Dep.target = _target } export function popTarget () { Dep.target = targetStack.pop() } Dep 是一个 Class，它定义了一些属性和方法，这里需要特别注意的是它有一个静态属性 target，这是一个全局唯一 Watcher，这是一个非常巧妙的设计，因为在同一时间只能有一个全局的 Watcher 被计算，另外它的自身属性 subs 也是 Watcher 的数组。 Dep 实际上就是对 Watcher 的一种管理，Dep 脱离 Watcher 单独存在是没有意义的，为了完整地讲清楚依赖收集过程，我们有必要看一下 Watcher 的一些相关实现，它的定义在 src/core/observer/watcher.js 中： Watcherlet uid = 0 /** * A watcher parses an expression, collects dependencies, * and fires callback when the expression value changes. * This is used for both the $watch() api and directives. */ export default class Watcher { vm: Component; expression: string; cb: Function; id: number; deep: boolean; user: boolean; computed: boolean; sync: boolean; dirty: boolean; active: boolean; dep: Dep; deps: Array&lt;Dep>; newDeps: Array&lt;Dep>; depIds: SimpleSet; newDepIds: SimpleSet; before: ?Function; getter: Function; value: any; constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean ) { this.vm = vm if (isRenderWatcher) { vm._watcher = this } vm._watchers.push(this) // options if (options) { this.deep = !!options.deep this.user = !!options.user this.computed = !!options.computed this.sync = !!options.sync this.before = options.before } else { this.deep = this.user = this.computed = this.sync = false } this.cb = cb this.id = ++uid // uid for batching this.active = true this.dirty = this.computed // for computed watchers this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '' // parse expression for getter if (typeof expOrFn === 'function') { this.getter = expOrFn } else { this.getter = parsePath(expOrFn) if (!this.getter) { this.getter = function () {} process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed watching path: \"${expOrFn}\" ` + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm ) } } if (this.computed) { this.value = undefined this.dep = new Dep() } else { this.value = this.get() } } /** * Evaluate the getter, and re-collect dependencies. */ get () { pushTarget(this) let value const vm = this.vm try { value = this.getter.call(vm, vm) } catch (e) { if (this.user) { handleError(e, vm, `getter for watcher \"${this.expression}\"`) } else { throw e } } finally { // \"touch\" every property so they are all tracked as // dependencies for deep watching if (this.deep) { traverse(value) } popTarget() this.cleanupDeps() } return value } /** * Add a dependency to this directive. */ addDep (dep: Dep) { const id = dep.id if (!this.newDepIds.has(id)) { this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) { dep.addSub(this) } } } /** * Clean up for dependency collection. */ cleanupDeps () { let i = this.deps.length while (i--) { const dep = this.deps[i] if (!this.newDepIds.has(dep.id)) { dep.removeSub(this) } } let tmp = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0 } // ... } Watcher 是一个 Class，在它的构造函数中，定义了一些和 Dep 相关的属性： this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() 其中，this.deps 和 this.newDeps 表示 Watcher 实例持有的 Dep 实例的数组；而 this.depIds 和 this.newDepIds 分别代表 this.deps 和 this.newDeps 的 id Set（这个 Set 是 ES6 的数据结构，它的实现在 src/core/util/env.js 中）。那么这里为何需要有 2 个 Dep 实例数组呢，稍后我们会解释。 Watcher 还定义了一些原型的方法，和依赖收集相关的有 get、addDep 和 cleanupDeps 方法，单个介绍它们的实现不方便理解，我会结合整个依赖收集的过程把这几个方法讲清楚。 过程分析之前我们介绍当对数据对象的访问会触发他们的 getter 方法，那么这些对象什么时候被访问呢？还记得之前我们介绍过 Vue 的 mount 过程是通过 mountComponent 函数，其中有一段比较重要的逻辑，大致如下： updateComponent = () => { vm._update(vm._render(), hydrating) } new Watcher(vm, updateComponent, noop, { before () { if (vm._isMounted) { callHook(vm, 'beforeUpdate') } } }, true /* isRenderWatcher */) 当我们去实例化一个渲染 watcher 的时候，首先进入 watcher 的构造函数逻辑，然后会执行它的 this.get() 方法，进入 get 函数，首先会执行： pushTarget(this) pushTarget 的定义在 src/core/observer/dep.js 中： export function pushTarget (_target: Watcher) { if (Dep.target) targetStack.push(Dep.target) Dep.target = _target } 实际上就是把 Dep.target 赋值为当前的渲染 watcher 并压栈（为了恢复用）。接着又执行了： value = this.getter.call(vm, vm) this.getter 对应就是 updateComponent 函数，这实际上就是在执行： vm._update(vm._render(), hydrating) 它会先执行 vm._render() 方法，因为之前分析过这个方法会生成 渲染 VNode，并且在这个过程中会对 vm 上的数据访问，这个时候就触发了数据对象的 getter。 那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。 刚才我们提到这个时候 Dep.target 已经被赋值为渲染 watcher，那么就执行到 addDep 方法： addDep (dep: Dep) { const id = dep.id if (!this.newDepIds.has(id)) { this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) { dep.addSub(this) } } } 这时候会做一些逻辑判断（保证同一数据不会被添加多次）后执行 dep.addSub(this)，那么就会执行 this.subs.push(sub)，也就是说把当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。 所以在 vm._render() 过程中，会触发所有数据的 getter，这样实际上已经完成了一个依赖收集的过程。那么到这里就结束了么，其实并没有，在完成依赖收集后，还有几个逻辑要执行，首先是： if (this.deep) { traverse(value) } 这个是要递归去访问 value，触发它所有子项的 getter，这个之后会详细讲。接下来执行： popTarget() popTarget 的定义在 src/core/observer/dep.js 中： Dep.target = targetStack.pop() 实际上就是把 Dep.target 恢复成上一个状态，因为当前 vm 的数据依赖收集已经完成，那么对应的渲染Dep.target 也需要改变。最后执行： this.cleanupDeps() 其实很多人都分析过并了解到 Vue 有依赖收集的过程，但我几乎没有看到有人分析依赖清空的过程，其实这是大部分同学会忽视的一点，也是 Vue 考虑特别细的一点。 cleanupDeps () { let i = this.deps.length while (i--) { const dep = this.deps[i] if (!this.newDepIds.has(dep.id)) { dep.removeSub(this) } } let tmp = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0 } 考虑到 Vue 是数据驱动的，所以每次数据变化都会重新 render，那么 vm._render() 方法又会再次执行，并再次触发数据的 getters，所以 Wathcer 在构造函数中会初始化 2 个 Dep 实例数组，newDeps 表示新添加的 Dep 实例数组，而 deps 表示上一次添加的 Dep 实例数组。 在执行 cleanupDeps 函数的时候，会首先遍历 deps，移除对 dep.subs 数组中 Wathcer 的订阅，然后把 newDepIds 和 depIds 交换，newDeps 和 deps 交换，并把 newDepIds 和 newDeps 清空。 那么为什么需要做 deps 订阅的移除呢，在添加 deps 的订阅过程，已经能通过 id 去重避免重复订阅了。 考虑到一种场景，我们的模板会根据 v-if 去渲染不同子模板 a 和 b，当我们满足某种条件的时候渲染 a 的时候，会访问到 a 中的数据，这时候我们对 a 使用的数据添加了 getter，做了依赖收集，那么当我们去修改 a 的数据的时候，理应通知到这些订阅者。那么如果我们一旦改变了条件渲染了 b 模板，又会对 b 使用的数据添加了 getter，如果我们没有依赖移除的过程，那么这时候我去修改 a 模板的数据，会通知 a 数据的订阅的回调，这显然是有浪费的。 因此 Vue 设计了在每次添加完新的订阅，会移除掉旧的订阅，这样就保证了在我们刚才的场景中，如果渲染 b 模板的时候去修改 a 模板的数据，a 数据订阅回调已经被移除了，所以不会有任何浪费，真的是非常赞叹 Vue 对一些细节上的处理。 总结通过这一节的分析，我们对 Vue 数据的依赖收集过程已经有了认识，并且对这其中的一些细节做了分析。收集依赖的目的是为了当这些响应式数据发生变化，触发它们的 setter 的时候，能知道应该通知哪些订阅者去做相应的逻辑处理，我们把这个过程叫派发更新，其实 Watcher 和 Dep 就是一个非常经典的观察者设计模式的实现，下一节我们来详细分析一下派发更新的过程。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"koa2实现session","slug":"004.koa学习/001.基础篇/005. cookie-session/002.koa2实现session","date":"2018-03-21T15:58:13.000Z","updated":"2019-09-16T01:57:01.499Z","comments":true,"path":"2018/03/21/004.koa学习/001.基础篇/005. cookie-session/002.koa2实现session/","link":"","permalink":"http://www.chenya.site/2018/03/21/004.koa学习/001.基础篇/005. cookie-session/002.koa2实现session/","excerpt":"","text":"koa2实现session前言koa2原生功能只提供了cookie的操作，但是没有提供session操作。session就只用自己实现或者通过第三方中间件实现。在koa2中实现session的方案有一下几种 如果session数据量很小，可以直接存在内存中 如果session数据量很大，则需要存储介质存放session数据 数据库存储方案 将session存放在MySQL数据库中 需要用到中间件 koa-session-minimal 适用于koa2 的session中间件，提供存储介质的读写接口 。 koa-mysql-session 为koa-session-minimal中间件提供MySQL数据库的session数据读写操作。 将sessionId和对应的数据存到数据库 将数据库的存储的sessionId存到页面的cookie中 根据cookie的sessionId去获取对于的session信息 快速使用demo源码 session/index.js 例子代码const Koa = require('koa') const session = require('koa-session-minimal') const MysqlSession = require('koa-mysql-session') const app = new Koa() // 配置存储session信息的mysql let store = new MysqlSession({ user: 'root', password: 'abc123', database: 'koa_demo', host: '127.0.0.1', }) // 存放sessionId的cookie配置 let cookie = { maxAge: '', // cookie有效时长 expires: '', // cookie失效时间 path: '', // 写cookie所在的路径 domain: '', // 写cookie所在的域名 httpOnly: '', // 是否只用于http请求中获取 overwrite: '', // 是否允许重写 secure: '', sameSite: '', signed: '', } // 使用session中间件 app.use(session({ key: 'SESSION_ID', store: store, cookie: cookie })) app.use( async ( ctx ) => { // 设置session if ( ctx.url === '/set' ) { ctx.session = { user_id: Math.random().toString(36).substr(2), count: 0 } ctx.body = ctx.session } else if ( ctx.url === '/' ) { // 读取session信息 ctx.session.count = ctx.session.count + 1 ctx.body = ctx.session } }) app.listen(3000) console.log('[demo] session is starting at port 3000') 运行例子执行命令node index.js 访问连接设置sessionhttp://localhost:3000/set session-result-01 查看数据库session是否存储 session-result-01 查看cookie中是否种下了sessionIdhttp://localhost:3000 session-result-01","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"Vue源码学习 - 响应式对象","slug":"005.vue源码学习/004.响应式原理/002.响应式对象","date":"2018-03-18T14:12:56.000Z","updated":"2019-09-16T01:57:01.504Z","comments":true,"path":"2018/03/18/005.vue源码学习/004.响应式原理/002.响应式对象/","link":"","permalink":"http://www.chenya.site/2018/03/18/005.vue源码学习/004.响应式原理/002.响应式对象/","excerpt":"","text":"响应式对象可能很多小伙伴之前都了解过 Vue.js 实现响应式的核心是利用了 ES5 的 Object.defineProperty，这也是为什么 Vue.js 不能兼容 IE8 及以下浏览器的原因，我们先来对它有个直观的认识。 Object.definePropertyObject.defineProperty 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象，先来看一下它的语法： Object.defineProperty(obj, prop, descriptor) obj 是要在其上定义属性的对象；prop 是要定义或修改的属性的名称；descriptor 是将被定义或修改的属性描述符。 比较核心的是 descriptor，它有很多可选键值，具体的可以去参阅它的文档。这里我们最关心的是 get 和 set，get 是一个给属性提供的 getter 方法，当我们访问了该属性的时候会触发 getter 方法；set 是一个给属性提供的 setter 方法，当我们对该属性做修改的时候会触发 setter 方法。 一旦对象拥有了 getter 和 setter，我们可以简单地把这个对象称为响应式对象。那么 Vue.js 把哪些对象变成了响应式对象了呢，接下来我们从源码层面分析。 initState在 Vue 的初始化阶段，_init 方法执行的时候，会执行 initState(vm) 方法，它的定义在 src/core/instance/state.js 中。 export function initState (vm: Component) { vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) { initData(vm) } else { observe(vm._data = {}, true /* asRootData */) } if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) { initWatch(vm, opts.watch) } } initState 方法主要是对 props、methods、data、computed 和 wathcer 等属性做了初始化操作。这里我们重点分析 props 和 data，对于其它属性的初始化我们之后再详细分析。 initProps function initProps (vm: Component, propsOptions: Object) { const propsData = vm.$options.propsData || {} const props = vm._props = {} // cache prop keys so that future props updates can iterate using Array // instead of dynamic object key enumeration. const keys = vm.$options._propKeys = [] const isRoot = !vm.$parent // root instance props should be converted if (!isRoot) { toggleObserving(false) } for (const key in propsOptions) { keys.push(key) const value = validateProp(key, propsOptions, propsData, vm) /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') { const hyphenatedKey = hyphenate(key) if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) { warn( `\"${hyphenatedKey}\" is a reserved attribute and cannot be used as component prop.`, vm ) } defineReactive(props, key, value, () => { if (vm.$parent &amp;&amp; !isUpdatingChildComponent) { warn( `Avoid mutating a prop directly since the value will be ` + `overwritten whenever the parent component re-renders. ` + `Instead, use a data or computed property based on the prop's ` + `value. Prop being mutated: \"${key}\"`, vm ) } }) } else { defineReactive(props, key, value) } // static props are already proxied on the component's prototype // during Vue.extend(). We only need to proxy props defined at // instantiation here. if (!(key in vm)) { proxy(vm, `_props`, key) } } toggleObserving(true) } props 的初始化主要过程，就是遍历定义的 props 配置。遍历的过程主要做两件事情：一个是调用 defineReactive 方法把每个 prop 对应的值变成响应式，可以通过 vm._props.xxx 访问到定义 props 中对应的属性。对于 defineReactive 方法，我们稍后会介绍；另一个是通过 proxy 把 vm._props.xxx 的访问代理到 vm.xxx 上，我们稍后也会介绍。 initData function initData (vm: Component) { let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {} if (!isPlainObject(data)) { data = {} process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) } // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) { const key = keys[i] if (process.env.NODE_ENV !== 'production') { if (methods &amp;&amp; hasOwn(methods, key)) { warn( `Method \"${key}\" has already been defined as a data property.`, vm ) } } if (props &amp;&amp; hasOwn(props, key)) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"${key}\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) } else if (!isReserved(key)) { proxy(vm, `_data`, key) } } // observe data observe(data, true /* asRootData */) } data 的初始化主要过程也是做两件事，一个是对定义 data 函数返回对象的遍历，通过 proxy 把每一个值 vm._data.xxx 都代理到 vm.xxx 上；另一个是调用 observe 方法观测整个 data 的变化，把 data 也变成响应式，可以通过 vm._data.xxx 访问到定义 data 返回函数中对应的属性，observe 我们稍后会介绍。 可以看到，无论是 props 或是 data 的初始化都是把它们变成响应式对象，这个过程我们接触到几个函数，接下来我们来详细分析它们。 proxy首先介绍一下代理，代理的作用是把 props 和 data 上的属性代理到 vm 实例上，这也就是为什么比如我们定义了如下 props，却可以通过 vm 实例访问到它。 let comP = { props: { msg: 'hello' }, methods: { say() { console.log(this.msg) } } } 我们可以在 say 函数中通过 this.msg 访问到我们定义在 props 中的 msg，这个过程发生在 proxy 阶段： const sharedPropertyDefinition = { enumerable: true, configurable: true, get: noop, set: noop } export function proxy (target: Object, sourceKey: string, key: string) { sharedPropertyDefinition.get = function proxyGetter () { return this[sourceKey][key] } sharedPropertyDefinition.set = function proxySetter (val) { this[sourceKey][key] = val } Object.defineProperty(target, key, sharedPropertyDefinition) } proxy 方法的实现很简单，通过 Object.defineProperty 把 target[sourceKey][key] 的读写变成了对 target[key] 的读写。所以对于 props 而言，对 vm._props.xxx 的读写变成了 vm.xxx 的读写，而对于 vm._props.xxx 我们可以访问到定义在 props 中的属性，所以我们就可以通过 vm.xxx 访问到定义在 props 中的 xxx 属性了。同理，对于 data 而言，对 vm._data.xxxx 的读写变成了对 vm.xxxx 的读写，而对于 vm._data.xxxx 我们可以访问到定义在 data 函数返回对象中的属性，所以我们就可以通过 vm.xxxx 访问到定义在 data 函数返回对象中的 xxxx 属性了。 observeobserve 的功能就是用来监测数据的变化，它的定义在 src/core/observer/index.js 中： /** * Attempt to create an observer instance for a value, * returns the new observer if successfully observed, * or the existing observer if the value already has one. */ export function observe (value: any, asRootData: ?boolean): Observer | void { if (!isObject(value) || value instanceof VNode) { return } let ob: Observer | void if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) { ob = value.__ob__ } else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) { ob = new Observer(value) } if (asRootData &amp;&amp; ob) { ob.vmCount++ } return ob } observe 方法的作用就是给非 VNode 的对象类型数据添加一个 Observer，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 Observer 对象实例。接下来我们来看一下 Observer 的作用。 ObserverObserver 是一个类，它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新： /** * Observer class that is attached to each observed * object. Once attached, the observer converts the target * object's property keys into getter/setters that * collect dependencies and dispatch updates. */ export class Observer { value: any; dep: Dep; vmCount: number; // number of vms that has this object as root $data constructor (value: any) { this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) { const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) } else { this.walk(value) } } /** * Walk through each property and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive(obj, keys[i]) } } /** * Observe a list of Array items. */ observeArray (items: Array&lt;any>) { for (let i = 0, l = items.length; i &lt; l; i++) { observe(items[i]) } } } Observer 的构造函数逻辑很简单，首先实例化 Dep 对象，这块稍后会介绍，接着通过执行 def 函数把自身实例添加到数据对象 value 的 __ob__ 属性上，def 的定义在 src/core/util/lang.js 中： /** * Define a property. */ export function def (obj: Object, key: string, val: any, enumerable?: boolean) { Object.defineProperty(obj, key, { value: val, enumerable: !!enumerable, writable: true, configurable: true }) } def 函数是一个非常简单的Object.defineProperty 的封装，这就是为什么我在开发中输出 data 上对象类型的数据，会发现该对象多了一个 __ob__ 的属性。 回到 Observer 的构造函数，接下来会对 value 做判断，对于数组会调用 observeArray 方法，否则对纯对象调用 walk 方法。可以看到 observeArray 是遍历数组再次调用 observe 方法，而 walk 方法是遍历对象的 key 调用 defineReactive 方法，那么我们来看一下这个方法是做什么的。 defineReactivedefineReactive 的功能就是定义一个响应式对象，给对象动态添加 getter 和 setter，它的定义在 src/core/observer/index.js 中： /** * Define a reactive property on an Object. */ export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean ) { const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) { return } // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) { val = obj[key] } let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { const value = getter ? getter.call(obj) : val if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, set: function reactiveSetter (newVal) { const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) { customSetter() } if (setter) { setter.call(obj, newVal) } else { val = newVal } childOb = !shallow &amp;&amp; observe(newVal) dep.notify() } }) } defineReactive 函数最开始初始化 Dep 对象的实例，接着拿到 obj 的属性描述符，然后对子对象递归调用 observe 方法，这样就保证了无论 obj 的结构多复杂，它的所有子属性也能变成响应式的对象，这样我们访问或修改 obj 中一个嵌套较深的属性，也能触发 getter 和 setter。最后利用 Object.defineProperty 去给 obj 的属性 key 添加 getter 和 setter。而关于 getter 和 setter 的具体实现，我们会在之后介绍。 总结这一节我们介绍了响应式对象，核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新，那么在接下来的章节我们会重点对这两个过程分析。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"koa2使用cookie","slug":"004.koa学习/001.基础篇/005. cookie-session/001.koa2使用cookie","date":"2018-03-13T06:22:43.000Z","updated":"2019-09-16T01:57:01.499Z","comments":true,"path":"2018/03/13/004.koa学习/001.基础篇/005. cookie-session/001.koa2使用cookie/","link":"","permalink":"http://www.chenya.site/2018/03/13/004.koa学习/001.基础篇/005. cookie-session/001.koa2使用cookie/","excerpt":"","text":"koa2使用cookie使用方法koa提供了从上下文直接读取、写入cookie的方法 ctx.cookies.get(name, [options]) 读取上下文请求中的cookie ctx.cookies.set(name, value, [options]) 在上下文中写入cookie koa2 中操作的cookies是使用了npm的cookies模块，源码在https://github.com/pillarjs/cookies，所以在读写cookie的使用参数与该模块的使用一致。 例子代码const Koa = require('koa') const app = new Koa() app.use( async ( ctx ) => { if ( ctx.url === '/index' ) { ctx.cookies.set( 'cid', 'hello world', { domain: 'localhost', // 写cookie所在的域名 path: '/index', // 写cookie所在的路径 maxAge: 10 * 60 * 1000, // cookie有效时长 expires: new Date('2017-02-15'), // cookie失效时间 httpOnly: false, // 是否只用于http请求中获取 overwrite: false // 是否允许重写 } ) ctx.body = 'cookie is ok' } else { ctx.body = 'hello world' } }) app.listen(3000, () => { console.log('[demo] cookie is starting at port 3000') }) 运行例子执行脚本node index.js 运行结果访问http://localhost:3000/index 可以在控制台的cookie列表中中看到写在页面上的cookie 在控制台的console中使用document.cookie可以打印出在页面的所有cookie（需要是httpOnly设置false才能显示） cookie-result-01","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"koa-static中间件使用","slug":"004.koa学习/001.基础篇/004.静态资源加载/002.koa-static中间件使用","date":"2018-03-08T01:19:32.000Z","updated":"2019-09-16T01:57:01.498Z","comments":true,"path":"2018/03/08/004.koa学习/001.基础篇/004.静态资源加载/002.koa-static中间件使用/","link":"","permalink":"http://www.chenya.site/2018/03/08/004.koa学习/001.基础篇/004.静态资源加载/002.koa-static中间件使用/","excerpt":"","text":"koa-static中间件使用使用例子demo源码 static-use-middleware const Koa = require('koa') const path = require('path') const static = require('koa-static') const app = new Koa() // 静态资源目录对于相对入口文件index.js的路径 const staticPath = './static' app.use(static( path.join( __dirname, staticPath) )) app.use( async ( ctx ) => { ctx.body = 'hello world' }) app.listen(3000, () => { console.log('[demo] static-use-middleware is starting at port 3000') }) 效果访问http://localhost:3000 static-server-result 访问http://localhost:3000/index.html static-server-result 访问http://localhost:3000/js/index.js static-server-result","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"Vue源码学习 - 响应式原理介绍","slug":"005.vue源码学习/004.响应式原理/001.响应式原理介绍","date":"2018-03-07T15:39:56.000Z","updated":"2019-09-16T01:57:01.504Z","comments":true,"path":"2018/03/07/005.vue源码学习/004.响应式原理/001.响应式原理介绍/","link":"","permalink":"http://www.chenya.site/2018/03/07/005.vue源码学习/004.响应式原理/001.响应式原理介绍/","excerpt":"","text":"深入响应式原理前面 2 章介绍的都是 Vue 怎么实现数据渲染和组件化的，主要讲的是初始化的过程，把原始的数据最终映射到 DOM 中，但并没有涉及到数据变化到 DOM 变化的部分。而 Vue 的数据驱动除了数据渲染 DOM 之外，还有一个很重要的体现就是数据的变更会触发 DOM 的变化。 其实前端开发最重要的 2 个工作，一个是把数据渲染到页面，另一个是处理用户交互。Vue 把数据渲染到页面的能力我们已经通过源码分析出其中的原理了，但是由于一些用户交互或者是其它方面导致数据发生变化重新对页面渲染的原理我们还未分析。 考虑如下示例： &lt;div id=\"app\" @click=\"changeMsg\"> {{ message }} &lt;/div> var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }, methods: { changeMsg() { this.message = 'Hello World!' } } }) 当我们去修改 this.message 的时候，模板对应的插值也会渲染成新的数据，那么这一切是怎么做到的呢？ 在分析前，我们先直观的想一下，如果不用 Vue 的话，我们会通过最简单的方法实现这个需求：监听点击事件，修改数据，手动操作 DOM 重新渲染。这个过程和使用 Vue 的最大区别就是多了一步“手动操作 DOM 重新渲染”。这一步看上去并不多，但它背后又潜在的几个要处理的问题： 我需要修改哪块的 DOM？ 我的修改效率和性能是不是最优的？ 我需要对数据每一次的修改都去操作 DOM 吗？ 我需要 case by case 去写修改 DOM 的逻辑吗？ 如果我们使用了 Vue，那么上面几个问题 Vue 内部就帮你做了，那么 Vue 是如何在我们对数据修改后自动做这些事情呢，接下来我们将进入一些 Vue 响应式系统的底层的细节。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - 异步组件","slug":"005.vue源码学习/003.组件化/007.异步组件","date":"2018-03-06T07:23:11.000Z","updated":"2019-09-16T01:57:01.504Z","comments":true,"path":"2018/03/06/005.vue源码学习/003.组件化/007.异步组件/","link":"","permalink":"http://www.chenya.site/2018/03/06/005.vue源码学习/003.组件化/007.异步组件/","excerpt":"","text":"异步组件在我们平时的开发工作中，为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。Vue 也原生支持了异步组件的能力，如下： Vue.component('async-example', function (resolve, reject) { // 这个特殊的 require 语法告诉 webpack // 自动将编译后的代码分割成不同的块， // 这些块将通过 Ajax 请求自动下载。 require(['./my-async-component'], resolve) }) 示例中可以看到，Vue 注册的组件不再是一个对象，而是一个工厂函数，函数有两个参数 resolve 和 reject，函数内部用 setTimout 模拟了异步，实际使用可能是通过动态请求异步组件的 JS 地址，最终通过执行 resolve 方法，它的参数就是我们的异步组件对象。 在了解了异步组件如何注册后，我们从源码的角度来分析一下它的实现。 上一节我们分析了组件的注册逻辑，由于组件的定义并不是一个普通对象，所以不会执行 Vue.extend 的逻辑把它变成一个组件的构造函数，但是它仍然可以执行到 createComponent 函数，我们再来对这个函数做回顾，它的定义在 src/core/vdom/create-component/js 中： export function createComponent ( Ctor: Class&lt;Component> | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array&lt;VNode>, tag?: string ): VNode | Array&lt;VNode> | void { if (isUndef(Ctor)) { return } const baseCtor = context.$options._base // plain options object: turn it into a constructor if (isObject(Ctor)) { Ctor = baseCtor.extend(Ctor) } // ... // async component let asyncFactory if (isUndef(Ctor.cid)) { asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context) if (Ctor === undefined) { // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) } } } 我们省略了不必要的逻辑，只保留关键逻辑，由于我们这个时候传入的 Ctor 是一个函数，那么它也并不会执行 Vue.extend 逻辑，因此它的 cid 是 undefiend，进入了异步组件创建的逻辑。这里首先执行了 Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context) 方法，它的定义在 src/core/vdom/helpers/resolve-async-component.js 中： export function resolveAsyncComponent ( factory: Function, baseCtor: Class&lt;Component>, context: Component ): Class&lt;Component> | void { if (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) { return factory.errorComp } if (isDef(factory.resolved)) { return factory.resolved } if (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingComp)) { return factory.loadingComp } if (isDef(factory.contexts)) { // already pending factory.contexts.push(context) } else { const contexts = factory.contexts = [context] let sync = true const forceRender = () => { for (let i = 0, l = contexts.length; i &lt; l; i++) { contexts[i].$forceUpdate() } } const resolve = once((res: Object | Class&lt;Component>) => { // cache resolved factory.resolved = ensureCtor(res, baseCtor) // invoke callbacks only if this is not a synchronous resolve // (async resolves are shimmed as synchronous during SSR) if (!sync) { forceRender() } }) const reject = once(reason => { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed to resolve async component: ${String(factory)}` + (reason ? `\\nReason: ${reason}` : '') ) if (isDef(factory.errorComp)) { factory.error = true forceRender() } }) const res = factory(resolve, reject) if (isObject(res)) { if (typeof res.then === 'function') { // () => Promise if (isUndef(factory.resolved)) { res.then(resolve, reject) } } else if (isDef(res.component) &amp;&amp; typeof res.component.then === 'function') { res.component.then(resolve, reject) if (isDef(res.error)) { factory.errorComp = ensureCtor(res.error, baseCtor) } if (isDef(res.loading)) { factory.loadingComp = ensureCtor(res.loading, baseCtor) if (res.delay === 0) { factory.loading = true } else { setTimeout(() => { if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) { factory.loading = true forceRender() } }, res.delay || 200) } } if (isDef(res.timeout)) { setTimeout(() => { if (isUndef(factory.resolved)) { reject( process.env.NODE_ENV !== 'production' ? `timeout (${res.timeout}ms)` : null ) } }, res.timeout) } } } sync = false // return in case resolved synchronously return factory.loading ? factory.loadingComp : factory.resolved } } resolveAsyncComponent 函数的逻辑略复杂，因为它实际上处理了 3 种异步组件的创建方式，除了刚才示例的组件注册方式，还支持 2 种，一种是支持 Promise 创建组件的方式，如下： Vue.component( 'async-webpack-example', // 该 `import` 函数返回一个 `Promise` 对象。 () => import('./my-async-component') ) 另一种是高级异步组件，如下： const AsyncComp = () => ({ // 需要加载的组件。应当是一个 Promise component: import('./MyComp.vue'), // 加载中应当渲染的组件 loading: LoadingComp, // 出错时渲染的组件 error: ErrorComp, // 渲染加载中组件前的等待时间。默认：200ms。 delay: 200, // 最长等待时间。超出此时间则渲染错误组件。默认：Infinity timeout: 3000 }) Vue.component('async-example', AsyncComp) 那么解下来，我们就根据这 3 种异步组件的情况，来分别去分析 resolveAsyncComponent 的逻辑。 普通函数异步组件针对普通函数的情况，前面几个 if 判断可以忽略，它们是为高级组件所用，对于 factory.contexts 的判断，是考虑到多个地方同时初始化一个异步组件，那么它的实际加载应该只有一次。接着进入实际加载逻辑，定义了 forceRender、resolve 和 reject 函数，注意 resolve 和 reject 函数用 once 函数做了一层包装，它的定义在 src/shared/util.js 中： /** * Ensure a function is called only once. */ export function once (fn: Function): Function { let called = false return function () { if (!called) { called = true fn.apply(this, arguments) } } } once 逻辑非常简单，传入一个函数，并返回一个新函数，它非常巧妙地利用闭包和一个标志位保证了它包装的函数只会执行一次，也就是确保 resolve 和 reject 函数只执行一次。 接下来执行 const res = factory(resolve, reject) 逻辑，这块儿就是执行我们组件的工厂函数，同时把 resolve 和 reject 函数作为参数传入，组件的工厂函数通常会先发送请求去加载我们的异步组件的 JS 文件，拿到组件定义的对象 res 后，执行 resolve(res) 逻辑，它会先执行 factory.resolved = ensureCtor(res, baseCtor)： function ensureCtor (comp: any, base) { if ( comp.__esModule || (hasSymbol &amp;&amp; comp[Symbol.toStringTag] === 'Module') ) { comp = comp.default } return isObject(comp) ? base.extend(comp) : comp } 这个函数目的是为了保证能找到异步组件 JS 定义的组件对象，并且如果它是一个普通对象，则调用 Vue.extend 把它转换成一个组件的构造函数。 resolve 逻辑最后判断了 sync，显然我们这个场景下 sync 为 false，那么就会执行 forceRender 函数，它会遍历 factory.contexts，拿到每一个调用异步组件的实例 vm, 执行 vm.$forceUpdate() 方法，它的定义在 src/core/instance/lifecycle.js 中： Vue.prototype.$forceUpdate = function () { const vm: Component = this if (vm._watcher) { vm._watcher.update() } } $forceUpdate 的逻辑非常简单，就是调用渲染 watcher 的 update 方法，让渲染 watcher 对应的回调函数执行，也就是触发了组件的重新渲染。之所以这么做是因为 Vue 通常是数据驱动视图重新渲染，但是在整个异步组件加载过程中是没有数据发生变化的，所以通过执行 $forceUpdate 可以强制组件重新渲染一次。 Promise 异步组件Vue.component( 'async-webpack-example', // 该 `import` 函数返回一个 `Promise` 对象。 () => import('./my-async-component') ) webpack 2+ 支持了异步加载的语法糖：() =&gt; import(&#39;./my-async-component&#39;)，当执行完 res = factory(resolve, reject)，返回的值就是 import(&#39;./my-async-component&#39;) 的返回值，它是一个 Promise 对象。接着进入 if 条件，又判断了 typeof res.then === &#39;function&#39;)，条件满足，执行： if (isUndef(factory.resolved)) { res.then(resolve, reject) } 当组件异步加载成功后，执行 resolve，加载失败则执行 reject，这样就非常巧妙地实现了配合 webpack 2+ 的异步加载组件的方式（Promise）加载异步组件。 高级异步组件由于异步加载组件需要动态加载 JS，有一定网络延时，而且有加载失败的情况，所以通常我们在开发异步组件相关逻辑的时候需要设计 loading 组件和 error 组件，并在适当的时机渲染它们。Vue.js 2.3+ 支持了一种高级异步组件的方式，它通过一个简单的对象配置，帮你搞定 loading 组件和 error 组件的渲染时机，你完全不用关心细节，非常方便。接下来我们就从源码的角度来分析高级异步组件是怎么实现的。 const AsyncComp = () => ({ // 需要加载的组件。应当是一个 Promise component: import('./MyComp.vue'), // 加载中应当渲染的组件 loading: LoadingComp, // 出错时渲染的组件 error: ErrorComp, // 渲染加载中组件前的等待时间。默认：200ms。 delay: 200, // 最长等待时间。超出此时间则渲染错误组件。默认：Infinity timeout: 3000 }) Vue.component('async-example', AsyncComp) 高级异步组件的初始化逻辑和普通异步组件一样，也是执行 resolveAsyncComponent，当执行完 res = factory(resolve, reject)，返回值就是定义的组件对象，显然满足 else if (isDef(res.component) &amp;&amp; typeof res.component.then === &#39;function&#39;) 的逻辑，接着执行 res.component.then(resolve, reject)，当异步组件加载成功后，执行 resolve，失败执行 reject。 因为异步组件加载是一个异步过程，它接着又同步执行了如下逻辑： if (isDef(res.error)) { factory.errorComp = ensureCtor(res.error, baseCtor) } if (isDef(res.loading)) { factory.loadingComp = ensureCtor(res.loading, baseCtor) if (res.delay === 0) { factory.loading = true } else { setTimeout(() => { if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) { factory.loading = true forceRender() } }, res.delay || 200) } } if (isDef(res.timeout)) { setTimeout(() => { if (isUndef(factory.resolved)) { reject( process.env.NODE_ENV !== 'production' ? `timeout (${res.timeout}ms)` : null ) } }, res.timeout) } 先判断 res.error 是否定义了 error 组件，如果有的话则赋值给 factory.errorComp。接着判断 res.loading 是否定义了 loading 组件，如果有的话则赋值给 factory.loadingComp，如果设置了 res.delay 且为 0，则设置 factory.loading = true，否则延时 delay 的时间执行： if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) { factory.loading = true forceRender() } 最后判断 res.timeout，如果配置了该项，则在 res.timout 时间后，如果组件没有成功加载，执行 reject。 在 resolveAsyncComponent 的最后有一段逻辑： sync = false return factory.loading ? factory.loadingComp : factory.resolved 如果 delay 配置为 0，则这次直接渲染 loading 组件，否则则延时 delay 执行 forceRender，那么又会再一次执行到 resolveAsyncComponent。 那么这时候我们有几种情况，按逻辑的执行顺序，对不同的情况做判断。 异步组件加载失败当异步组件加载失败，会执行 reject 函数： const reject = once(reason => { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed to resolve async component: ${String(factory)}` + (reason ? `\\nReason: ${reason}` : '') ) if (isDef(factory.errorComp)) { factory.error = true forceRender() } }) 这个时候会把 factory.error 设置为 true，同时执行 forceRender() 再次执行到 resolveAsyncComponent： if (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) { return factory.errorComp } 那么这个时候就返回 factory.errorComp，直接渲染 error 组件。 异步组件加载成功当异步组件加载成功，会执行 resolve 函数： const resolve = once((res: Object | Class&lt;Component>) => { factory.resolved = ensureCtor(res, baseCtor) if (!sync) { forceRender() } }) 首先把加载结果缓存到 factory.resolved 中，这个时候因为 sync 已经为 false，则执行 forceRender() 再次执行到 resolveAsyncComponent： if (isDef(factory.resolved)) { return factory.resolved } 那么这个时候直接返回 factory.resolved，渲染成功加载的组件。 异步组件加载中如果异步组件加载中并未返回，这时候会走到这个逻辑： if (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingComp)) { return factory.loadingComp } 那么则会返回 factory.loadingComp，渲染 loading 组件。 异步组件加载超时如果超时，则走到了 reject 逻辑，之后逻辑和加载失败一样，渲染 error 组件。 异步组件 patch回到 createComponent 的逻辑： Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context) if (Ctor === undefined) { return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) } 如果是第一次执行 resolveAsyncComponent，除非使用高级异步组件 0 delay 去创建了一个 loading 组件，否则返回是 undefiend，接着通过 createAsyncPlaceholder 创建一个注释节点作为占位符。它的定义在 src/core/vdom/helpers/resolve-async-components.js 中： export function createAsyncPlaceholder ( factory: Function, data: ?VNodeData, context: Component, children: ?Array&lt;VNode>, tag: ?string ): VNode { const node = createEmptyVNode() node.asyncFactory = factory node.asyncMeta = { data, context, children, tag } return node } 实际上就是就是创建了一个占位的注释 VNode，同时把 asyncFactory 和 asyncMeta 赋值给当前 vnode。 当执行 forceRender 的时候，会触发组件的重新渲染，那么会再一次执行 resolveAsyncComponent，这时候就会根据不同的情况，可能返回 loading、error 或成功加载的异步组件，返回值不为 undefined，因此就走正常的组件 render、patch 过程，与组件第一次渲染流程不一样，这个时候是存在新旧 vnode 的，下一章我会分析组件更新的 patch 过程。 总结通过以上代码分析，我们对 Vue 的异步组件的实现有了深入的了解，知道了 3 种异步组件的实现方式，并且看到高级异步组件的实现是非常巧妙的，它实现了 loading、resolve、reject、timeout 4 种状态。异步组件实现的本质是 2 次渲染，除了 0 delay 的高级异步组件第一次直接渲染成 loading 组件外，其它都是第一次渲染生成一个注释节点，当异步获取组件成功后，再通过 forceRender 强制重新渲染，这样就能正确渲染出我们异步加载的组件了。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"原生koa2实现静态资源服务器","slug":"004.koa学习/001.基础篇/004.静态资源加载/001.原生koa2实现静态资源服务器","date":"2018-03-03T14:39:51.000Z","updated":"2019-09-16T01:57:01.498Z","comments":true,"path":"2018/03/03/004.koa学习/001.基础篇/004.静态资源加载/001.原生koa2实现静态资源服务器/","link":"","permalink":"http://www.chenya.site/2018/03/03/004.koa学习/001.基础篇/004.静态资源加载/001.原生koa2实现静态资源服务器/","excerpt":"","text":"原生koa2实现静态资源服务器前言一个http请求访问web服务静态资源，一般响应结果有三种情况 访问文本，例如js，css，png，jpg，gif 访问静态目录 找不到资源，抛出404错误 原生koa2 静态资源服务器例子demo源码 static-server 代码目录├── static # 静态资源目录 │ ├── css/ │ ├── image/ │ ├── js/ │ └── index.html ├── util # 工具代码 │ ├── content.js # 读取请求内容 │ ├── dir.js # 读取目录内容 │ ├── file.js # 读取文件内容 │ ├── mimes.js # 文件类型列表 │ └── walk.js # 遍历目录内容 └── index.js # 启动入口文件 代码解析index.jsconst Koa = require('koa') const path = require('path') const content = require('./util/content') const mimes = require('./util/mimes') const app = new Koa() // 静态资源目录对于相对入口文件index.js的路径 const staticPath = './static' // 解析资源类型 function parseMime( url ) { let extName = path.extname( url ) extName = extName ? extName.slice(1) : 'unknown' return mimes[ extName ] } app.use( async ( ctx ) => { // 静态资源目录在本地的绝对路径 let fullStaticPath = path.join(__dirname, staticPath) // 获取静态资源内容，有可能是文件内容，目录，或404 let _content = await content( ctx, fullStaticPath ) // 解析请求内容的类型 let _mime = parseMime( ctx.url ) // 如果有对应的文件类型，就配置上下文的类型 if ( _mime ) { ctx.type = _mime } // 输出静态资源内容 if ( _mime &amp;&amp; _mime.indexOf('image/') >= 0 ) { // 如果是图片，则用node原生res，输出二进制数据 ctx.res.writeHead(200) ctx.res.write(_content, 'binary') ctx.res.end() } else { // 其他则输出文本 ctx.body = _content } }) app.listen(3000) console.log('[demo] static-server is starting at port 3000') util/content.jsconst path = require('path') const fs = require('fs') // 封装读取目录内容方法 const dir = require('./dir') // 封装读取文件内容方法 const file = require('./file') /** * 获取静态资源内容 * @param {object} ctx koa上下文 * @param {string} 静态资源目录在本地的绝对路径 * @return {string} 请求获取到的本地内容 */ async function content( ctx, fullStaticPath ) { // 封装请求资源的完绝对径 let reqPath = path.join(fullStaticPath, ctx.url) // 判断请求路径是否为存在目录或者文件 let exist = fs.existsSync( reqPath ) // 返回请求内容， 默认为空 let content = '' if( !exist ) { //如果请求路径不存在，返回404 content = '404 Not Found! o(╯□╰)o！' } else { //判断访问地址是文件夹还是文件 let stat = fs.statSync( reqPath ) if( stat.isDirectory() ) { //如果为目录，则渲读取目录内容 content = dir( ctx.url, reqPath ) } else { // 如果请求为文件，则读取文件内容 content = await file( reqPath ) } } return content } module.exports = content util/dir.jsconst url = require('url') const fs = require('fs') const path = require('path') // 遍历读取目录内容方法 const walk = require('./walk') /** * 封装目录内容 * @param {string} url 当前请求的上下文中的url，即ctx.url * @param {string} reqPath 请求静态资源的完整本地路径 * @return {string} 返回目录内容，封装成HTML */ function dir ( url, reqPath ) { // 遍历读取当前目录下的文件、子目录 let contentList = walk( reqPath ) let html = `&lt;ul>` for ( let [ index, item ] of contentList.entries() ) { html = `${html}&lt;li>&lt;a href=\"${url === '/' ? '' : url}/${item}\">${item}&lt;/a>` } html = `${html}&lt;/ul>` return html } module.exports = dir util/file.jsconst fs = require('fs') /** * 读取文件方法 * @param {string} 文件本地的绝对路径 * @return {string|binary} */ function file ( filePath ) { let content = fs.readFileSync(filePath, 'binary' ) return content } module.exports = file util/walk.jsconst fs = require('fs') const mimes = require('./mimes') /** * 遍历读取目录内容（子目录，文件名） * @param {string} reqPath 请求资源的绝对路径 * @return {array} 目录内容列表 */ function walk( reqPath ){ let files = fs.readdirSync( reqPath ); let dirList = [], fileList = []; for( let i=0, len=files.length; i&lt;len; i++ ) { let item = files[i]; let itemArr = item.split(\"\\.\"); let itemMime = ( itemArr.length > 1 ) ? itemArr[ itemArr.length - 1 ] : \"undefined\"; if( typeof mimes[ itemMime ] === \"undefined\" ) { dirList.push( files[i] ); } else { fileList.push( files[i] ); } } let result = dirList.concat( fileList ); return result; }; module.exports = walk; util/mime.jslet mimes = { 'css': 'text/css', 'less': 'text/css', 'gif': 'image/gif', 'html': 'text/html', 'ico': 'image/x-icon', 'jpeg': 'image/jpeg', 'jpg': 'image/jpeg', 'js': 'text/javascript', 'json': 'application/json', 'pdf': 'application/pdf', 'png': 'image/png', 'svg': 'image/svg+xml', 'swf': 'application/x-shockwave-flash', 'tiff': 'image/tiff', 'txt': 'text/plain', 'wav': 'audio/x-wav', 'wma': 'audio/x-ms-wma', 'wmv': 'video/x-ms-wmv', 'xml': 'text/xml' } module.exports = mimes 运行效果启动服务node index.js 效果访问http://localhost:3000 static-server-result 访问http://localhost:3000/index.html static-server-result 访问http://localhost:3000/js/index.js static-server-result","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"koa-bodyparser中间件","slug":"004.koa学习/001.基础篇/003.请求数据获取/003.koa-bodyparser中间件","date":"2018-02-23T11:25:21.000Z","updated":"2019-09-16T01:57:01.498Z","comments":true,"path":"2018/02/23/004.koa学习/001.基础篇/003.请求数据获取/003.koa-bodyparser中间件/","link":"","permalink":"http://www.chenya.site/2018/02/23/004.koa学习/001.基础篇/003.请求数据获取/003.koa-bodyparser中间件/","excerpt":"","text":"koa-bodyparser中间件原理对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文的formData数据解析到ctx.request.body中 安装koa2版本的koa-bodyparser@3中间件npm install --save koa-bodyparser@3 举个例子例子代码demo源码 request/post-middleware.js const Koa = require('koa') const app = new Koa() const bodyParser = require('koa-bodyparser') // 使用ctx.body解析中间件 app.use(bodyParser()) app.use( async ( ctx ) => { if ( ctx.url === '/' &amp;&amp; ctx.method === 'GET' ) { // 当GET请求时候返回表单页面 let html = ` &lt;h1>koa2 request post demo&lt;/h1> &lt;form method=\"POST\" action=\"/\"> &lt;p>userName&lt;/p> &lt;input name=\"userName\" />&lt;br/> &lt;p>nickName&lt;/p> &lt;input name=\"nickName\" />&lt;br/> &lt;p>email&lt;/p> &lt;input name=\"email\" />&lt;br/> &lt;button type=\"submit\">submit&lt;/button> &lt;/form> ` ctx.body = html } else if ( ctx.url === '/' &amp;&amp; ctx.method === 'POST' ) { // 当POST请求的时候，中间件koa-bodyparser解析POST表单里的数据，并显示出来 let postData = ctx.request.body ctx.body = postData } else { // 其他请求显示404 ctx.body = '&lt;h1>404！！！ o(╯□╰)o&lt;/h1>' } }) app.listen(3000, () => { console.log('[demo] request post is starting at port 3000') }) 启动例子node post-middleware.js 访问页面 request-post-form 提交表单发起POST请求结果显示 request-post-result","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"Vue源码学习 - 组件注册","slug":"005.vue源码学习/003.组件化/006.组件注册","date":"2018-02-18T13:14:23.000Z","updated":"2019-09-16T01:57:01.504Z","comments":true,"path":"2018/02/18/005.vue源码学习/003.组件化/006.组件注册/","link":"","permalink":"http://www.chenya.site/2018/02/18/005.vue源码学习/003.组件化/006.组件注册/","excerpt":"","text":"组件注册在 Vue.js 中，除了它内置的组件如 keep-alive、component、transition、transition-group 等，其它用户自定义组件在使用前必须注册。很多同学在开发过程中可能会遇到如下报错信息： &#39;Unknown custom element: &lt;xxx&gt; - did you register the component correctly? For recursive components, make sure to provide the &quot;name&quot; option.&#39; 一般报这个错的原因都是我们使用了未注册的组件。Vue.js 提供了 2 种组件的注册方式，全局注册和局部注册。接下来我们从源码分析的角度来分析这两种注册方式。 全局注册要注册一个全局组件，可以使用 Vue.component(tagName, options)。例如： Vue.component('my-component', { // 选项 }) 那么，Vue.component 函数是在什么时候定义的呢，它的定义过程发生在最开始初始化 Vue 的全局函数的时候，代码在 src/core/global-api/assets.js 中： import { ASSET_TYPES } from 'shared/constants' import { isPlainObject, validateComponentName } from '../util/index' export function initAssetRegisters (Vue: GlobalAPI) { /** * Create asset registration methods. */ ASSET_TYPES.forEach(type => { Vue[type] = function ( id: string, definition: Function | Object ): Function | Object | void { if (!definition) { return this.options[type + 's'][id] } else { /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; type === 'component') { validateComponentName(id) } if (type === 'component' &amp;&amp; isPlainObject(definition)) { definition.name = definition.name || id definition = this.options._base.extend(definition) } if (type === 'directive' &amp;&amp; typeof definition === 'function') { definition = { bind: definition, update: definition } } this.options[type + 's'][id] = definition return definition } } }) } 函数首先遍历 ASSET_TYPES，得到 type 后挂载到 Vue 上 。ASSET_TYPES 的定义在 src/shared/constants.js 中： export const ASSET_TYPES = [ 'component', 'directive', 'filter' ] 所以实际上 Vue 是初始化了 3 个全局函数，并且如果 type 是 component 且 definition 是一个对象的话，通过 this.opitons._base.extend， 相当于 Vue.extend 把这个对象转换成一个继承于 Vue 的构造函数，最后通过 this.options[type + &#39;s&#39;][id] = definition 把它挂载到 Vue.options.components 上。 由于我们每个组件的创建都是通过 Vue.extend 继承而来，我们之前分析过在继承的过程中有这么一段逻辑： Sub.options = mergeOptions( Super.options, extendOptions ) 也就是说它会把 Vue.options 合并到 Sub.options，也就是组件的 options 上， 然后在组件的实例化阶段，会执行 merge options 逻辑，把 Sub.options.components 合并到 vm.$options.components 上。 然后在创建 vnode 的过程中，会执行 _createElement 方法，我们再来回顾一下这部分的逻辑，它的定义在 src/core/vdom/create-element.js 中： export function _createElement ( context: Component, tag?: string | Class&lt;Component> | Function | Object, data?: VNodeData, children?: any, normalizationType?: number ): VNode | Array&lt;VNode> { // ... let vnode, ns if (typeof tag === 'string') { let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) if (config.isReservedTag(tag)) { // platform built-in elements vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) { // component vnode = createComponent(Ctor, data, context, children, tag) } else { // unknown or unlisted namespaced elements // check at runtime because it may get assigned a namespace when its // parent normalizes children vnode = new VNode( tag, data, children, undefined, undefined, context ) } } else { // direct component options / constructor vnode = createComponent(tag, data, context, children) } // ... } 这里有一个判断逻辑 isDef(Ctor = resolveAsset(context.$options, &#39;components&#39;, tag))，先来看一下 resolveAsset 的定义，在 src/core/utils/options.js 中： /** * Resolve an asset. * This function is used because child instances need access * to assets defined in its ancestor chain. */ export function resolveAsset ( options: Object, type: string, id: string, warnMissing?: boolean ): any { /* istanbul ignore if */ if (typeof id !== 'string') { return } const assets = options[type] // check local registration variations first if (hasOwn(assets, id)) return assets[id] const camelizedId = camelize(id) if (hasOwn(assets, camelizedId)) return assets[camelizedId] const PascalCaseId = capitalize(camelizedId) if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId] // fallback to prototype chain const res = assets[id] || assets[camelizedId] || assets[PascalCaseId] if (process.env.NODE_ENV !== 'production' &amp;&amp; warnMissing &amp;&amp; !res) { warn( 'Failed to resolve ' + type.slice(0, -1) + ': ' + id, options ) } return res } 这段逻辑很简单，先通过 const assets = options[type] 拿到 assets，然后再尝试拿 assets[id]，这里有个顺序，先直接使用 id 拿，如果不存在，则把 id 变成驼峰的形式再拿，如果仍然不存在则在驼峰的基础上把首字母再变成大写的形式再拿，如果仍然拿不到则报错。这样说明了我们在使用 Vue.component(id, definition) 全局注册组件的时候，id 可以是连字符、驼峰或首字母大写的形式。 那么回到我们的调用 resolveAsset(context.$options, &#39;components&#39;, tag)，即拿 vm.$options.components[tag]，这样我们就可以在 resolveAsset 的时候拿到这个组件的构造函数，并作为 createComponent 的钩子的参数。 局部注册Vue.js 也同样支持局部注册，我们可以在一个组件内部使用 components 选项做组件的局部注册，例如： import HelloWorld from './components/HelloWorld' export default { components: { HelloWorld } } 其实理解了全局注册的过程，局部注册是非常简单的。在组件的 Vue 的实例化阶段有一个合并 option 的逻辑，之前我们也分析过，所以就把 components 合并到 vm.$options.components 上，这样我们就可以在 resolveAsset 的时候拿到这个组件的构造函数，并作为 createComponent 的钩子的参数。 注意，局部注册和全局注册不同的是，只有该类型的组件才可以访问局部注册的子组件，而全局注册是扩展到 Vue.options 下，所以在所有组件创建的过程中，都会从全局的 Vue.options.components 扩展到当前组件的 vm.$options.components 下，这就是全局注册的组件能被任意使用的原因。 总结通过这一小节的分析，我们对组件的注册过程有了认识，并理解了全局注册和局部注册的差异。其实在平时的工作中，当我们使用到组件库的时候，往往更通用基础组件都是全局注册的，而编写的特例场景的业务组件都是局部注册的。了解了它们的原理，对我们在工作中到底使用全局注册组件还是局部注册组件是有这非常好的指导意义的。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - 生命周期","slug":"005.vue源码学习/003.组件化/005.生命周期","date":"2018-02-14T22:31:31.000Z","updated":"2019-09-16T01:57:01.504Z","comments":true,"path":"2018/02/15/005.vue源码学习/003.组件化/005.生命周期/","link":"","permalink":"http://www.chenya.site/2018/02/15/005.vue源码学习/003.组件化/005.生命周期/","excerpt":"","text":"生命周期每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。 生命周期 在我们实际项目开发过程中，会非常频繁地和 Vue 组件的生命周期打交道，接下来我们就从源码的角度来看一下这些生命周期的钩子函数是如何被执行的。 源码中最终执行生命周期的函数都是调用 callHook 方法，它的定义在 src/core/instance/lifecycle 中： export function callHook (vm: Component, hook: string) { // #7573 disable dep collection when invoking lifecycle hooks pushTarget() const handlers = vm.$options[hook] if (handlers) { for (let i = 0, j = handlers.length; i &lt; j; i++) { try { handlers[i].call(vm) } catch (e) { handleError(e, vm, `${hook} hook`) } } } if (vm._hasHookEvent) { vm.$emit('hook:' + hook) } popTarget() } callHook 函数的逻辑很简单，根据传入的字符串 hook，去拿到 vm.$options[hook] 对应的回调函数数组，然后遍历执行，执行的时候把 vm 作为函数执行的上下文。 在上一节中，我们详细地介绍了 Vue.js 合并 options 的过程，各个阶段的生命周期的函数也被合并到 vm.$options 里，并且是一个数组。因此 callhook 函数的功能就是调用某个生命周期钩子注册的所有回调函数。 了解了生命周期的执行方式后，接下来我们会具体介绍每一个生命周期函数它的调用时机。 beforeCreate &amp; createdbeforeCreate 和 created 函数都是在实例化 Vue 的阶段，在 _init 方法中执行的，它的定义在 src/core/instance/init.js 中： Vue.prototype._init = function (options?: Object) { // ... initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') // ... } 可以看到 beforeCreate 和 created 的钩子调用是在 initState 的前后，initState 的作用是初始化 props、data、methods、watch、computed 等属性，之后我们会详细分析。那么显然 beforeCreate 的钩子函数中就不能获取到 props、data 中定义的值，也不能调用 methods 中定义的函数。 在这俩个钩子函数执行的时候，并没有渲染 DOM，所以我们也不能够访问 DOM，一般来说，如果组件在加载的时候需要和后端有交互，放在这俩个钩子函数执行都可以，如果是需要访问 props、data 等数据的话，就需要使用 created 钩子函数。之后我们会介绍 vue-router 和 vuex 的时候会发现它们都混合了 beforeCreatd 钩子函数。 beforeMount &amp; mounted顾名思义，beforeMount 钩子函数发生在 mount，也就是 DOM 挂载之前，它的调用时机是在 mountComponent 函数中，定义在 src/core/instance/lifecycle.js 中： export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean ): Component { vm.$el = el // ... callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { updateComponent = () => { const name = vm._name const id = vm._uid const startTag = `vue-perf-start:${id}` const endTag = `vue-perf-end:${id}` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue ${name} render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue ${name} patch`, startTag, endTag) } } else { updateComponent = () => { vm._update(vm._render(), hydrating) } } // we set this to vm._watcher inside the watcher's constructor // since the watcher's initial patch may call $forceUpdate (e.g. inside child // component's mounted hook), which relies on vm._watcher being already defined new Watcher(vm, updateComponent, noop, { before () { if (vm._isMounted) { callHook(vm, 'beforeUpdate') } } }, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) { vm._isMounted = true callHook(vm, 'mounted') } return vm } 在执行 vm._render() 函数渲染 VNode 之前，执行了 beforeMount 钩子函数，在执行完 vm._update() 把 VNode patch 到真实 DOM 后，执行 mounted 钩子。注意，这里对 mounted 钩子函数执行有一个判断逻辑，vm.$vnode 如果为 null，则表明这不是一次组件的初始化过程，而是我们通过外部 new Vue 初始化过程。那么对于组件，它的 mounted 时机在哪儿呢？ 之前我们提到过，组件的 VNode patch 到 DOM 后，会执行 invokeInsertHook 函数，把 insertedVnodeQueue 里保存的钩子函数依次执行一遍，它的定义在 src/core/vdom/patch.js 中： function invokeInsertHook (vnode, queue, initial) { // delay insert hooks for component root nodes, invoke them after the // element is really inserted if (isTrue(initial) &amp;&amp; isDef(vnode.parent)) { vnode.parent.data.pendingInsert = queue } else { for (let i = 0; i &lt; queue.length; ++i) { queue[i].data.hook.insert(queue[i]) } } } 该函数会执行 insert 这个钩子函数，对于组件而言，insert 钩子函数的定义在 src/core/vdom/create-component.js 中的 componentVNodeHooks 中： const componentVNodeHooks = { // ... insert (vnode: MountedComponentVNode) { const { context, componentInstance } = vnode if (!componentInstance._isMounted) { componentInstance._isMounted = true callHook(componentInstance, 'mounted') } // ... }, } 我们可以看到，每个子组件都是在这个钩子函数中执行 mounted 钩子函数，并且我们之前分析过，insertedVnodeQueue 的添加顺序是先子后父，所以对于同步渲染的子组件而言，mounted 钩子函数的执行顺序也是先子后父。 beforeUpdate &amp; updated顾名思义，beforeUpdate 和 updated 的钩子函数执行时机都应该是在数据更新的时候，到目前为止，我们还没有分析 Vue 的数据双向绑定、更新相关，下一章我会详细介绍这个过程。 beforeUpdate 的执行时机是在渲染 Watcher 的 before 函数中，我们刚才提到过： export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean ): Component { // ... // we set this to vm._watcher inside the watcher's constructor // since the watcher's initial patch may call $forceUpdate (e.g. inside child // component's mounted hook), which relies on vm._watcher being already defined new Watcher(vm, updateComponent, noop, { before () { if (vm._isMounted) { callHook(vm, 'beforeUpdate') } } }, true /* isRenderWatcher */) // ... } 注意这里有个判断，也就是在组件已经 mounted 之后，才会去调用这个钩子函数。 update 的执行时机是在flushSchedulerQueue 函数调用的时候，它的定义在 src/core/observer/scheduler.js 中： function flushSchedulerQueue () { // ... // 获取到 updatedQueue callUpdatedHooks(updatedQueue) } function callUpdatedHooks (queue) { let i = queue.length while (i--) { const watcher = queue[i] const vm = watcher.vm if (vm._watcher === watcher &amp;&amp; vm._isMounted) { callHook(vm, 'updated') } } } flushSchedulerQueue 函数我们之后会详细介绍，可以先大概了解一下，updatedQueue 是更新了的 wathcer 数组，那么在 callUpdatedHooks 函数中，它对这些数组做遍历，只有满足当前 watcher 为 vm._watcher 以及组件已经 mounted 这两个条件，才会执行 updated 钩子函数。 我们之前提过，在组件 mount 的过程中，会实例化一个渲染的 Watcher 去监听 vm 上的数据变化重新渲染，这段逻辑发生在 mountComponent 函数执行的时候： export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean ): Component { // ... // 这里是简写 let updateComponent = () => { vm._update(vm._render(), hydrating) } new Watcher(vm, updateComponent, noop, { before () { if (vm._isMounted) { callHook(vm, 'beforeUpdate') } } }, true /* isRenderWatcher */) // ... } 那么在实例化 Watcher 的过程中，在它的构造函数里会判断 isRenderWatcher，接着把当前 watcher 的实例赋值给 vm._watcher，定义在 src/core/observer/watcher.js 中： export default class Watcher { // ... constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean ) { this.vm = vm if (isRenderWatcher) { vm._watcher = this } vm._watchers.push(this) // ... } } 同时，还把当前 wathcer 实例 push 到 vm._watchers 中，vm._watcher 是专门用来监听 vm 上数据变化然后重新渲染的，所以它是一个渲染相关的 watcher，因此在 callUpdatedHooks 函数中，只有 vm._watcher 的回调执行完毕后，才会执行 updated 钩子函数。 beforeDestroy &amp; destroyed顾名思义，beforeDestroy 和 destroyed 钩子函数的执行时机在组件销毁的阶段，组件的销毁过程之后会详细介绍，最终会调用 $destroy 方法，它的定义在 src/core/instance/lifecycle.js 中： Vue.prototype.$destroy = function () { const vm: Component = this if (vm._isBeingDestroyed) { return } callHook(vm, 'beforeDestroy') vm._isBeingDestroyed = true // remove self from parent const parent = vm.$parent if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) { remove(parent.$children, vm) } // teardown watchers if (vm._watcher) { vm._watcher.teardown() } let i = vm._watchers.length while (i--) { vm._watchers[i].teardown() } // remove reference from data ob // frozen object may not have observer. if (vm._data.__ob__) { vm._data.__ob__.vmCount-- } // call the last hook... vm._isDestroyed = true // invoke destroy hooks on current rendered tree vm.__patch__(vm._vnode, null) // fire destroyed hook callHook(vm, 'destroyed') // turn off all instance listeners. vm.$off() // remove __vue__ reference if (vm.$el) { vm.$el.__vue__ = null } // release circular reference (#6759) if (vm.$vnode) { vm.$vnode.parent = null } } beforeDestroy 钩子函数的执行时机是在 $destroy 函数执行最开始的地方，接着执行了一系列的销毁动作，包括从 parent 的 $children 中删掉自身，删除 watcher，当前渲染的 VNode 执行销毁钩子函数等，执行完毕后再调用 destroy 钩子函数。 在 $destroy 的执行过程中，它又会执行 vm.__patch__(vm._vnode, null) 触发它子组件的销毁钩子函数，这样一层层的递归调用，所以 destroy 钩子函数执行顺序是先子后父，和 mounted 过程一样。 activated &amp; deactivatedactivated 和 deactivated 钩子函数是专门为 keep-alive 组件定制的钩子，我们会在介绍 keep-alive 组件的时候详细介绍，这里先留个悬念。 总结这一节主要介绍了 Vue 生命周期中各个钩子函数的执行时机以及顺序，通过分析，我们知道了如在 created 钩子函数中可以访问到数据，在 mounted 钩子函数中可以访问到 DOM，在 destroy 钩子函数中可以做一些定时器销毁工作，了解它们有利于我们在合适的生命周期去做不同的事情。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - 合并配置","slug":"005.vue源码学习/003.组件化/004.合并配置","date":"2018-02-13T22:45:11.000Z","updated":"2019-09-16T01:57:01.503Z","comments":true,"path":"2018/02/14/005.vue源码学习/003.组件化/004.合并配置/","link":"","permalink":"http://www.chenya.site/2018/02/14/005.vue源码学习/003.组件化/004.合并配置/","excerpt":"","text":"合并配置通过之前章节的源码分析我们知道，new Vue 的过程通常有 2 种场景，一种是外部我们的代码主动调用 new Vue(options) 的方式实例化一个 Vue 对象；另一种是我们上一节分析的组件过程中内部通过 new Vue(options) 实例化子组件。 无论哪种场景，都会执行实例的 _init(options) 方法，它首先会执行一个 merge options 的逻辑，相关的代码在 src/core/instance/init.js 中： Vue.prototype._init = function (options?: Object) { // merge options if (options &amp;&amp; options._isComponent) { // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) } else { vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) } // ... } 可以看到不同场景对于 options 的合并逻辑是不一样的，并且传入的 options 值也有非常大的不同，接下来我会分开介绍 2 种场景的 options 合并过程。 为了更直观，我们可以举个简单的示例： import Vue from 'vue' let childComp = { template: '&lt;div>{{msg}}&lt;/div>', created() { console.log('child created') }, mounted() { console.log('child mounted') }, data() { return { msg: 'Hello Vue' } } } Vue.mixin({ created() { console.log('parent created') } }) let app = new Vue({ el: '#app', render: h => h(childComp) }) 外部调用场景当执行 new Vue 的时候，在执行 this._init(options) 的时候，就会执行如下逻辑去合并 options： vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) 这里通过调用 mergeOptions 方法来合并，它实际上就是把 resolveConstructorOptions(vm.constructor) 的返回值和 options 做合并，resolveConstructorOptions 的实现先不考虑，在我们这个场景下，它还是简单返回 vm.constructor.options，相当于 Vue.options，那么这个值又是什么呢，其实在 initGlobalAPI(Vue) 的时候定义了这个值，代码在 src/core/global-api/index.js 中： export function initGlobalAPI (Vue: GlobalAPI) { // ... Vue.options = Object.create(null) ASSET_TYPES.forEach(type => { Vue.options[type + 's'] = Object.create(null) }) // this is used to identify the \"base\" constructor to extend all plain-object // components with in Weex's multi-instance scenarios. Vue.options._base = Vue extend(Vue.options.components, builtInComponents) // ... } 首先通过 Vue.options = Object.create(null) 创建一个空对象，然后遍历 ASSET_TYPES，ASSET_TYPES 的定义在 src/shared/constants.js 中： export const ASSET_TYPES = [ 'component', 'directive', 'filter' ] 所以上面遍历 ASSET_TYPES 后的代码相当于： Vue.options.components = {} Vue.options.directives = {} Vue.options.filters = {} 接着执行了 Vue.options._base = Vue，它的作用在我们上节实例化子组件的时候介绍了。 最后通过 extend(Vue.options.components, builtInComponents) 把一些内置组件扩展到 Vue.options.components 上，Vue 的内置组件目前有 &lt;keep-alive&gt;、&lt;transition&gt; 和 &lt;transition-group&gt; 组件，这也就是为什么我们在其它组件中使用 &lt;keep-alive&gt; 组件不需要注册的原因，这块儿后续我们介绍 &lt;keep-alive&gt; 组件的时候会详细讲。 那么回到 mergeOptions 这个函数，它的定义在 src/core/util/options.js 中： /** * Merge two option objects into a new one. * Core utility used in both instantiation and inheritance. */ export function mergeOptions ( parent: Object, child: Object, vm?: Component ): Object { if (process.env.NODE_ENV !== 'production') { checkComponents(child) } if (typeof child === 'function') { child = child.options } normalizeProps(child, vm) normalizeInject(child, vm) normalizeDirectives(child) const extendsFrom = child.extends if (extendsFrom) { parent = mergeOptions(parent, extendsFrom, vm) } if (child.mixins) { for (let i = 0, l = child.mixins.length; i &lt; l; i++) { parent = mergeOptions(parent, child.mixins[i], vm) } } const options = {} let key for (key in parent) { mergeField(key) } for (key in child) { if (!hasOwn(parent, key)) { mergeField(key) } } function mergeField (key) { const strat = strats[key] || defaultStrat options[key] = strat(parent[key], child[key], vm, key) } return options } mergeOptions 主要功能就是把 parent 和 child 这两个对象根据一些合并策略，合并成一个新对象并返回。比较核心的几步，先递归把 extends 和 mixins 合并到 parent 上，然后遍历 parent，调用 mergeField，然后再遍历 child，如果 key 不在 parent 的自身属性上，则调用 mergeField。 这里有意思的是 mergeField 函数，它对不同的 key 有着不同的合并策略。举例来说，对于生命周期函数，它的合并策略是这样的： function mergeHook ( parentVal: ?Array&lt;Function>, childVal: ?Function | ?Array&lt;Function> ): ?Array&lt;Function> { return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal } LIFECYCLE_HOOKS.forEach(hook => { strats[hook] = mergeHook }) 这其中的 LIFECYCLE_HOOKS 的定义在 src/shared/constants.js 中： export const LIFECYCLE_HOOKS = [ 'beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured' ] 这里定义了 Vue.js 所有的钩子函数名称，所以对于钩子函数，他们的合并策略都是 mergeHook 函数。这个函数的实现也非常有意思，用了一个多层 3 元运算符，逻辑就是如果不存在 childVal ，就返回 parentVal；否则再判断是否存在 parentVal，如果存在就把 childVal 添加到 parentVal 后返回新数组；否则返回 childVal 的数组。所以回到 mergeOptions 函数，一旦 parent 和 child 都定义了相同的钩子函数，那么它们会把 2 个钩子函数合并成一个数组。 关于其它属性的合并策略的定义都可以在 src/core/util/options.js 文件中看到，这里不一一介绍了，感兴趣的同学可以自己看。 通过执行 mergeField 函数，把合并后的结果保存到 options 对象中，最终返回它。 因此，在我们当前这个 case 下，执行完如下合并后： vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) vm.$options 的值差不多是如下这样： vm.$options = { components: { }, created: [ function created() { console.log('parent created') } ], directives: { }, filters: { }, _base: function Vue(options) { // ... }, el: \"#app\", render: function (h) { //... } } 组件场景由于组件的构造函数是通过 Vue.extend 继承自 Vue 的，先回顾一下这个过程，代码定义在 src/core/global-api/extend.js 中。 /** * Class inheritance */ Vue.extend = function (extendOptions: Object): Function { // ... Sub.options = mergeOptions( Super.options, extendOptions ) // ... // keep a reference to the super options at extension time. // later at instantiation we can check if Super's options have // been updated. Sub.superOptions = Super.options Sub.extendOptions = extendOptions Sub.sealedOptions = extend({}, Sub.options) // ... return Sub } 我们只保留关键逻辑，这里的 extendOptions 对应的就是前面定义的组件对象，它会和 Vue.options 合并到 Sub.opitons 中。 接下来我们再回忆一下子组件的初始化过程，代码定义在 src/core/vdom/create-component.js 中： export function createComponentInstanceForVnode ( vnode: any, // we know it's MountedComponentVNode but flow doesn't parent: any, // activeInstance in lifecycle state ): Component { const options: InternalComponentOptions = { _isComponent: true, _parentVnode: vnode, parent } // ... return new vnode.componentOptions.Ctor(options) } 这里的 vnode.componentOptions.Ctor 就是指向 Vue.extend 的返回值 Sub， 所以 执行 new vnode.componentOptions.Ctor(options) 接着执行 this._init(options)，因为 options._isComponent 为 true，那么合并 options 的过程走到了 initInternalComponent(vm, options) 逻辑。先来看一下它的代码实现，在 src/core/instance/init.js 中： export function initInternalComponent (vm: Component, options: InternalComponentOptions) { const opts = vm.$options = Object.create(vm.constructor.options) // doing this because it's faster than dynamic enumeration. const parentVnode = options._parentVnode opts.parent = options.parent opts._parentVnode = parentVnode const vnodeComponentOptions = parentVnode.componentOptions opts.propsData = vnodeComponentOptions.propsData opts._parentListeners = vnodeComponentOptions.listeners opts._renderChildren = vnodeComponentOptions.children opts._componentTag = vnodeComponentOptions.tag if (options.render) { opts.render = options.render opts.staticRenderFns = options.staticRenderFns } } initInternalComponent 方法首先执行 const opts = vm.$options = Object.create(vm.constructor.options)，这里的 vm.constructor 就是子组件的构造函数 Sub，相当于 vm.$options = Object.create(Sub.options)。 接着又把实例化子组件传入的子组件父 VNode 实例 parentVnode、子组件的父 Vue 实例 parent 保存到 vm.$options 中，另外还保留了 parentVnode 配置中的如 propsData 等其它的属性。 这么看来，initInternalComponent 只是做了简单一层对象赋值，并不涉及到递归、合并策略等复杂逻辑。 因此，在我们当前这个 case 下，执行完如下合并后： initInternalComponent(vm, options) vm.$options 的值差不多是如下这样： vm.$options = { parent: Vue /*父Vue实例*/, propsData: undefined, _componentTag: undefined, _parentVnode: VNode /*父VNode实例*/, _renderChildren:undefined, __proto__: { components: { }, directives: { }, filters: { }, _base: function Vue(options) { //... }, _Ctor: {}, created: [ function created() { console.log('parent created') }, function created() { console.log('child created') } ], mounted: [ function mounted() { console.log('child mounted') } ], data() { return { msg: 'Hello Vue' } }, template: '&lt;div>{{msg}}&lt;/div>' } } 总结那么至此，Vue 初始化阶段对于 options 的合并过程就介绍完了，我们需要知道对于 options 的合并有 2 种方式，子组件初始化过程通过 initInternalComponent 方式要比外部初始化 Vue 通过 mergeOptions 的过程要快，合并完的结果保留在 vm.$options 中。 纵观一些库、框架的设计几乎都是类似的，自身定义了一些默认配置，同时又可以在初始化阶段传入一些定义配置，然后去 merge 默认配置，来达到定制化不同需求的目的。只不过在 Vue 的场景下，会对 merge 的过程做一些精细化控制，虽然我们在开发自己的 JSSDK 的时候并没有 Vue 这么复杂，但这个设计思想是值得我们借鉴的。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"POST请求参数获取","slug":"004.koa学习/001.基础篇/003.请求数据获取/002.POST请求参数获取","date":"2018-02-13T10:24:17.000Z","updated":"2019-09-16T01:57:01.498Z","comments":true,"path":"2018/02/13/004.koa学习/001.基础篇/003.请求数据获取/002.POST请求参数获取/","link":"","permalink":"http://www.chenya.site/2018/02/13/004.koa学习/001.基础篇/003.请求数据获取/002.POST请求参数获取/","excerpt":"","text":"POST请求参数获取原理对于POST请求的处理，koa2没有封装获取参数的方法，需要通过解析上下文context中的原生node.js请求对象req，将POST表单数据解析成query string（例如：a=1&amp;b=2&amp;c=3），再将query string 解析成JSON格式（例如：{&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:&quot;2&quot;, &quot;c&quot;:&quot;3&quot;}） 注意：ctx.request是context经过封装的请求对象，ctx.req是context提供的node.js原生HTTP请求对象，同理ctx.response是context经过封装的响应对象，ctx.res是context提供的node.js原生HTTP请求对象。 具体koa2 API文档可见 https://github.com/koajs/koa/blob/master/docs/api/context.md#ctxreq 解析出POST请求上下文中的表单数据demo源码 request/post.js // 解析上下文里node原生请求的POST参数 function parsePostData( ctx ) { return new Promise((resolve, reject) => { try { let postdata = \"\"; ctx.req.addListener('data', (data) => { postdata += data }) ctx.req.addListener(\"end\",function(){ let parseData = parseQueryStr( postdata ) resolve( parseData ) }) } catch ( err ) { reject(err) } }) } // 将POST请求参数字符串解析成JSON function parseQueryStr( queryStr ) { let queryData = {} let queryStrList = queryStr.split('&amp;') console.log( queryStrList ) for ( let [ index, queryStr ] of queryStrList.entries() ) { let itemList = queryStr.split('=') queryData[ itemList[0] ] = decodeURIComponent(itemList[1]) } return queryData } 举个例子源码在 /demos/request/post.js中 例子代码const Koa = require('koa') const app = new Koa() app.use( async ( ctx ) => { if ( ctx.url === '/' &amp;&amp; ctx.method === 'GET' ) { // 当GET请求时候返回表单页面 let html = ` &lt;h1>koa2 request post demo&lt;/h1> &lt;form method=\"POST\" action=\"/\"> &lt;p>userName&lt;/p> &lt;input name=\"userName\" />&lt;br/> &lt;p>nickName&lt;/p> &lt;input name=\"nickName\" />&lt;br/> &lt;p>email&lt;/p> &lt;input name=\"email\" />&lt;br/> &lt;button type=\"submit\">submit&lt;/button> &lt;/form> ` ctx.body = html } else if ( ctx.url === '/' &amp;&amp; ctx.method === 'POST' ) { // 当POST请求的时候，解析POST表单里的数据，并显示出来 let postData = await parsePostData( ctx ) ctx.body = postData } else { // 其他请求显示404 ctx.body = '&lt;h1>404！！！ o(╯□╰)o&lt;/h1>' } }) // 解析上下文里node原生请求的POST参数 function parsePostData( ctx ) { return new Promise((resolve, reject) => { try { let postdata = \"\"; ctx.req.addListener('data', (data) => { postdata += data }) ctx.req.addListener(\"end\",function(){ let parseData = parseQueryStr( postdata ) resolve( parseData ) }) } catch ( err ) { reject(err) } }) } // 将POST请求参数字符串解析成JSON function parseQueryStr( queryStr ) { let queryData = {} let queryStrList = queryStr.split('&amp;') console.log( queryStrList ) for ( let [ index, queryStr ] of queryStrList.entries() ) { let itemList = queryStr.split('=') queryData[ itemList[0] ] = decodeURIComponent(itemList[1]) } return queryData } app.listen(3000, () => { console.log('[demo] request post is starting at port 3000') }) 启动例子node post.js 访问页面 request-post-form 提交表单发起POST请求结果显示 request-post-result","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"Vue源码学习 - patch","slug":"005.vue源码学习/003.组件化/003.patch","date":"2018-02-12T14:15:23.000Z","updated":"2019-09-16T01:57:01.503Z","comments":true,"path":"2018/02/12/005.vue源码学习/003.组件化/003.patch/","link":"","permalink":"http://www.chenya.site/2018/02/12/005.vue源码学习/003.组件化/003.patch/","excerpt":"","text":"patch通过前一章的分析我们知道，当我们通过 createComponent 创建了组件 VNode，接下来会走到 vm._update，执行 vm.__patch__ 去把 VNode 转换成真正的 DOM 节点。这个过程我们在前一章已经分析过了，但是针对一个普通的 VNode 节点，接下来我们来看看组件的 VNode 会有哪些不一样的地方。 patch 的过程会调用 createElm 创建元素节点，回顾一下 createElm 的实现，它的定义在 src/core/vdom/patch.js 中： function createElm ( vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index ) { // ... if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) { return } // ... } createComponent我们删掉多余的代码，只保留关键的逻辑，这里会判断 createComponent(vnode, insertedVnodeQueue, parentElm, refElm) 的返回值，如果为 true 则直接结束，那么接下来看一下 createComponent 方法的实现： function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) { let i = vnode.data if (isDef(i)) { const isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive if (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) { i(vnode, false /* hydrating */) } // after calling the init hook, if the vnode is a child component // it should've created a child instance and mounted it. the child // component also has set the placeholder vnode's elm. // in that case we can just return the element and be done. if (isDef(vnode.componentInstance)) { initComponent(vnode, insertedVnodeQueue) insert(parentElm, vnode.elm, refElm) if (isTrue(isReactivated)) { reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) } return true } } } createComponent 函数中，首先对 vnode.data 做了一些判断： let i = vnode.data if (isDef(i)) { // ... if (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) { i(vnode, false /* hydrating */) // ... } // .. } 如果 vnode 是一个组件 VNode，那么条件会满足，并且得到 i 就是 init 钩子函数，回顾上节我们在创建组件 VNode 的时候合并钩子函数中就包含 init 钩子函数，定义在 src/core/vdom/create-component.js 中： init (vnode: VNodeWithData, hydrating: boolean): ?boolean { if ( vnode.componentInstance &amp;&amp; !vnode.componentInstance._isDestroyed &amp;&amp; vnode.data.keepAlive ) { // kept-alive components, treat as a patch const mountedNode: any = vnode // work around flow componentVNodeHooks.prepatch(mountedNode, mountedNode) } else { const child = vnode.componentInstance = createComponentInstanceForVnode( vnode, activeInstance ) child.$mount(hydrating ? vnode.elm : undefined, hydrating) } }, init 钩子函数执行也很简单，我们先不考虑 keepAlive 的情况，它是通过 createComponentInstanceForVnode 创建一个 Vue 的实例，然后调用 $mount 方法挂载子组件，先来看一下 createComponentInstanceForVnode 的实现： export function createComponentInstanceForVnode ( vnode: any, // we know it's MountedComponentVNode but flow doesn't parent: any, // activeInstance in lifecycle state ): Component { const options: InternalComponentOptions = { _isComponent: true, _parentVnode: vnode, parent } // check inline-template render functions const inlineTemplate = vnode.data.inlineTemplate if (isDef(inlineTemplate)) { options.render = inlineTemplate.render options.staticRenderFns = inlineTemplate.staticRenderFns } return new vnode.componentOptions.Ctor(options) } createComponentInstanceForVnode 函数构造的一个内部组件的参数，然后执行 new vnode.componentOptions.Ctor(options)。这里的 vnode.componentOptions.Ctor 对应的就是子组件的构造函数，我们上一节分析了它实际上是继承于 Vue 的一个构造器 Sub，相当于 new Sub(options) 这里有几个关键参数要注意几个点，_isComponent 为 true 表示它是一个组件，parent 表示当前激活的组件实例（注意，这里比较有意思的是如何拿到组件实例，后面会介绍。 所以子组件的实例化实际上就是在这个时机执行的，并且它会执行实例的 _init 方法，这个过程有一些和之前不同的地方需要挑出来说，代码在 src/core/instance/init.js 中： Vue.prototype._init = function (options?: Object) { const vm: Component = this // merge options if (options &amp;&amp; options._isComponent) { // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) } else { vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) } // ... if (vm.$options.el) { vm.$mount(vm.$options.el) } } 这里首先是合并 options 的过程有变化，_isComponent 为 true，所以走到了 initInternalComponent 过程，这个函数的实现也简单看一下： export function initInternalComponent (vm: Component, options: InternalComponentOptions) { const opts = vm.$options = Object.create(vm.constructor.options) // doing this because it's faster than dynamic enumeration. const parentVnode = options._parentVnode opts.parent = options.parent opts._parentVnode = parentVnode const vnodeComponentOptions = parentVnode.componentOptions opts.propsData = vnodeComponentOptions.propsData opts._parentListeners = vnodeComponentOptions.listeners opts._renderChildren = vnodeComponentOptions.children opts._componentTag = vnodeComponentOptions.tag if (options.render) { opts.render = options.render opts.staticRenderFns = options.staticRenderFns } } 这个过程我们重点记住以下几个点即可：opts.parent = options.parent、opts._parentVnode = parentVnode，它们是把之前我们通过 createComponentInstanceForVnode 函数传入的几个参数合并到内部的选项 $options 里了。 再来看一下 _init 函数最后执行的代码： if (vm.$options.el) { vm.$mount(vm.$options.el) } 由于组件初始化的时候是不传 el 的，因此组件是自己接管了 $mount 的过程，这个过程的主要流程在上一章介绍过了，回到组件 init 的过程，componentVNodeHooks 的 init 钩子函数，在完成实例化的 _init 后，接着会执行 child.$mount(hydrating ? vnode.elm : undefined, hydrating) 。这里 hydrating 为 true 一般是服务端渲染的情况，我们只考虑客户端渲染，所以这里 $mount 相当于执行 child.$mount(undefined, false)，它最终会调用 mountComponent 方法，进而执行 vm._render() 方法： Vue.prototype._render = function (): VNode { const vm: Component = this const { render, _parentVnode } = vm.$options // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try { vnode = render.call(vm._renderProxy, vm.$createElement) } catch (e) { // ... } // set parent vnode.parent = _parentVnode return vnode } 我们只保留关键部分的代码，这里的 _parentVnode 就是当前组件的父 VNode，而 render 函数生成的 vnode 当前组件的渲染 vnode，vnode 的 parent 指向了 _parentVnode，也就是 vm.$vnode，它们是一种父子的关系。 我们知道在执行完 vm._render 生成 VNode 后，接下来就要执行 vm._update 去渲染 VNode 了。来看一下组件渲染的过程中有哪些需要注意的，vm._update 的定义在 src/core/instance/lifecycle.js 中： export let activeInstance: any = null Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) { const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const prevActiveInstance = activeInstance activeInstance = vm vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) { // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) } else { // updates vm.$el = vm.__patch__(prevVnode, vnode) } activeInstance = prevActiveInstance // update __vue__ reference if (prevEl) { prevEl.__vue__ = null } if (vm.$el) { vm.$el.__vue__ = vm } // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) { vm.$parent.$el = vm.$el } // updated hook is called by the scheduler to ensure that children are // updated in a parent's updated hook. } _update 过程中有几个关键的代码，首先 vm._vnode = vnode 的逻辑，这个 vnode 是通过 vm._render() 返回的组件渲染 VNode，vm._vnode 和 vm.$vnode 的关系就是一种父子关系，用代码表达就是 vm._vnode.parent === vm.$vnode。还有一段比较有意思的代码： export let activeInstance: any = null Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) { // ... const prevActiveInstance = activeInstance activeInstance = vm if (!prevVnode) { // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) } else { // updates vm.$el = vm.__patch__(prevVnode, vnode) } activeInstance = prevActiveInstance // ... } 这个 activeInstance 作用就是保持当前上下文的 Vue 实例，它是在 lifecycle 模块的全局变量，定义是 export let activeInstance: any = null，并且在之前我们调用 createComponentInstanceForVnode 方法的时候从 lifecycle 模块获取，并且作为参数传入的。因为实际上 JavaScript 是一个单线程，Vue 整个初始化是一个深度遍历的过程，在实例化子组件的过程中，它需要知道当前上下文的 Vue 实例是什么，并把它作为子组件的父 Vue 实例。之前我们提到过对子组件的实例化过程先会调用 initInternalComponent(vm, options) 合并 options，把 parent 存储在 vm.$options 中，在 $mount 之前会调用 initLifecycle(vm) 方法： export function initLifecycle (vm: Component) { const options = vm.$options // locate first non-abstract parent let parent = options.parent if (parent &amp;&amp; !options.abstract) { while (parent.$options.abstract &amp;&amp; parent.$parent) { parent = parent.$parent } parent.$children.push(vm) } vm.$parent = parent // ... } 可以看到 vm.$parent 就是用来保留当前 vm 的父实例，并且通过 parent.$children.push(vm) 来把当前的 vm 存储到父实例的 $children 中。 在 vm._update 的过程中，把当前的 vm 赋值给 activeInstance，同时通过 const prevActiveInstance = activeInstance 用 prevActiveInstance 保留上一次的 activeInstance。实际上，prevActiveInstance 和当前的 vm 是一个父子关系，当一个 vm 实例完成它的所有子树的 patch 或者 update 过程后，activeInstance 会回到它的父实例，这样就完美地保证了 createComponentInstanceForVnode 整个深度遍历过程中，我们在实例化子组件的时候能传入当前子组件的父 Vue 实例，并在 _init 的过程中，通过 vm.$parent 把这个父子关系保留。 那么回到 _update，最后就是调用 __patch__ 渲染 VNode 了。 vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) function patch (oldVnode, vnode, hydrating, removeOnly) { // ... let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) { // empty mount (likely as component), create new root element isInitialPatch = true createElm(vnode, insertedVnodeQueue) } else { // ... } // ... } 这里又回到了本节开始的过程，之前分析过负责渲染成 DOM 的函数是 createElm，注意这里我们只传了 2 个参数，所以对应的 parentElm 是 undefined。我们再来看看它的定义： function createElm ( vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index ) { // ... if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) { return } const data = vnode.data const children = vnode.children const tag = vnode.tag if (isDef(tag)) { // ... vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode) setScope(vnode) /* istanbul ignore if */ if (__WEEX__) { // ... } else { createChildren(vnode, children, insertedVnodeQueue) if (isDef(data)) { invokeCreateHooks(vnode, insertedVnodeQueue) } insert(parentElm, vnode.elm, refElm) } // ... } else if (isTrue(vnode.isComment)) { vnode.elm = nodeOps.createComment(vnode.text) insert(parentElm, vnode.elm, refElm) } else { vnode.elm = nodeOps.createTextNode(vnode.text) insert(parentElm, vnode.elm, refElm) } } 注意，这里我们传入的 vnode 是组件渲染的 vnode，也就是我们之前说的 vm._vnode，如果组件的根节点是个普通元素，那么 vm._vnode 也是普通的 vnode，这里 createComponent(vnode, insertedVnodeQueue, parentElm, refElm) 的返回值是 false。接下来的过程就和我们上一章一样了，先创建一个父节点占位符，然后再遍历所有子 VNode 递归调用 createElm，在遍历的过程中，如果遇到子 VNode 是一个组件的 VNode，则重复本节开始的过程，这样通过一个递归的方式就可以完整地构建了整个组件树。 由于我们这个时候传入的 parentElm 是空，所以对组件的插入，在 createComponent 有这么一段逻辑： function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) { let i = vnode.data if (isDef(i)) { // .... if (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) { i(vnode, false /* hydrating */) } // ... if (isDef(vnode.componentInstance)) { initComponent(vnode, insertedVnodeQueue) insert(parentElm, vnode.elm, refElm) if (isTrue(isReactivated)) { reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) } return true } } } 在完成组件的整个 patch 过程后，最后执行 insert(parentElm, vnode.elm, refElm) 完成组件的 DOM 插入，如果组件 patch 过程中又创建了子组件，那么DOM 的插入顺序是先子后父。 总结那么到此，一个组件的 VNode 是如何创建、初始化、渲染的过程也就介绍完毕了。在对组件化的实现有一个大概了解后，接下来我们来介绍一下这其中的一些细节。我们知道编写一个组件实际上是编写一个 JavaScript 对象，对象的描述就是各种配置，之前我们提到在 _init 的最初阶段执行的就是 merge options 的逻辑，那么下一节我们从源码角度来分析合并配置的过程。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - create-component","slug":"005.vue源码学习/003.组件化/002.create-component","date":"2018-02-06T01:50:23.000Z","updated":"2019-09-16T01:57:01.503Z","comments":true,"path":"2018/02/06/005.vue源码学习/003.组件化/002.create-component/","link":"","permalink":"http://www.chenya.site/2018/02/06/005.vue源码学习/003.组件化/002.create-component/","excerpt":"","text":"createComponent上一章我们在分析 createElement 的实现的时候，它最终会调用 _createElement 方法，其中有一段逻辑是对参数 tag 的判断，如果是一个普通的 html 标签，像上一章的例子那样是一个普通的 div，则会实例化一个普通 VNode 节点，否则通过 createComponent 方法创建一个组件 VNode。 if (typeof tag === 'string') { let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) if (config.isReservedTag(tag)) { // platform built-in elements vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) { // component vnode = createComponent(Ctor, data, context, children, tag) } else { // unknown or unlisted namespaced elements // check at runtime because it may get assigned a namespace when its // parent normalizes children vnode = new VNode( tag, data, children, undefined, undefined, context ) } } else { // direct component options / constructor vnode = createComponent(tag, data, context, children) } 在我们这一章传入的是一个 App 对象，它本质上是一个 Component 类型，那么它会走到上述代码的 else 逻辑，直接通过 createComponent 方法来创建 vnode。所以接下来我们来看一下 createComponent 方法的实现，它定义在 src/core/vdom/create-component.js 文件中： export function createComponent ( Ctor: Class&lt;Component> | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array&lt;VNode>, tag?: string ): VNode | Array&lt;VNode> | void { if (isUndef(Ctor)) { return } const baseCtor = context.$options._base // plain options object: turn it into a constructor if (isObject(Ctor)) { Ctor = baseCtor.extend(Ctor) } // if at this stage it's not a constructor or an async component factory, // reject. if (typeof Ctor !== 'function') { if (process.env.NODE_ENV !== 'production') { warn(`Invalid Component definition: ${String(Ctor)}`, context) } return } // async component let asyncFactory if (isUndef(Ctor.cid)) { asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context) if (Ctor === undefined) { // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) } } data = data || {} // resolve constructor options in case global mixins are applied after // component constructor creation resolveConstructorOptions(Ctor) // transform component v-model data into props &amp; events if (isDef(data.model)) { transformModel(Ctor.options, data) } // extract props const propsData = extractPropsFromVNodeData(data, Ctor, tag) // functional component if (isTrue(Ctor.options.functional)) { return createFunctionalComponent(Ctor, propsData, data, context, children) } // extract listeners, since these needs to be treated as // child component listeners instead of DOM listeners const listeners = data.on // replace with listeners with .native modifier // so it gets processed during parent component patch. data.on = data.nativeOn if (isTrue(Ctor.options.abstract)) { // abstract components do not keep anything // other than props &amp; listeners &amp; slot // work around flow const slot = data.slot data = {} if (slot) { data.slot = slot } } // install component management hooks onto the placeholder node installComponentHooks(data) // return a placeholder vnode const name = Ctor.options.name || tag const vnode = new VNode( `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`, data, undefined, undefined, undefined, context, { Ctor, propsData, listeners, tag, children }, asyncFactory ) // Weex specific: invoke recycle-list optimized @render function for // extracting cell-slot template. // https://github.com/Hanks10100/weex-native-directive/tree/master/component /* istanbul ignore if */ if (__WEEX__ &amp;&amp; isRecyclableComponent(vnode)) { return renderRecyclableComponentTemplate(vnode) } return vnode } 可以看到，createComponent 的逻辑也会有一些复杂，但是分析源码比较推荐的是只分析核心流程，分支流程可以之后针对性的看，所以这里针对组件渲染这个 case 主要就 3 个关键步骤： 构造子类构造函数，安装组件钩子函数和实例化 vnode。 构造子类构造函数const baseCtor = context.$options._base // plain options object: turn it into a constructor if (isObject(Ctor)) { Ctor = baseCtor.extend(Ctor) } 我们在编写一个组件的时候，通常都是创建一个普通对象，还是以我们的 App.vue 为例，代码如下： import HelloWorld from './components/HelloWorld' export default { name: 'app', components: { HelloWorld } } 这里 export 的是一个对象，所以 createComponent 里的代码逻辑会执行到 baseCtor.extend(Ctor)，在这里 baseCtor 实际上就是 Vue，这个的定义是在最开始初始化 Vue 的阶段，在 src/core/global-api/index.js 中的 initGlobalAPI 函数有这么一段逻辑： // this is used to identify the \"base\" constructor to extend all plain-object // components with in Weex's multi-instance scenarios. Vue.options._base = Vue 细心的同学会发现，这里定义的是 Vue.options，而我们的 createComponent 取的是 context.$options，实际上在 src/core/instance/init.js 里 Vue 原型上的 _init 函数中有这么一段逻辑： vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) 这样就把 Vue 上的一些 option 扩展到了 vm.$options 上，所以我们也就能通过 vm.$options._base 拿到 Vue 这个构造函数了。mergeOptions 的实现我们会在后续章节中具体分析，现在只需要理解它的功能是把 Vue 构造函数的 options 和用户传入的 options 做一层合并，到 vm.$options 上。 在了解了 baseCtor 指向了 Vue 之后，我们来看一下 Vue.extend 函数的定义，在 src/core/global-api/extend.js 中。 /** * Class inheritance */ Vue.extend = function (extendOptions: Object): Function { extendOptions = extendOptions || {} const Super = this const SuperId = Super.cid const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {}) if (cachedCtors[SuperId]) { return cachedCtors[SuperId] } const name = extendOptions.name || Super.options.name if (process.env.NODE_ENV !== 'production' &amp;&amp; name) { validateComponentName(name) } const Sub = function VueComponent (options) { this._init(options) } Sub.prototype = Object.create(Super.prototype) Sub.prototype.constructor = Sub Sub.cid = cid++ Sub.options = mergeOptions( Super.options, extendOptions ) Sub['super'] = Super // For props and computed properties, we define the proxy getters on // the Vue instances at extension time, on the extended prototype. This // avoids Object.defineProperty calls for each instance created. if (Sub.options.props) { initProps(Sub) } if (Sub.options.computed) { initComputed(Sub) } // allow further extension/mixin/plugin usage Sub.extend = Super.extend Sub.mixin = Super.mixin Sub.use = Super.use // create asset registers, so extended classes // can have their private assets too. ASSET_TYPES.forEach(function (type) { Sub[type] = Super[type] }) // enable recursive self-lookup if (name) { Sub.options.components[name] = Sub } // keep a reference to the super options at extension time. // later at instantiation we can check if Super's options have // been updated. Sub.superOptions = Super.options Sub.extendOptions = extendOptions Sub.sealedOptions = extend({}, Sub.options) // cache constructor cachedCtors[SuperId] = Sub return Sub } Vue.extend 的作用就是构造一个 Vue 的子类，它使用一种非常经典的原型继承的方式把一个纯对象转换一个继承于 Vue 的构造器 Sub 并返回，然后对 Sub 这个对象本身扩展了一些属性，如扩展 options、添加全局 API 等；并且对配置中的 props 和 computed 做了初始化工作；最后对于这个 Sub 构造函数做了缓存，避免多次执行 Vue.extend 的时候对同一个子组件重复构造。 这样当我们去实例化 Sub 的时候，就会执行 this._init 逻辑再次走到了 Vue 实例的初始化逻辑，实例化子组件的逻辑在之后的章节会介绍。 const Sub = function VueComponent (options) { this._init(options) } 安装组件钩子函数// install component management hooks onto the placeholder node installComponentHooks(data) 我们之前提到 Vue.js 使用的 Virtual DOM 参考的是开源库 snabbdom，它的一个特点是在 VNode 的 patch 流程中对外暴露了各种时机的钩子函数，方便我们做一些额外的事情，Vue.js 也是充分利用这一点，在初始化一个 Component 类型的 VNode 的过程中实现了几个钩子函数： const componentVNodeHooks = { init (vnode: VNodeWithData, hydrating: boolean): ?boolean { if ( vnode.componentInstance &amp;&amp; !vnode.componentInstance._isDestroyed &amp;&amp; vnode.data.keepAlive ) { // kept-alive components, treat as a patch const mountedNode: any = vnode // work around flow componentVNodeHooks.prepatch(mountedNode, mountedNode) } else { const child = vnode.componentInstance = createComponentInstanceForVnode( vnode, activeInstance ) child.$mount(hydrating ? vnode.elm : undefined, hydrating) } }, prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) { const options = vnode.componentOptions const child = vnode.componentInstance = oldVnode.componentInstance updateChildComponent( child, options.propsData, // updated props options.listeners, // updated listeners vnode, // new parent vnode options.children // new children ) }, insert (vnode: MountedComponentVNode) { const { context, componentInstance } = vnode if (!componentInstance._isMounted) { componentInstance._isMounted = true callHook(componentInstance, 'mounted') } if (vnode.data.keepAlive) { if (context._isMounted) { // vue-router#1212 // During updates, a kept-alive component's child components may // change, so directly walking the tree here may call activated hooks // on incorrect children. Instead we push them into a queue which will // be processed after the whole patch process ended. queueActivatedComponent(componentInstance) } else { activateChildComponent(componentInstance, true /* direct */) } } }, destroy (vnode: MountedComponentVNode) { const { componentInstance } = vnode if (!componentInstance._isDestroyed) { if (!vnode.data.keepAlive) { componentInstance.$destroy() } else { deactivateChildComponent(componentInstance, true /* direct */) } } } } const hooksToMerge = Object.keys(componentVNodeHooks) function installComponentHooks (data: VNodeData) { const hooks = data.hook || (data.hook = {}) for (let i = 0; i &lt; hooksToMerge.length; i++) { const key = hooksToMerge[i] const existing = hooks[key] const toMerge = componentVNodeHooks[key] if (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) { hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge } } } function mergeHook (f1: any, f2: any): Function { const merged = (a, b) => { // flow complains about extra args which is why we use any f1(a, b) f2(a, b) } merged._merged = true return merged } 整个 installComponentHooks 的过程就是把 componentVNodeHooks 的钩子函数合并到 data.hook 中，在 VNode 执行 patch 的过程中执行相关的钩子函数，具体的执行我们稍后在介绍 patch 过程中会详细介绍。这里要注意的是合并策略，在合并过程中，如果某个时机的钩子已经存在 data.hook 中，那么通过执行 mergeHook 函数做合并，这个逻辑很简单，就是在最终执行的时候，依次执行这两个钩子函数即可。 实例化 VNodeconst name = Ctor.options.name || tag const vnode = new VNode( `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`, data, undefined, undefined, undefined, context, { Ctor, propsData, listeners, tag, children }, asyncFactory ) return vnode 最后一步非常简单，通过 new VNode 实例化一个 vnode 并返回。需要注意的是和普通元素节点的 vnode 不同，组件的 vnode 是没有 children 的，这点很关键，在之后的 patch 过程中我们会再提。 总结这一节我们分析了 createComponent 的实现，了解到它在渲染一个组件的时候的 3 个关键逻辑：构造子类构造函数，安装组件钩子函数和实例化 vnode。createComponent 后返回的是组件 vnode，它也一样走到 vm._update 方法，进而执行了 patch 函数，我们在上一章对 patch 函数做了简单的分析，那么下一节我们会对它做进一步的分析。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"GET请求数据获取","slug":"004.koa学习/001.基础篇/003.请求数据获取/001.GET请求数据获取","date":"2018-02-06T01:26:45.000Z","updated":"2019-09-16T01:57:01.497Z","comments":true,"path":"2018/02/06/004.koa学习/001.基础篇/003.请求数据获取/001.GET请求数据获取/","link":"","permalink":"http://www.chenya.site/2018/02/06/004.koa学习/001.基础篇/003.请求数据获取/001.GET请求数据获取/","excerpt":"","text":"GET请求数据获取使用方法在koa中，获取GET请求数据源头是koa中request对象中的query方法或querystring方法，query返回是格式化好的参数对象，querystring返回的是请求字符串，由于ctx对request的API有直接引用的方式，所以获取GET请求数据有两个途径。 1.是从上下文中直接获取 请求对象ctx.query，返回如 { a:1, b:2 } 请求字符串 ctx.querystring，返回如 a=1&amp;b=2 2.是从上下文的request对象中获取 请求对象ctx.request.query，返回如 { a:1, b:2 } 请求字符串 ctx.request.querystring，返回如 a=1&amp;b=2 举个例子demo源码 request/get.js 例子代码const Koa = require('koa') const app = new Koa() app.use( async ( ctx ) => { let url = ctx.url // 从上下文的request对象中获取 let request = ctx.request let req_query = request.query let req_querystring = request.querystring // 从上下文中直接获取 let ctx_query = ctx.query let ctx_querystring = ctx.querystring ctx.body = { url, req_query, req_querystring, ctx_query, ctx_querystring } }) app.listen(3000, () => { console.log('[demo] request get is starting at port 3000') }) 执行程序node get.js 执行后程序后，用chrome访问 http://localhost:3000/page/user?a=1&amp;b=2 会出现以下情况 注意：我是用了chrome的json格式化插件才会显示json的格式化 request-get","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"Vue源码学习 - 组件化介绍","slug":"005.vue源码学习/003.组件化/001.组件化介绍","date":"2018-02-02T08:19:58.000Z","updated":"2019-09-16T01:57:01.503Z","comments":true,"path":"2018/02/02/005.vue源码学习/003.组件化/001.组件化介绍/","link":"","permalink":"http://www.chenya.site/2018/02/02/005.vue源码学习/003.组件化/001.组件化介绍/","excerpt":"","text":"组件化Vue.js 另一个核心思想是组件化。所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。 我们在用 Vue.js 开发实际项目的时候，就是像搭积木一样，编写一堆组件拼装生成页面。在 Vue.js 的官网中，也是花了大篇幅来介绍什么是组件，如何编写组件以及组件拥有的属性和特性。 那么在这一章节，我们将从源码的角度来分析 Vue 的组件内部是如何工作的，只有了解了内部的工作原理，才能让我们使用它的时候更加得心应手。 接下来我们会用 Vue-cli 初始化的代码为例，来分析一下 Vue 组件初始化的一个过程。 import Vue from 'vue' import App from './App.vue' var app = new Vue({ el: '#app', // 这里的 h 是 createElement 方法 render: h => h(App) }) 这段代码相信很多同学都很熟悉，它和我们上一章相同的点也是通过 render 函数去渲染的，不同的这次通过 createElement 传的参数是一个组件而不是一个原生的标签，那么接下来我们就开始分析这一过程。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"koa-router中间件","slug":"004.koa学习/001.基础篇/002.路由/002.koa-router中间件","date":"2018-02-01T02:16:39.000Z","updated":"2019-09-16T01:57:01.496Z","comments":true,"path":"2018/02/01/004.koa学习/001.基础篇/002.路由/002.koa-router中间件/","link":"","permalink":"http://www.chenya.site/2018/02/01/004.koa学习/001.基础篇/002.路由/002.koa-router中间件/","excerpt":"","text":"koa-router中间件如果依靠ctx.request.url去手动处理路由，将会写很多处理代码，这时候就需要对应的路由的中间件对路由进行控制，这里介绍一个比较好用的路由中间件koa-router 安装koa-router中间件# koa2 对应的版本是 7.x npm install --save koa-router@7 快速使用koa-routerdemo源码 route-use-middleware const Koa = require('koa') const fs = require('fs') const app = new Koa() const Router = require('koa-router') let home = new Router() // 子路由1 home.get('/', async ( ctx )=>{ let html = ` &lt;ul> &lt;li>&lt;a href=\"/page/helloworld\">/page/helloworld&lt;/a>&lt;/li> &lt;li>&lt;a href=\"/page/404\">/page/404&lt;/a>&lt;/li> &lt;/ul> ` ctx.body = html }) // 子路由2 let page = new Router() page.get('/404', async ( ctx )=>{ ctx.body = '404 page!' }).get('/helloworld', async ( ctx )=>{ ctx.body = 'helloworld page!' }) // 装载所有子路由 let router = new Router() router.use('/', home.routes(), home.allowedMethods()) router.use('/page', page.routes(), page.allowedMethods()) // 加载路由中间件 app.use(router.routes()).use(router.allowedMethods()) app.listen(3000, () => { console.log('[demo] route-use-middleware is starting at port 3000') })","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"Vue源码学习 - update","slug":"005.vue源码学习/002.数据驱动/007.update","date":"2018-01-28T05:23:30.000Z","updated":"2019-09-16T01:57:01.503Z","comments":true,"path":"2018/01/28/005.vue源码学习/002.数据驱动/007.update/","link":"","permalink":"http://www.chenya.site/2018/01/28/005.vue源码学习/002.数据驱动/007.update/","excerpt":"","text":"updateVue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM，它的定义在 src/core/instance/lifecycle.js 中： Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) { const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const prevActiveInstance = activeInstance activeInstance = vm vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) { // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) } else { // updates vm.$el = vm.__patch__(prevVnode, vnode) } activeInstance = prevActiveInstance // update __vue__ reference if (prevEl) { prevEl.__vue__ = null } if (vm.$el) { vm.$el.__vue__ = vm } // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) { vm.$parent.$el = vm.$el } // updated hook is called by the scheduler to ensure that children are // updated in a parent's updated hook. } _update 的核心就是调用 vm.__patch__ 方法，这个方法实际上在不同的平台，比如 web 和 weex 上的定义是不一样的，因此在 web 平台中它的定义在 src/platforms/web/runtime/index.js 中： Vue.prototype.__patch__ = inBrowser ? patch : noop 可以看到，甚至在 web 平台上，是否是服务端渲染也会对这个方法产生影响。因为在服务端渲染中，没有真实的浏览器 DOM 环境，所以不需要把 VNode 最终转换成 DOM，因此是一个空函数，而在浏览器端渲染中，它指向了 patch 方法，它的定义在 src/platforms/web/runtime/patch.js中： import * as nodeOps from 'web/runtime/node-ops' import { createPatchFunction } from 'core/vdom/patch' import baseModules from 'core/vdom/modules/index' import platformModules from 'web/runtime/modules/index' // the directive module should be applied last, after all // built-in modules have been applied. const modules = platformModules.concat(baseModules) export const patch: Function = createPatchFunction({ nodeOps, modules }) 该方法的定义是调用 createPatchFunction 方法的返回值，这里传入了一个对象，包含 nodeOps 参数和 modules 参数。其中，nodeOps 封装了一系列 DOM 操作的方法，modules 定义了一些模块的钩子函数的实现，我们这里先不详细介绍，来看一下 createPatchFunction 的实现，它定义在 src/core/vdom/patch.js 中： const hooks = ['create', 'activate', 'update', 'remove', 'destroy'] export function createPatchFunction (backend) { let i, j const cbs = {} const { modules, nodeOps } = backend for (i = 0; i &lt; hooks.length; ++i) { cbs[hooks[i]] = [] for (j = 0; j &lt; modules.length; ++j) { if (isDef(modules[j][hooks[i]])) { cbs[hooks[i]].push(modules[j][hooks[i]]) } } } // ... return function patch (oldVnode, vnode, hydrating, removeOnly) { if (isUndef(vnode)) { if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return } let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) { // empty mount (likely as component), create new root element isInitialPatch = true createElm(vnode, insertedVnodeQueue) } else { const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) { // patch existing root node patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) } else { if (isRealElement) { // mounting to a real element // check if this is server-rendered content and if we can perform // a successful hydration. if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) { oldVnode.removeAttribute(SSR_ATTR) hydrating = true } if (isTrue(hydrating)) { if (hydrate(oldVnode, vnode, insertedVnodeQueue)) { invokeInsertHook(vnode, insertedVnodeQueue, true) return oldVnode } else if (process.env.NODE_ENV !== 'production') { warn( 'The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '&lt;p>, or missing &lt;tbody>. Bailing hydration and performing ' + 'full client-side render.' ) } } // either not server-rendered, or hydration failed. // create an empty node and replace it oldVnode = emptyNodeAt(oldVnode) } // replacing existing element const oldElm = oldVnode.elm const parentElm = nodeOps.parentNode(oldElm) // create new node createElm( vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a // leaving transition. Only happens when combining transition + // keep-alive + HOCs. (#4590) oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) // update parent placeholder node element, recursively if (isDef(vnode.parent)) { let ancestor = vnode.parent const patchable = isPatchable(vnode) while (ancestor) { for (let i = 0; i &lt; cbs.destroy.length; ++i) { cbs.destroy[i](ancestor) } ancestor.elm = vnode.elm if (patchable) { for (let i = 0; i &lt; cbs.create.length; ++i) { cbs.create[i](emptyNode, ancestor) } // #6513 // invoke insert hooks that may have been merged by create hooks. // e.g. for directives that uses the \"inserted\" hook. const insert = ancestor.data.hook.insert if (insert.merged) { // start at index 1 to avoid re-invoking component mounted hook for (let i = 1; i &lt; insert.fns.length; i++) { insert.fns[i]() } } } else { registerRef(ancestor) } ancestor = ancestor.parent } } // destroy old node if (isDef(parentElm)) { removeVnodes(parentElm, [oldVnode], 0, 0) } else if (isDef(oldVnode.tag)) { invokeDestroyHook(oldVnode) } } } invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch) return vnode.elm } } createPatchFunction 内部定义了一系列的辅助方法，最终返回了一个 patch 方法，这个方法就赋值给了 vm._update 函数里调用的 vm.__patch__。 在介绍 patch 的方法实现之前，我们可以思考一下为何 Vue.js 源码绕了这么一大圈，把相关代码分散到各个目录。因为前面介绍过，patch 是平台相关的，在 Web 和 Weex 环境，它们把虚拟 DOM 映射到 “平台 DOM” 的方法是不同的，并且对 “DOM” 包括的属性模块创建和更新也不尽相同。因此每个平台都有各自的 nodeOps 和 modules，它们的代码需要托管在 src/platforms 这个大目录下。 而不同平台的 patch 的主要逻辑部分是相同的，所以这部分公共的部分托管在 core 这个大目录下。差异化部分只需要通过参数来区别，这里用到了一个函数柯里化的技巧，通过 createPatchFunction 把差异化参数提前固化，这样不用每次调用 patch 的时候都传递 nodeOps 和 modules 了，这种编程技巧也非常值得学习。 在这里，nodeOps 表示对 “平台 DOM” 的一些操作方法，modules 表示平台的一些模块，它们会在整个 patch 过程的不同阶段执行相应的钩子函数。这些代码的具体实现会在之后的章节介绍。 回到 patch 方法本身，它接收 4个参数，oldVnode 表示旧的 VNode 节点，它也可以不存在或者是一个 DOM 对象；vnode 表示执行 _render 后返回的 VNode 的节点；hydrating 表示是否是服务端渲染；removeOnly 是给 transition-group 用的，之后会介绍。 patch 的逻辑看上去相对复杂，因为它有着非常多的分支逻辑，为了方便理解，我们并不会在这里介绍所有的逻辑，仅会针对我们之前的例子分析它的执行逻辑。之后我们对其它场景做源码分析的时候会再次回顾 patch 方法。 先来回顾我们的例子： var app = new Vue({ el: '#app', render: function (createElement) { return createElement('div', { attrs: { id: 'app' }, }, this.message) }, data: { message: 'Hello Vue!' } }) 然后我们在 vm._update 的方法里是这么调用 patch 方法的： // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) 结合我们的例子，我们的场景是首次渲染，所以在执行 patch 函数的时候，传入的 vm.$el 对应的是例子中 id 为 app 的 DOM 对象，这个也就是我们在 index.html 模板中写的 &lt;div id=&quot;app&quot;&gt;， vm.$el 的赋值是在之前 mountComponent 函数做的，vnode 对应的是调用 render 函数的返回值，hydrating 在非服务端渲染情况下为 false，removeOnly 为 false。 确定了这些入参后，我们回到 patch 函数的执行过程，看几个关键步骤。 const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) { // patch existing root node patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) } else { if (isRealElement) { // mounting to a real element // check if this is server-rendered content and if we can perform // a successful hydration. if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) { oldVnode.removeAttribute(SSR_ATTR) hydrating = true } if (isTrue(hydrating)) { if (hydrate(oldVnode, vnode, insertedVnodeQueue)) { invokeInsertHook(vnode, insertedVnodeQueue, true) return oldVnode } else if (process.env.NODE_ENV !== 'production') { warn( 'The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '&lt;p>, or missing &lt;tbody>. Bailing hydration and performing ' + 'full client-side render.' ) } } // either not server-rendered, or hydration failed. // create an empty node and replace it oldVnode = emptyNodeAt(oldVnode) } // replacing existing element const oldElm = oldVnode.elm const parentElm = nodeOps.parentNode(oldElm) // create new node createElm( vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a // leaving transition. Only happens when combining transition + // keep-alive + HOCs. (#4590) oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) } 由于我们传入的 oldVnode 实际上是一个 DOM container，所以 isRealElement 为 true，接下来又通过 emptyNodeAt 方法把 oldVnode 转换成 VNode 对象，然后再调用 createElm 方法，这个方法在这里非常重要，来看一下它的实现： function createElm ( vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index ) { if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) { // This vnode was used in a previous render! // now it's used as a new node, overwriting its elm would cause // potential patch errors down the road when it's used as an insertion // reference node. Instead, we clone the node on-demand before creating // associated DOM element for it. vnode = ownerArray[index] = cloneVNode(vnode) } vnode.isRootInsert = !nested // for transition enter check if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) { return } const data = vnode.data const children = vnode.children const tag = vnode.tag if (isDef(tag)) { if (process.env.NODE_ENV !== 'production') { if (data &amp;&amp; data.pre) { creatingElmInVPre++ } if (isUnknownElement(vnode, creatingElmInVPre)) { warn( 'Unknown custom element: &lt;' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context ) } } vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode) setScope(vnode) /* istanbul ignore if */ if (__WEEX__) { // ... } else { createChildren(vnode, children, insertedVnodeQueue) if (isDef(data)) { invokeCreateHooks(vnode, insertedVnodeQueue) } insert(parentElm, vnode.elm, refElm) } if (process.env.NODE_ENV !== 'production' &amp;&amp; data &amp;&amp; data.pre) { creatingElmInVPre-- } } else if (isTrue(vnode.isComment)) { vnode.elm = nodeOps.createComment(vnode.text) insert(parentElm, vnode.elm, refElm) } else { vnode.elm = nodeOps.createTextNode(vnode.text) insert(parentElm, vnode.elm, refElm) } } createElm 的作用是通过虚拟节点创建真实的 DOM 并插入到它的父节点中。 我们来看一下它的一些关键逻辑，createComponent 方法目的是尝试创建子组件，这个逻辑在之后组件的章节会详细介绍，在当前这个 case 下它的返回值为 false；接下来判断 vnode 是否包含 tag，如果包含，先简单对 tag 的合法性在非生产环境下做校验，看是否是一个合法标签；然后再去调用平台 DOM 的操作去创建一个占位符元素。 vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode) 接下来调用 createChildren 方法去创建子元素： createChildren(vnode, children, insertedVnodeQueue) function createChildren (vnode, children, insertedVnodeQueue) { if (Array.isArray(children)) { if (process.env.NODE_ENV !== 'production') { checkDuplicateKeys(children) } for (let i = 0; i &lt; children.length; ++i) { createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i) } } else if (isPrimitive(vnode.text)) { nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text))) } } createChildren 的逻辑很简单，实际上是遍历子虚拟节点，递归调用 createElm，这是一种常用的深度优先的遍历算法，这里要注意的一点是在遍历过程中会把 vnode.elm 作为父容器的 DOM 节点占位符传入。 接着再调用 invokeCreateHooks 方法执行所有的 create 的钩子并把 vnode push 到 insertedVnodeQueue 中。 if (isDef(data)) { invokeCreateHooks(vnode, insertedVnodeQueue) } function invokeCreateHooks (vnode, insertedVnodeQueue) { for (let i = 0; i &lt; cbs.create.length; ++i) { cbs.create[i](emptyNode, vnode) } i = vnode.data.hook // Reuse variable if (isDef(i)) { if (isDef(i.create)) i.create(emptyNode, vnode) if (isDef(i.insert)) insertedVnodeQueue.push(vnode) } } 最后调用 insert 方法把 DOM 插入到父节点中，因为是递归调用，子元素会优先调用 insert，所以整个 vnode 树节点的插入顺序是先子后父。来看一下 insert 方法，它的定义在 src/core/vdom/patch.js 上。 insert(parentElm, vnode.elm, refElm) function insert (parent, elm, ref) { if (isDef(parent)) { if (isDef(ref)) { if (ref.parentNode === parent) { nodeOps.insertBefore(parent, elm, ref) } } else { nodeOps.appendChild(parent, elm) } } } insert 逻辑很简单，调用一些 nodeOps 把子节点插入到父节点中，这些辅助方法定义在 src/platforms/web/runtime/node-ops.js 中： export function insertBefore (parentNode: Node, newNode: Node, referenceNode: Node) { parentNode.insertBefore(newNode, referenceNode) } export function appendChild (node: Node, child: Node) { node.appendChild(child) } 其实就是调用原生 DOM 的 API 进行 DOM 操作，看到这里，很多同学恍然大悟，原来 Vue 是这样动态创建的 DOM。 在 createElm 过程中，如果 vnode 节点不包含 tag，则它有可能是一个注释或者纯文本节点，可以直接插入到父元素中。在我们这个例子中，最内层就是一个文本 vnode，它的 text 值取的就是之前的 this.message 的值 Hello Vue!。 再回到 patch 方法，首次渲染我们调用了 createElm 方法，这里传入的 parentElm 是 oldVnode.elm 的父元素，在我们的例子是 id 为 #app div 的父元素，也就是 Body；实际上整个过程就是递归创建了一个完整的 DOM 树并插入到 Body 上。 最后，我们根据之前递归 createElm 生成的 vnode 插入顺序队列，执行相关的 insert 钩子函数，这部分内容我们之后会详细介绍。 总结那么至此我们从主线上把模板和数据如何渲染成最终的 DOM 的过程分析完毕了，我们可以通过下图更直观地看到从初始化 Vue 到最终渲染的整个过程。 我们这里只是分析了最简单和最基础的场景，在实际项目中，我们是把页面拆成很多组件的，Vue 另一个核心思想就是组件化。那么下一章我们就来分析 Vue 的组件化过程。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - createElement","slug":"005.vue源码学习/002.数据驱动/006.createElement","date":"2018-01-25T01:49:14.000Z","updated":"2019-09-16T01:57:01.502Z","comments":true,"path":"2018/01/25/005.vue源码学习/002.数据驱动/006.createElement/","link":"","permalink":"http://www.chenya.site/2018/01/25/005.vue源码学习/002.数据驱动/006.createElement/","excerpt":"","text":"createElementVue.js 利用 createElement 方法创建 VNode，它定义在 src/core/vdom/create-elemenet.js 中： // wrapper function for providing a more flexible interface // without getting yelled at by flow export function createElement ( context: Component, tag: any, data: any, children: any, normalizationType: any, alwaysNormalize: boolean ): VNode | Array&lt;VNode> { if (Array.isArray(data) || isPrimitive(data)) { normalizationType = children children = data data = undefined } if (isTrue(alwaysNormalize)) { normalizationType = ALWAYS_NORMALIZE } return _createElement(context, tag, data, children, normalizationType) } createElement 方法实际上是对 _createElement 方法的封装，它允许传入的参数更加灵活，在处理这些参数后，调用真正创建 VNode 的函数 _createElement： export function _createElement ( context: Component, tag?: string | Class&lt;Component> | Function | Object, data?: VNodeData, children?: any, normalizationType?: number ): VNode | Array&lt;VNode> { if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` + 'Always create fresh vnode data objects in each render!', context ) return createEmptyVNode() } // object syntax in v-bind if (isDef(data) &amp;&amp; isDef(data.is)) { tag = data.is } if (!tag) { // in case of component :is set to falsy value return createEmptyVNode() } // warn against non-primitive key if (process.env.NODE_ENV !== 'production' &amp;&amp; isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key) ) { if (!__WEEX__ || !('@binding' in data.key)) { warn( 'Avoid using non-primitive value as key, ' + 'use string/number value instead.', context ) } } // support single function children as default scoped slot if (Array.isArray(children) &amp;&amp; typeof children[0] === 'function' ) { data = data || {} data.scopedSlots = { default: children[0] } children.length = 0 } if (normalizationType === ALWAYS_NORMALIZE) { children = normalizeChildren(children) } else if (normalizationType === SIMPLE_NORMALIZE) { children = simpleNormalizeChildren(children) } let vnode, ns if (typeof tag === 'string') { let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) if (config.isReservedTag(tag)) { // platform built-in elements vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) { // component vnode = createComponent(Ctor, data, context, children, tag) } else { // unknown or unlisted namespaced elements // check at runtime because it may get assigned a namespace when its // parent normalizes children vnode = new VNode( tag, data, children, undefined, undefined, context ) } } else { // direct component options / constructor vnode = createComponent(tag, data, context, children) } if (Array.isArray(vnode)) { return vnode } else if (isDef(vnode)) { if (isDef(ns)) applyNS(vnode, ns) if (isDef(data)) registerDeepBindings(data) return vnode } else { return createEmptyVNode() } } _createElement 方法有 5 个参数，context 表示 VNode 的上下文环境，它是 Component 类型；tag 表示标签，它可以是一个字符串，也可以是一个 Component；data 表示 VNode 的数据，它是一个 VNodeData 类型，可以在 flow/vnode.js 中找到它的定义，这里先不展开说；children 表示当前 VNode 的子节点，它是任意类型的，它接下来需要被规范为标准的 VNode 数组；normalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，它主要是参考 render 函数是编译生成的还是用户手写的。 createElement 函数的流程略微有点多，我们接下来主要分析 2 个重点的流程 —— children 的规范化以及 VNode 的创建。 children 的规范化由于 Virtual DOM 实际上是一个树状结构，每一个 VNode 可能会有若干个子节点，这些子节点应该也是 VNode 的类型。_createElement 接收的第 4 个参数 children 是任意类型的，因此我们需要把它们规范成 VNode 类型。 这里根据 normalizationType 的不同，调用了 normalizeChildren(children) 和 simpleNormalizeChildren(children) 方法，它们的定义都在 src/core/vdom/helpers/normalzie-children.js 中： // The template compiler attempts to minimize the need for normalization by // statically analyzing the template at compile time. // // For plain HTML markup, normalization can be completely skipped because the // generated render function is guaranteed to return Array&lt;VNode>. There are // two cases where extra normalization is needed: // 1. When the children contains components - because a functional component // may return an Array instead of a single root. In this case, just a simple // normalization is needed - if any child is an Array, we flatten the whole // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep // because functional components already normalize their own children. export function simpleNormalizeChildren (children: any) { for (let i = 0; i &lt; children.length; i++) { if (Array.isArray(children[i])) { return Array.prototype.concat.apply([], children) } } return children } // 2. When the children contains constructs that always generated nested Arrays, // e.g. &lt;template>, &lt;slot>, v-for, or when the children is provided by user // with hand-written render functions / JSX. In such cases a full normalization // is needed to cater to all possible types of children values. export function normalizeChildren (children: any): ?Array&lt;VNode> { return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined } simpleNormalizeChildren 方法调用场景是 render 函数是编译生成的。理论上编译生成的 children 都已经是 VNode 类型的，但这里有一个例外，就是 functional component 函数式组件返回的是一个数组而不是一个根节点，所以会通过 Array.prototype.concat 方法把整个 children 数组打平，让它的深度只有一层。 normalizeChildren 方法的调用场景有 2 种，一个场景是 render 函数是用户手写的，当 children 只有一个节点的时候，Vue.js 从接口层面允许用户把 children 写成基础类型用来创建单个简单的文本节点，这种情况会调用 createTextVNode 创建一个文本节点的 VNode；另一个场景是当编译 slot、v-for 的时候会产生嵌套数组的情况，会调用 normalizeArrayChildren 方法，接下来看一下它的实现： function normalizeArrayChildren (children: any, nestedIndex?: string): Array&lt;VNode> { const res = [] let i, c, lastIndex, last for (i = 0; i &lt; children.length; i++) { c = children[i] if (isUndef(c) || typeof c === 'boolean') continue lastIndex = res.length - 1 last = res[lastIndex] // nested if (Array.isArray(c)) { if (c.length > 0) { c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`) // merge adjacent text nodes if (isTextNode(c[0]) &amp;&amp; isTextNode(last)) { res[lastIndex] = createTextVNode(last.text + (c[0]: any).text) c.shift() } res.push.apply(res, c) } } else if (isPrimitive(c)) { if (isTextNode(last)) { // merge adjacent text nodes // this is necessary for SSR hydration because text nodes are // essentially merged when rendered to HTML strings res[lastIndex] = createTextVNode(last.text + c) } else if (c !== '') { // convert primitive to vnode res.push(createTextVNode(c)) } } else { if (isTextNode(c) &amp;&amp; isTextNode(last)) { // merge adjacent text nodes res[lastIndex] = createTextVNode(last.text + c.text) } else { // default key for nested array children (likely generated by v-for) if (isTrue(children._isVList) &amp;&amp; isDef(c.tag) &amp;&amp; isUndef(c.key) &amp;&amp; isDef(nestedIndex)) { c.key = `__vlist${nestedIndex}_${i}__` } res.push(c) } } } return res } normalizeArrayChildren 接收 2 个参数，children 表示要规范的子节点，nestedIndex 表示嵌套的索引，因为单个 child 可能是一个数组类型。 normalizeArrayChildren 主要的逻辑就是遍历 children，获得单个节点 c，然后对 c 的类型判断，如果是一个数组类型，则递归调用 normalizeArrayChildren; 如果是基础类型，则通过 createTextVNode 方法转换成 VNode 类型；否则就已经是 VNode 类型了，如果 children 是一个列表并且列表还存在嵌套的情况，则根据 nestedIndex 去更新它的 key。这里需要注意一点，在遍历的过程中，对这 3 种情况都做了如下处理：如果存在两个连续的 text 节点，会把它们合并成一个 text 节点。 经过对 children 的规范化，children 变成了一个类型为 VNode 的 Array。 VNode 的创建回到 createElement 函数，规范化 children 后，接下来会去创建一个 VNode 的实例： let vnode, ns if (typeof tag === 'string') { let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) if (config.isReservedTag(tag)) { // platform built-in elements vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) { // component vnode = createComponent(Ctor, data, context, children, tag) } else { // unknown or unlisted namespaced elements // check at runtime because it may get assigned a namespace when its // parent normalizes children vnode = new VNode( tag, data, children, undefined, undefined, context ) } } else { // direct component options / constructor vnode = createComponent(tag, data, context, children) } 这里先对 tag 做判断，如果是 string 类型，则接着判断如果是内置的一些节点，则直接创建一个普通 VNode，如果是为已注册的组件名，则通过 createComponent 创建一个组件类型的 VNode，否则创建一个未知的标签的 VNode。 如果是 tag 一个 Component 类型，则直接调用 createComponent 创建一个组件类型的 VNode 节点。对于 createComponent 创建组件类型的 VNode 的过程，我们之后会去介绍，本质上它还是返回了一个 VNode。 总结那么至此，我们大致了解了 createElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个 VNode，这样就形成了一个 VNode Tree，它很好的描述了我们的 DOM Tree。 回到 mountComponent 函数的过程，我们已经知道 vm._render 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的，接下来分析一下这个过程。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - Virtual DOM","slug":"005.vue源码学习/002.数据驱动/005.Virtual DOM","date":"2018-01-24T00:22:10.000Z","updated":"2019-09-16T01:57:01.502Z","comments":true,"path":"2018/01/24/005.vue源码学习/002.数据驱动/005.Virtual DOM/","link":"","permalink":"http://www.chenya.site/2018/01/24/005.vue源码学习/002.数据驱动/005.Virtual DOM/","excerpt":"","text":"Virtual DOMVirtual DOM 这个概念相信大部分人都不会陌生，它产生的前提是浏览器中的 DOM 是很“昂贵”的，为了更直观的感受，我们可以简单的把一个简单的 div 元素的属性都打印出来，如图所示： Virtual-DOM 可以看到，真正的 DOM 元素是非常庞大的，因为浏览器的标准就把 DOM 设计的非常复杂。当我们频繁的去做 DOM 更新，会产生一定的性能问题。 而 Virtual DOM 就是用一个原生的 JS 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多。在 Vue.js 中，Virtual DOM 是用 VNode 这么一个 Class 去描述，它是定义在 src/core/vdom/vnode.js 中的。 export default class VNode { tag: string | void; data: VNodeData | void; children: ?Array&lt;VNode>; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component's scope key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node // strictly internal raw: boolean; // contains raw HTML? (server only) isStatic: boolean; // hoisted static node isRootInsert: boolean; // necessary for enter transition check isComment: boolean; // empty comment placeholder? isCloned: boolean; // is a cloned node? isOnce: boolean; // is a v-once node? asyncFactory: Function | void; // async component factory function asyncMeta: Object | void; isAsyncPlaceholder: boolean; ssrContext: Object | void; fnContext: Component | void; // real context vm for functional nodes fnOptions: ?ComponentOptions; // for SSR caching fnScopeId: ?string; // functional scope id support constructor ( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode>, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions, asyncFactory?: Function ) { this.tag = tag this.data = data this.children = children this.text = text this.elm = elm this.ns = undefined this.context = context this.fnContext = undefined this.fnOptions = undefined this.fnScopeId = undefined this.key = data &amp;&amp; data.key this.componentOptions = componentOptions this.componentInstance = undefined this.parent = undefined this.raw = false this.isStatic = false this.isRootInsert = true this.isComment = false this.isCloned = false this.isOnce = false this.asyncFactory = asyncFactory this.asyncMeta = undefined this.isAsyncPlaceholder = false } // DEPRECATED: alias for componentInstance for backwards compat. /* istanbul ignore next */ get child (): Component | void { return this.componentInstance } } 可以看到 Vue.js 中的 Virtual DOM 的定义还是略微复杂一些的，因为它这里包含了很多 Vue.js 的特性。这里千万不要被这些茫茫多的属性吓到，实际上 Vue.js 中 Virtual DOM 是借鉴了一个开源库 snabbdom 的实现，然后加入了一些 Vue.js 特色的东西。我建议大家如果想深入了解 Vue.js 的 Virtual DOM 前不妨先阅读这个库的源码，因为它更加简单和纯粹。 总结其实 VNode 是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。由于 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是非常轻量和简单的。 Virtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。那么在 Vue.js 中，VNode 的 create 是通过之前提到的 createElement 方法创建的，我们接下来分析这部分的实现。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - render","slug":"005.vue源码学习/002.数据驱动/004.render","date":"2018-01-23T04:33:15.000Z","updated":"2019-09-16T01:57:01.502Z","comments":true,"path":"2018/01/23/005.vue源码学习/002.数据驱动/004.render/","link":"","permalink":"http://www.chenya.site/2018/01/23/005.vue源码学习/002.数据驱动/004.render/","excerpt":"","text":"renderVue 的 _render 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。它的定义在 src/core/instance/render.js 文件中： Vue.prototype._render = function (): VNode { const vm: Component = this const { render, _parentVnode } = vm.$options // reset _rendered flag on slots for duplicate slot check if (process.env.NODE_ENV !== 'production') { for (const key in vm.$slots) { // $flow-disable-line vm.$slots[key]._rendered = false } } if (_parentVnode) { vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject } // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try { vnode = render.call(vm._renderProxy, vm.$createElement) } catch (e) { handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') { if (vm.$options.renderError) { try { vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) } catch (e) { handleError(e, vm, `renderError`) vnode = vm._vnode } } else { vnode = vm._vnode } } else { vnode = vm._vnode } } // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) { if (process.env.NODE_ENV !== 'production' &amp;&amp; Array.isArray(vnode)) { warn( 'Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm ) } vnode = createEmptyVNode() } // set parent vnode.parent = _parentVnode return vnode } 这段代码最关键的是 render 方法的调用，我们在平时的开发工作中手写 render 方法的场景比较少，而写的比较多的是 template 模板，在之前的 mounted 方法的实现中，会把 template 编译成 render 方法，但这个编译过程是非常复杂的，我们不打算在这里展开讲，之后会专门花一个章节来分析 Vue 的编译过程。 在 Vue 的官方文档中介绍了 render 函数的第一个参数是 createElement，那么结合之前的例子： &lt;div id=\"app\"> {{ message }} &lt;/div> 相当于我们编写如下 render 函数： render: function (createElement) { return createElement('div', { attrs: { id: 'app' }, }, this.message) } 再回到 _render 函数中的 render 方法的调用： vnode = render.call(vm._renderProxy, vm.$createElement) 可以看到，render 函数中的 createElement 方法就是 vm.$createElement 方法： export function initRender (vm: Component) { // ... // bind the createElement fn to this instance // so that we get proper render context inside it. // args order: tag, data, children, normalizationType, alwaysNormalize // internal version is used by render functions compiled from templates vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false) // normalization is always applied for the public version, used in // user-written render functions. vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true) } 实际上，vm.$createElement 方法定义是在执行 initRender 方法的时候，可以看到除了 vm.$createElement 方法，还有一个 vm._c 方法，它是被模板编译成的 render 函数使用，而 vm.$createElement 是用户手写 render 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 createElement 方法。 总结vm._render 最终是通过执行 createElement 方法并返回的是 vnode，它是一个虚拟 Node。Vue 2.0 相比 Vue 1.0 最大的升级就是利用了 Virtual DOM。因此在分析 createElement 的实现前，我们先了解一下 Virtual DOM 的概念。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - Vue 实例挂载的实现.","slug":"005.vue源码学习/002.数据驱动/003.Vue 实例挂载的实现","date":"2018-01-21T15:01:23.000Z","updated":"2019-09-16T01:57:01.502Z","comments":true,"path":"2018/01/21/005.vue源码学习/002.数据驱动/003.Vue 实例挂载的实现/","link":"","permalink":"http://www.chenya.site/2018/01/21/005.vue源码学习/002.数据驱动/003.Vue 实例挂载的实现/","excerpt":"","text":"Vue 实例挂载的实现Vue 中我们是通过 $mount 实例方法去挂载 vm 的，$mount 方法在多个文件中都有定义，如 src/platform/web/entry-runtime-with-compiler.js、src/platform/web/runtime/index.js、src/platform/weex/runtime/index.js。因为 $mount 这个方法的实现是和平台、构建方式都相关的。接下来我们重点分析带 compiler 版本的 $mount 实现，因为抛开 webpack 的 vue-loader，我们在纯前端浏览器环境分析 Vue 的工作原理，有助于我们对原理理解的深入。 compiler 版本的 $mount 实现非常有意思，先来看一下 src/platform/web/entry-runtime-with-compiler.js 文件中定义： const mount = Vue.prototype.$mount Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean ): Component { el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Do not mount Vue to &lt;html> or &lt;body> - mount to normal elements instead.` ) return this } const options = this.$options // resolve template/el and convert to render function if (!options.render) { let template = options.template if (template) { if (typeof template === 'string') { if (template.charAt(0) === '#') { template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) { warn( `Template element not found or is empty: ${options.template}`, this ) } } } else if (template.nodeType) { template = template.innerHTML } else { if (process.env.NODE_ENV !== 'production') { warn('invalid template option:' + template, this) } return this } } else if (el) { template = getOuterHTML(el) } if (template) { /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { mark('compile') } const { render, staticRenderFns } = compileToFunctions(template, { shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments }, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { mark('compile end') measure(`vue ${this._name} compile`, 'compile', 'compile end') } } } return mount.call(this, el, hydrating) } 这段代码首先缓存了原型上的 $mount 方法，再重新定义该方法，我们先来分析这段代码。首先，它对 el 做了限制，Vue 不能挂载在 body、html 这样的根节点上。接下来的是很关键的逻辑 —— 如果没有定义 render 方法，则会把 el 或者 template 字符串转换成 render 方法。这里我们要牢记，在 Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 render 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 el 或者 template 属性，最终都会转换成 render 方法，那么这个过程是 Vue 的一个“在线编译”的过程，它是调用 compileToFunctions 方法实现的，编译过程我们之后会介绍。最后，调用原先原型上的 $mount 方法挂载。 原先原型上的 $mount 方法在 src/platform/web/runtime/index.js 中定义，之所以这么设计完全是为了复用，因为它是可以被 runtime only 版本的 Vue 直接使用的。 // public mount method Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean ): Component { el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating) } $mount 方法支持传入 2 个参数，第一个是 el，它表示挂载的元素，可以是字符串，也可以是 DOM 对象，如果是字符串在浏览器环境下会调用 query 方法转换成 DOM 对象的。第二个参数是和服务端渲染相关，在浏览器环境下我们不需要传第二个参数。 $mount 方法实际上会去调用 mountComponent 方法，这个方法定义在 src/core/instance/lifecycle.js 文件中： export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean ): Component { vm.$el = el if (!vm.$options.render) { vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== 'production') { /* istanbul ignore if */ if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== '#') || vm.$options.el || el) { warn( 'You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm ) } else { warn( 'Failed to mount component: template or render function not defined.', vm ) } } } callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { updateComponent = () => { const name = vm._name const id = vm._uid const startTag = `vue-perf-start:${id}` const endTag = `vue-perf-end:${id}` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue ${name} render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue ${name} patch`, startTag, endTag) } } else { updateComponent = () => { vm._update(vm._render(), hydrating) } } // we set this to vm._watcher inside the watcher's constructor // since the watcher's initial patch may call $forceUpdate (e.g. inside child // component's mounted hook), which relies on vm._watcher being already defined new Watcher(vm, updateComponent, noop, { before () { if (vm._isMounted) { callHook(vm, 'beforeUpdate') } } }, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) { vm._isMounted = true callHook(vm, 'mounted') } return vm } 从上面的代码可以看到，mountComponent 核心就是先实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法先生成虚拟 Node，最终调用 vm._update 更新 DOM。 Watcher 在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 vm 实例中的监测的数据发生变化的时候执行回调函数，这块儿我们会在之后的章节中介绍。 函数最后判断为根节点的时候设置 vm._isMounted 为 true， 表示这个实例已经挂载了，同时执行 mounted 钩子函数。 这里注意 vm.$vnode 表示 Vue 实例的父虚拟 Node，所以它为 Null 则表示当前是根 Vue 的实例。 总结mountComponent 方法的逻辑也是非常清晰的，它会完成整个渲染工作，接下来我们要重点分析其中的细节，也就是最核心的 2 个方法：vm._render 和 vm._update。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"koa2 原生路由实现","slug":"004.koa学习/001.基础篇/002.路由/001.koa2 原生路由实现","date":"2018-01-21T07:34:12.000Z","updated":"2019-09-16T01:57:01.496Z","comments":true,"path":"2018/01/21/004.koa学习/001.基础篇/002.路由/001.koa2 原生路由实现/","link":"","permalink":"http://www.chenya.site/2018/01/21/004.koa学习/001.基础篇/002.路由/001.koa2 原生路由实现/","excerpt":"","text":"koa2 原生路由实现简单例子const Koa = require('koa') const app = new Koa() app.use( async ( ctx ) => { let url = ctx.request.url ctx.body = url }) app.listen(3000) 访问 http://localhost:3000/hello/world 页面会输出 /hello/world，也就是说上下文的请求request对象中url之就是当前访问的路径名称，可以根据ctx.request.url 通过一定的判断或者正则匹配就可以定制出所需要的路由。 定制化的路由demo源码 route-simple 源码文件目录. ├── index.js ├── package.json └── view ├── 404.html ├── index.html └── todo.html demo源码const Koa = require('koa') const fs = require('fs') const app = new Koa() /** * 用Promise封装异步读取文件方法 * @param {string} page html文件名称 * @return {promise} */ function render( page ) { return new Promise(( resolve, reject ) => { let viewUrl = `./view/${page}` fs.readFile(viewUrl, \"binary\", ( err, data ) => { if ( err ) { reject( err ) } else { resolve( data ) } }) }) } /** * 根据URL获取HTML内容 * @param {string} url koa2上下文的url，ctx.url * @return {string} 获取HTML文件内容 */ async function route( url ) { let view = '404.html' switch ( url ) { case '/': view = 'index.html' break case '/index': view = 'index.html' break case '/todo': view = 'todo.html' break case '/404': view = '404.html' break default: break } let html = await render( view ) return html } app.use( async ( ctx ) => { let url = ctx.request.url let html = await route( url ) ctx.body = html }) app.listen(3000) console.log('[demo] route-simple is starting at port 3000') 运行demo执行运行脚本node -harmony index.js 运行效果如下访问http://localhost:3000/index route-result-01","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"Vue源码学习 - new Vue 发生了什么","slug":"005.vue源码学习/002.数据驱动/002.new Vue 发生了什么","date":"2018-01-20T05:23:10.000Z","updated":"2019-09-16T01:57:01.501Z","comments":true,"path":"2018/01/20/005.vue源码学习/002.数据驱动/002.new Vue 发生了什么/","link":"","permalink":"http://www.chenya.site/2018/01/20/005.vue源码学习/002.数据驱动/002.new Vue 发生了什么/","excerpt":"","text":"new Vue 发生了什么 从入口代码开始分析，我们先来分析 new Vue 背后发生了哪些事情。我们都知道，new 关键字在 Javascript 语言中代表实例化是一个对象，而 Vue 实际上是一个类，类在 Javascript 中是用 Function 来实现的，来看一下源码，在src/core/instance/index.js 中。 function Vue (options) { if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) { warn('Vue is a constructor and should be called with the `new` keyword') } this._init(options) } 可以看到 Vue 只能通过 new 关键字初始化，然后会调用 this._init 方法， 该方法在 src/core/instance/init.js 中定义。 Vue.prototype._init = function (options?: Object) { const vm: Component = this // a uid vm._uid = uid++ let startTag, endTag /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { startTag = `vue-perf-start:${vm._uid}` endTag = `vue-perf-end:${vm._uid}` mark(startTag) } // a flag to avoid this being observed vm._isVue = true // merge options if (options &amp;&amp; options._isComponent) { // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) } else { vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) } /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') { initProxy(vm) } else { vm._renderProxy = vm } // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue ${vm._name} init`, startTag, endTag) } if (vm.$options.el) { vm.$mount(vm.$options.el) } } Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。 总结Vue 的初始化逻辑写的非常清楚，把不同的功能逻辑拆成一些单独的函数执行，让主线逻辑一目了然，这样的编程思想是非常值得借鉴和学习的。 由于我们这一章的目标是弄清楚模板和数据如何渲染成最终的 DOM，所以各种初始化逻辑我们先不看。在初始化的最后，检测到如果有 el 属性，则调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM，那么接下来我们来分析 Vue 的挂载过程。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - 数据驱动介绍","slug":"005.vue源码学习/002.数据驱动/001.数据驱动介绍","date":"2018-01-19T15:13:10.000Z","updated":"2019-09-16T01:57:01.501Z","comments":true,"path":"2018/01/19/005.vue源码学习/002.数据驱动/001.数据驱动介绍/","link":"","permalink":"http://www.chenya.site/2018/01/19/005.vue源码学习/002.数据驱动/001.数据驱动介绍/","excerpt":"","text":"数据驱动Vue.js 一个核心思想是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。它相比我们传统的前端开发，如使用 jQuery 等前端库直接修改 DOM，大大简化了代码量。特别是当交互复杂的时候，只关心数据的修改会让代码的逻辑变的非常清晰，因为 DOM 变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触 DOM，这样的代码非常利于维护。 在 Vue.js 中我们可以采用简洁的模板语法来声明式的将数据渲染为 DOM： &lt;div id=\"app\"> {{ message }} &lt;/div> var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' } }) 最终它会在页面上渲染出 Hello Vue。接下来，我们会从源码角度来分析 Vue 是如何实现的，分析过程会以主线代码为主，重要的分支逻辑会放在之后单独分析。数据驱动还有一部分是数据更新驱动视图变化，这一块内容我们也会在之后的章节分析，这一章我们的目标是弄清楚模板和数据如何渲染成最终的 DOM。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"异步上传图片实现","slug":"004.koa学习/001.基础篇/007.文件上传/003.异步上传图片实现","date":"2018-01-18T09:26:31.000Z","updated":"2019-09-16T01:57:01.500Z","comments":true,"path":"2018/01/18/004.koa学习/001.基础篇/007.文件上传/003.异步上传图片实现/","link":"","permalink":"http://www.chenya.site/2018/01/18/004.koa学习/001.基础篇/007.文件上传/003.异步上传图片实现/","excerpt":"","text":"异步上传图片实现快速上手demo 地址 upload-async 源码理解demo源码目录. ├── index.js # 后端启动文件 ├── node_modules ├── package.json ├── static # 静态资源目录 │ ├── image # 异步上传图片存储目录 │ └── js │ └── index.js # 上传图片前端js操作 ├── util │ └── upload.js # 后端处理图片流操作 └── view └── index.ejs # ejs后端渲染模板 后端代码入口文件 demo/upload-async/index.js const Koa = require('koa') const views = require('koa-views') const path = require('path') const convert = require('koa-convert') const static = require('koa-static') const { uploadFile } = require('./util/upload') const app = new Koa() /** * 使用第三方中间件 start */ app.use(views(path.join(__dirname, './view'), { extension: 'ejs' })) // 静态资源目录对于相对入口文件index.js的路径 const staticPath = './static' // 由于koa-static目前不支持koa2 // 所以只能用koa-convert封装一下 app.use(convert(static( path.join( __dirname, staticPath) ))) /** * 使用第三方中间件 end */ app.use( async ( ctx ) => { if ( ctx.method === 'GET' ) { let title = 'upload pic async' await ctx.render('index', { title, }) } else if ( ctx.url === '/api/picture/upload.json' &amp;&amp; ctx.method === 'POST' ) { // 上传文件请求处理 let result = { success: false } let serverFilePath = path.join( __dirname, 'static/image' ) // 上传文件事件 result = await uploadFile( ctx, { fileType: 'album', path: serverFilePath }) ctx.body = result } else { // 其他请求显示404 ctx.body = '&lt;h1>404！！！ o(╯□╰)o&lt;/h1>' } }) app.listen(3000, () => { console.log('[demo] upload-pic-async is starting at port 3000') }) 后端上传图片流写操作入口文件 demo/upload-async/util/upload.js const inspect = require('util').inspect const path = require('path') const os = require('os') const fs = require('fs') const Busboy = require('busboy') /** * 同步创建文件目录 * @param {string} dirname 目录绝对地址 * @return {boolean} 创建目录结果 */ function mkdirsSync( dirname ) { if (fs.existsSync( dirname )) { return true } else { if (mkdirsSync( path.dirname(dirname)) ) { fs.mkdirSync( dirname ) return true } } } /** * 获取上传文件的后缀名 * @param {string} fileName 获取上传文件的后缀名 * @return {string} 文件后缀名 */ function getSuffixName( fileName ) { let nameList = fileName.split('.') return nameList[nameList.length - 1] } /** * 上传文件 * @param {object} ctx koa上下文 * @param {object} options 文件上传参数 fileType文件类型， path文件存放路径 * @return {promise} */ function uploadFile( ctx, options) { let req = ctx.req let res = ctx.res let busboy = new Busboy({headers: req.headers}) // 获取类型 let fileType = options.fileType || 'common' let filePath = path.join( options.path, fileType) let mkdirResult = mkdirsSync( filePath ) return new Promise((resolve, reject) => { console.log('文件上传中...') let result = { success: false, message: '', data: null } // 解析请求文件事件 busboy.on('file', function(fieldname, file, filename, encoding, mimetype) { let fileName = Math.random().toString(16).substr(2) + '.' + getSuffixName(filename) let _uploadFilePath = path.join( filePath, fileName ) let saveTo = path.join(_uploadFilePath) // 文件保存到制定路径 file.pipe(fs.createWriteStream(saveTo)) // 文件写入事件结束 file.on('end', function() { result.success = true result.message = '文件上传成功' result.data = { pictureUrl: `//${ctx.host}/image/${fileType}/${fileName}` } console.log('文件上传成功！') resolve(result) }) }) // 解析结束事件 busboy.on('finish', function( ) { console.log('文件上结束') resolve(result) }) // 解析错误事件 busboy.on('error', function(err) { console.log('文件上出错') reject(result) }) req.pipe(busboy) }) } module.exports = { uploadFile } 前端代码&lt;button class=\"btn\" id=\"J_UploadPictureBtn\">上传图片&lt;/button> &lt;hr/> &lt;p>上传进度&lt;span id=\"J_UploadProgress\">0&lt;/span>%&lt;/p> &lt;p>上传结果图片&lt;/p> &lt;div id=\"J_PicturePreview\" class=\"preview-picture\"> &lt;/div> &lt;script src=\"/js/index.js\">&lt;/script> 上传操作代码 (function(){ let btn = document.getElementById('J_UploadPictureBtn') let progressElem = document.getElementById('J_UploadProgress') let previewElem = document.getElementById('J_PicturePreview') btn.addEventListener('click', function(){ uploadAction({ success: function( result ) { console.log( result ) if ( result &amp;&amp; result.success &amp;&amp; result.data &amp;&amp; result.data.pictureUrl ) { previewElem.innerHTML = '&lt;img src=\"'+ result.data.pictureUrl +'\" style=\"max-width: 100%\">' } }, progress: function( data ) { if ( data &amp;&amp; data * 1 > 0 ) { progressElem.innerText = data } } }) }) /** * 类型判断 * @type {Object} */ let UtilType = { isPrototype: function( data ) { return Object.prototype.toString.call(data).toLowerCase(); }, isJSON: function( data ) { return this.isPrototype( data ) === '[object object]'; }, isFunction: function( data ) { return this.isPrototype( data ) === '[object function]'; } } /** * form表单上传请求事件 * @param {object} options 请求参数 */ function requestEvent( options ) { try { let formData = options.formData let xhr = new XMLHttpRequest() xhr.onreadystatechange = function() { if ( xhr.readyState === 4 &amp;&amp; xhr.status === 200 ) { options.success(JSON.parse(xhr.responseText)) } } xhr.upload.onprogress = function(evt) { let loaded = evt.loaded let tot = evt.total let per = Math.floor(100 * loaded / tot) options.progress(per) } xhr.open('post', '/api/picture/upload.json') xhr.send(formData) } catch ( err ) { options.fail(err) } } /** * 上传事件 * @param {object} options 上传参数 */ function uploadEvent ( options ){ let file let formData = new FormData() let input = document.createElement('input') input.setAttribute('type', 'file') input.setAttribute('name', 'files') input.click() input.onchange = function () { file = input.files[0] formData.append('files', file) requestEvent({ formData, success: options.success, fail: options.fail, progress: options.progress }) } } /** * 上传操作 * @param {object} options 上传参数 */ function uploadAction( options ) { if ( !UtilType.isJSON( options ) ) { console.log( 'upload options is null' ) return } let _options = {} _options.success = UtilType.isFunction(options.success) ? options.success : function() {} _options.fail = UtilType.isFunction(options.fail) ? options.fail : function() {} _options.progress = UtilType.isFunction(options.progress) ? options.progress : function() {} uploadEvent(_options) } })() 运行效果 upload-async-result","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"koa中间件开发和使用","slug":"004.koa学习/001.基础篇/001.koa2开始/004.koa中间件开发和使用","date":"2018-01-17T11:47:35.000Z","updated":"2019-09-16T01:57:01.496Z","comments":true,"path":"2018/01/17/004.koa学习/001.基础篇/001.koa2开始/004.koa中间件开发和使用/","link":"","permalink":"http://www.chenya.site/2018/01/17/004.koa学习/001.基础篇/001.koa2开始/004.koa中间件开发和使用/","excerpt":"","text":"koa中间件开发和使用 koa v1和v2中使用到的中间件的开发和使用 generator 中间件开发在koa v1和v2中使用 async await 中间件开发和只能在koa v2中使用 generator中间件开发 generator中间件返回的应该是function * () 函数 /* ./middleware/logger-generator.js */ function log( ctx ) { console.log( ctx.method, ctx.header.host + ctx.url ) } module.exports = function () { return function * ( next ) { // 执行中间件的操作 log( this ) if ( next ) { yield next } } } generator中间件在koa@1中的使用 generator 中间件在koa v1中可以直接use使用 const koa = require('koa') // koa v1 const loggerGenerator = require('./middleware/logger-generator') const app = koa() app.use(loggerGenerator()) app.use(function *( ) { this.body = 'hello world!' }) app.listen(3000) console.log('the server is starting at port 3000') generator中间件在koa@2中的使用 generator 中间件在koa v2中需要用koa-convert封装一下才能使用 const Koa = require('koa') // koa v2 const convert = require('koa-convert') const loggerGenerator = require('./middleware/logger-generator') const app = new Koa() app.use(convert(loggerGenerator())) app.use(( ctx ) => { ctx.body = 'hello world!' }) app.listen(3000) console.log('the server is starting at port 3000') async中间件开发async 中间件开发/* ./middleware/logger-async.js */ function log( ctx ) { console.log( ctx.method, ctx.header.host + ctx.url ) } module.exports = function () { return async function ( ctx, next ) { log(ctx); await next() } } async 中间件在koa@2中使用 async 中间件只能在 koa v2中使用 const Koa = require('koa') // koa v2 const loggerAsync = require('./middleware/logger-async') const app = new Koa() app.use(loggerAsync()) app.use(( ctx ) => { ctx.body = 'hello world!' }) app.listen(3000) console.log('the server is starting at port 3000')","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"Vue源码学习 - 从入口开始","slug":"005.vue源码学习/001.源码目录/005.从入口开始","date":"2018-01-15T05:05:31.000Z","updated":"2019-09-16T01:57:01.501Z","comments":true,"path":"2018/01/15/005.vue源码学习/001.源码目录/005.从入口开始/","link":"","permalink":"http://www.chenya.site/2018/01/15/005.vue源码学习/001.源码目录/005.从入口开始/","excerpt":"","text":"从入口开始我们之前提到过 Vue.js 构建过程，在 web 应用下，我们来分析 Runtime + Compiler 构建出来的 Vue.js，它的入口是 src/platforms/web/entry-runtime-with-compiler.js： /* @flow */ import config from 'core/config' import { warn, cached } from 'core/util/index' import { mark, measure } from 'core/util/perf' import Vue from './runtime/index' import { query } from './util/index' import { compileToFunctions } from './compiler/index' import { shouldDecodeNewlines, shouldDecodeNewlinesForHref } from './util/compat' const idToTemplate = cached(id => { const el = query(id) return el &amp;&amp; el.innerHTML }) const mount = Vue.prototype.$mount Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean ): Component { el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) { process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Do not mount Vue to &lt;html> or &lt;body> - mount to normal elements instead.` ) return this } const options = this.$options // resolve template/el and convert to render function if (!options.render) { let template = options.template if (template) { if (typeof template === 'string') { if (template.charAt(0) === '#') { template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) { warn( `Template element not found or is empty: ${options.template}`, this ) } } } else if (template.nodeType) { template = template.innerHTML } else { if (process.env.NODE_ENV !== 'production') { warn('invalid template option:' + template, this) } return this } } else if (el) { template = getOuterHTML(el) } if (template) { /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { mark('compile') } const { render, staticRenderFns } = compileToFunctions(template, { shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments }, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { mark('compile end') measure(`vue ${this._name} compile`, 'compile', 'compile end') } } } return mount.call(this, el, hydrating) } /** * Get outerHTML of elements, taking care * of SVG elements in IE as well. */ function getOuterHTML (el: Element): string { if (el.outerHTML) { return el.outerHTML } else { const container = document.createElement('div') container.appendChild(el.cloneNode(true)) return container.innerHTML } } Vue.compile = compileToFunctions export default Vue 那么，当我们的代码执行 import Vue from &#39;vue&#39; 的时候，就是从这个入口执行代码来初始化 Vue，那么 Vue 到底是什么，它是怎么初始化的，我们来一探究竟。 Vue 的入口在这个入口 JS 的上方我们可以找到 Vue 的来源：import Vue from &#39;./runtime/index&#39;，我们先来看一下这块儿的实现，它定义在 src/platforms/web/runtime/index.js 中： import Vue from 'core/index' import config from 'core/config' import { extend, noop } from 'shared/util' import { mountComponent } from 'core/instance/lifecycle' import { devtools, inBrowser, isChrome } from 'core/util/index' import { query, mustUseProp, isReservedTag, isReservedAttr, getTagNamespace, isUnknownElement } from 'web/util/index' import { patch } from './patch' import platformDirectives from './directives/index' import platformComponents from './components/index' // install platform specific utils Vue.config.mustUseProp = mustUseProp Vue.config.isReservedTag = isReservedTag Vue.config.isReservedAttr = isReservedAttr Vue.config.getTagNamespace = getTagNamespace Vue.config.isUnknownElement = isUnknownElement // install platform runtime directives &amp; components extend(Vue.options.directives, platformDirectives) extend(Vue.options.components, platformComponents) // install platform patch function Vue.prototype.__patch__ = inBrowser ? patch : noop // public mount method Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean ): Component { el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating) } // ... export default Vue 这里关键的代码是 import Vue from &#39;core/index&#39;，之后的逻辑都是对 Vue 这个对象做一些扩展，可以先不用看，我们来看一下真正初始化 Vue 的地方，在 src/core/index.js 中： import Vue from './instance/index' import { initGlobalAPI } from './global-api/index' import { isServerRendering } from 'core/util/env' import { FunctionalRenderContext } from 'core/vdom/create-functional-component' initGlobalAPI(Vue) Object.defineProperty(Vue.prototype, '$isServer', { get: isServerRendering }) Object.defineProperty(Vue.prototype, '$ssrContext', { get () { /* istanbul ignore next */ return this.$vnode &amp;&amp; this.$vnode.ssrContext } }) // expose FunctionalRenderContext for ssr runtime helper installation Object.defineProperty(Vue, 'FunctionalRenderContext', { value: FunctionalRenderContext }) Vue.version = '__VERSION__' export default Vue 这里有 2 处关键的代码，import Vue from &#39;./instance/index&#39; 和 initGlobalAPI(Vue)，初始化全局 Vue API（我们稍后介绍），我们先来看第一部分，在 src/core/instance/index.js 中： Vue 的定义import { initMixin } from './init' import { stateMixin } from './state' import { renderMixin } from './render' import { eventsMixin } from './events' import { lifecycleMixin } from './lifecycle' import { warn } from '../util/index' function Vue (options) { if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) { warn('Vue is a constructor and should be called with the `new` keyword') } this._init(options) } initMixin(Vue) stateMixin(Vue) eventsMixin(Vue) lifecycleMixin(Vue) renderMixin(Vue) export default Vue 在这里，我们终于看到了 Vue 的庐山真面目，它实际上就是一个用 Function 实现的类，我们只能通过 new Vue 去实例化它。 我们看到这不禁想问，为何 Vue 不用 ES6 的 Class 去实现呢？我们往后看这里有很多 xxxMixin 的函数调用，并把 Vue 当参数传入，它们的功能都是给 Vue 的 prototype 上扩展一些方法（这里具体的细节会在之后的文章介绍，这里不展开），Vue 按功能把这些扩展分散到多个模块中去实现，而不是在一个模块里实现所有，这种方式是用 Class 难以实现的。这么做的好处是非常方便代码的维护和管理，这种编程技巧也非常值得我们去学习。 initGlobalAPIVue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 Vue 这个对象本身扩展全局的静态方法，它的定义在 src/core/global-api/index.js 中： export function initGlobalAPI (Vue: GlobalAPI) { // config const configDef = {} configDef.get = () => config if (process.env.NODE_ENV !== 'production') { configDef.set = () => { warn( 'Do not replace the Vue.config object, set individual fields instead.' ) } } Object.defineProperty(Vue, 'config', configDef) // exposed util methods. // NOTE: these are not considered part of the public API - avoid relying on // them unless you are aware of the risk. Vue.util = { warn, extend, mergeOptions, defineReactive } Vue.set = set Vue.delete = del Vue.nextTick = nextTick Vue.options = Object.create(null) ASSET_TYPES.forEach(type => { Vue.options[type + 's'] = Object.create(null) }) // this is used to identify the \"base\" constructor to extend all plain-object // components with in Weex's multi-instance scenarios. Vue.options._base = Vue extend(Vue.options.components, builtInComponents) initUse(Vue) initMixin(Vue) initExtend(Vue) initAssetRegisters(Vue) } 这里就是在 Vue 上扩展的一些全局方法的定义，Vue 官网中关于全局 API 都可以在这里找到，这里不会介绍细节，会在之后的章节我们具体介绍到某个 API 的时候会详细介绍。有一点要注意的是，Vue.util 暴露的方法最好不要依赖，因为它可能经常会发生变化，是不稳定的。 总结那么至此，Vue 的初始化过程基本介绍完毕。这一节的目的是让我们对 Vue 是什么有一个直观的认识，它本质上就是一个用 Function 实现的 Class，然后它的原型 prototype 以及它本身都扩展了一系列的方法和属性，那么 Vue 能做什么，它是怎么做的，会在后面的章节一层层揭开 Vue 的神秘面纱。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - Vue.js 源码构建","slug":"005.vue源码学习/001.源码目录/004.Vue.js 源码构建","date":"2018-01-13T08:45:21.000Z","updated":"2019-09-16T01:57:01.501Z","comments":true,"path":"2018/01/13/005.vue源码学习/001.源码目录/004.Vue.js 源码构建/","link":"","permalink":"http://www.chenya.site/2018/01/13/005.vue源码学习/001.源码目录/004.Vue.js 源码构建/","excerpt":"","text":"Vue.js 源码构建Vue.js 源码是基于 Rollup 构建的，它的构建相关配置都在 scripts 目录下。 构建脚本通常一个基于 NPM 托管的项目都会有一个 package.json 文件，它是对项目的描述文件，它的内容实际上是一个标准的 JSON 对象。 我们通常会配置 script 字段作为 NPM 的执行脚本，Vue.js 源码构建的脚本如下： { \"script\": { \"build\": \"node scripts/build.js\", \"build:ssr\": \"npm run build -- web-runtime-cjs,web-server-renderer\", \"build:weex\": \"npm run build -- weex\" } } 这里总共有 3 条命令，作用都是构建 Vue.js，后面 2 条是在第一条命令的基础上，添加一些环境参数。 当在命令行运行 npm run build 的时候，实际上就会执行 node scripts/build.js，接下来我们来看看它实际是怎么构建的。 构建过程我们对于构建过程分析是基于源码的，先打开构建的入口 JS 文件，在 scripts/build.js 中： let builds = require('./config').getAllBuilds() // filter builds via command line arg if (process.argv[2]) { const filters = process.argv[2].split(',') builds = builds.filter(b => { return filters.some(f => b.output.file.indexOf(f) > -1 || b._name.indexOf(f) > -1) }) } else { // filter out weex builds by default builds = builds.filter(b => { return b.output.file.indexOf('weex') === -1 }) } build(builds) 这段代码逻辑非常简单，先从配置文件读取配置，再通过命令行参数对构建配置做过滤，这样就可以构建出不同用途的 Vue.js 了。接下来我们看一下配置文件，在 scripts/config.js 中： const builds = { // Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify 'web-runtime-cjs': { entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.common.js'), format: 'cjs', banner }, // Runtime+compiler CommonJS build (CommonJS) 'web-full-cjs': { entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.common.js'), format: 'cjs', alias: { he: './entity-decoder' }, banner }, // Runtime only (ES Modules). Used by bundlers that support ES Modules, // e.g. Rollup &amp; Webpack 2 'web-runtime-esm': { entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.esm.js'), format: 'es', banner }, // Runtime+compiler CommonJS build (ES Modules) 'web-full-esm': { entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.esm.js'), format: 'es', alias: { he: './entity-decoder' }, banner }, // runtime-only build (Browser) 'web-runtime-dev': { entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.js'), format: 'umd', env: 'development', banner }, // runtime-only production build (Browser) 'web-runtime-prod': { entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.min.js'), format: 'umd', env: 'production', banner }, // Runtime+compiler development build (Browser) 'web-full-dev': { entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.js'), format: 'umd', env: 'development', alias: { he: './entity-decoder' }, banner }, // Runtime+compiler production build (Browser) 'web-full-prod': { entry: resolve('web/entry-runtime-with-compiler.js'), dest: resolve('dist/vue.min.js'), format: 'umd', env: 'production', alias: { he: './entity-decoder' }, banner }, // ... } ` 这里列举了一些 Vue.js 构建的配置，关于还有一些服务端渲染 webpack 插件以及 weex 的打包配置就不列举了。 对于单个配置，它是遵循 Rollup 的构建规则的。其中 entry 属性表示构建的入口 JS 文件地址，dest 属性表示构建后的 JS 文件地址。format 属性表示构建的格式，cjs 表示构建出来的文件遵循 CommonJS 规范，es 表示构建出来的文件遵循 ES Module 规范。 umd 表示构建出来的文件遵循 UMD 规范。 以 web-runtime-cjs 配置为例，它的 entry 是resolve(&#39;web/entry-runtime.js&#39;)，先来看一下 resolve 函数的定义。 源码目录：scripts/config.js const aliases = require('./alias') const resolve = p => { const base = p.split('/')[0] if (aliases[base]) { return path.resolve(aliases[base], p.slice(base.length + 1)) } else { return path.resolve(__dirname, '../', p) } } 这里的 resolve 函数实现非常简单，它先把 resolve 函数传入的参数 p 通过 / 做了分割成数组，然后取数组第一个元素设置为 base。在我们这个例子中，参数 p 是 web/entry-runtime.js，那么 base 则为 web。base 并不是实际的路径，它的真实路径借助了别名的配置，我们来看一下别名配置的代码，在 scripts/alias 中： const path = require('path') module.exports = { vue: path.resolve(__dirname, '../src/platforms/web/entry-runtime-with-compiler'), compiler: path.resolve(__dirname, '../src/compiler'), core: path.resolve(__dirname, '../src/core'), shared: path.resolve(__dirname, '../src/shared'), web: path.resolve(__dirname, '../src/platforms/web'), weex: path.resolve(__dirname, '../src/platforms/weex'), server: path.resolve(__dirname, '../src/server'), entries: path.resolve(__dirname, '../src/entries'), sfc: path.resolve(__dirname, '../src/sfc') } 很显然，这里 web 对应的真实的路径是 path.resolve(__dirname, &#39;../src/platforms/web&#39;)，这个路径就找到了 Vue.js 源码的 web 目录。然后 resolve 函数通过 path.resolve(aliases[base], p.slice(base.length + 1)) 找到了最终路径，它就是 Vue.js 源码 web 目录下的 entry-runtime.js。因此，web-runtime-cjs 配置对应的入口文件就找到了。 它经过 Rollup 的构建打包后，最终会在 dist 目录下生成 vue.runtime.common.js。 Runtime Only VS Runtime + Compiler通常我们利用 vue-cli 去初始化我们的 Vue.js 项目的时候会询问我们用 Runtime Only 版本的还是 Runtime + Compiler 版本。下面我们来对比这两个版本。 Runtime Only 我们在使用 Runtime Only 版本的 Vue.js 的时候，通常需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更轻量。 Runtime + Compiler 我们如果没有对代码做预编译，但又使用了 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板，如下所示： // 需要编译器的版本 new Vue({ template: '&lt;div>{{ hi }}&lt;/div>' }) // 这种情况不需要 new Vue({ render (h) { return h('div', this.hi) } }) 因为在 Vue.js 2.0 中，最终渲染都是通过 render 函数，如果写 template 属性，则需要编译成 render 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本。 很显然，这个编译过程对性能会有一定损耗，所以通常我们更推荐使用 Runtime-Only 的 Vue.js。 总结通过这一节的分析，我们可以了解到 Vue.js 的构建打包过程，也知道了不同作用和功能的 Vue.js 它们对应的入口以及最终编译生成的 JS 文件。尽管在实际开发过程中我们会用 Runtime Only 版本开发比较多，但为了分析 Vue 的编译过程，我们这门课重点分析的源码是 Runtime + Compiler 的 Vue.js。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"koa2简析结构","slug":"004.koa学习/001.基础篇/001.koa2开始/003.koa2简析结构","date":"2018-01-12T14:31:02.000Z","updated":"2019-09-16T01:57:01.496Z","comments":true,"path":"2018/01/12/004.koa学习/001.基础篇/001.koa2开始/003.koa2简析结构/","link":"","permalink":"http://www.chenya.site/2018/01/12/004.koa学习/001.基础篇/001.koa2开始/003.koa2简析结构/","excerpt":"","text":"koa2简析结构源码文件├── lib │ ├── application.js │ ├── context.js │ ├── request.js │ └── response.js └── package.json 这个就是 GitHub https://github.com/koajs/koa上开源的koa2源码的源文件结构，核心代码就是lib目录下的四个文件 application.js 是整个koa2 的入口文件，封装了context，request，response，以及最核心的中间件处理流程。 context.js 处理应用上下文，里面直接封装部分request.js和response.js的方法 request.js 处理http请求 response.js 处理http响应 koa2特性 只提供封装好http上下文、请求、响应，以及基于async/await的中间件容器。 利用ES7的async/await的来处理传统回调嵌套问题和代替koa@1的generator，但是需要在node.js 7.x的harmony模式下才能支持async/await。 中间件只支持 async/await 封装的，如果要使用koa@1基于generator中间件，需要通过中间件koa-convert封装一下才能使用。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"Vue源码学习 - Vue.js 源码目录设计","slug":"005.vue源码学习/001.源码目录/003.Vue.js 源码目录设计","date":"2018-01-12T01:12:44.000Z","updated":"2019-09-16T01:57:01.501Z","comments":true,"path":"2018/01/12/005.vue源码学习/001.源码目录/003.Vue.js 源码目录设计/","link":"","permalink":"http://www.chenya.site/2018/01/12/005.vue源码学习/001.源码目录/003.Vue.js 源码目录设计/","excerpt":"","text":"Vue.js 源码目录设计Vue.js 的源码都在 src 目录下，其目录结构如下。 src ├── compiler # 编译相关 ├── core # 核心代码 ├── platforms # 不同平台的支持 ├── server # 服务端渲染 ├── sfc # .vue 文件解析 ├── shared # 共享代码 compilercompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。 编译的工作可以在构建时做（借助 webpack、vue-loader 等辅助插件）；也可以在运行时做，使用包含构建功能的 Vue.js。显然，编译是一项耗性能的工作，所以更推荐前者——离线编译。 corecore 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。 这里的代码可谓是 Vue.js 的灵魂，也是我们之后需要重点分析的地方。 platformVue.js 是一个跨平台的 MVVM 框架，它可以跑在 web 上，也可以配合 weex 跑在 native 客户端上。platform 是 Vue.js 的入口，2 个目录代表 2 个主要入口，分别打包成运行在 web 上和 weex 上的 Vue.js。 我们会重点分析 web 入口打包后的 Vue.js，对于 weex 入口打包的 Vue.js，感兴趣的可以自行研究。 serverVue.js 2.0 支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。注意：这部分代码是跑在服务端的 Node.js，不要和跑在浏览器端的 Vue.js 混为一谈。 服务端渲染主要的工作是把组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序。 sfc通常我们开发 Vue.js 都会借助 webpack 构建， 然后通过 .vue 单文件来编写组件。 这个目录下的代码逻辑会把 .vue 文件内容解析成一个 JavaScript 的对象。 sharedVue.js 会定义一些工具方法，这里定义的工具方法都是会被浏览器端的 Vue.js 和服务端的 Vue.js 所共享的。 总结从 Vue.js 的目录设计可以看到，作者把功能模块拆分的非常清楚，相关的逻辑放在一个独立的目录下维护，并且把复用的代码也抽成一个独立目录。 这样的目录设计让代码的阅读性和可维护性都变强，是非常值得学习和推敲的。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"Vue源码学习 - 认识 Flow","slug":"005.vue源码学习/001.源码目录/002.认识 Flow","date":"2018-01-08T14:13:34.000Z","updated":"2019-09-16T01:57:01.501Z","comments":true,"path":"2018/01/08/005.vue源码学习/001.源码目录/002.认识 Flow/","link":"","permalink":"http://www.chenya.site/2018/01/08/005.vue源码学习/001.源码目录/002.认识 Flow/","excerpt":"","text":"认识 FlowFlow 是 facebook 出品的 JavaScript 静态类型检查工具。Vue.js 的源码利用了 Flow 做了静态类型检查，所以了解 Flow 有助于我们阅读源码。 为什么用 FlowJavaScript 是动态类型语言，它的灵活性有目共睹，但是过于灵活的副作用是很容易就写出非常隐蔽的隐患代码，在编译期甚至看上去都不会报错，但在运行阶段就可能出现各种奇怪的 bug。 类型检查是当前动态类型语言的发展趋势，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。 项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。 Vue.js 在做 2.0 重构的时候，在 ES2015 的基础上，除了 ESLint 保证代码风格之外，也引入了 Flow 做静态类型检查。之所以选择 Flow，主要是因为 Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力。 Flow 的工作方式通常类型检查分成 2 种方式： 类型推断：通过变量的使用上下文来推断出变量类型，然后根据这些推断来检查类型。 类型注释：事先注释好我们期待的类型，Flow 会基于这些注释来判断。 类型推断它不需要任何代码修改即可进行类型检查，最小化开发者的工作量。它不会强制你改变开发习惯，因为它会自动推断出变量的类型。这就是所谓的类型推断，Flow 最重要的特性之一。 通过一个简单例子说明一下： /*@flow*/ function split(str) { return str.split(' ') } split(11) Flow 检查上述代码后会报错，因为函数 split期待的参数是字符串，而我们输入了数字。 类型注释如上所述，类型推断是 Flow 最有用的特性之一，不需要编写类型注释就能获取有用的反馈。但在某些特定的场景下，添加类型注释可以提供更好更明确的检查依据。 考虑如下代码： /*@flow*/ function add(x, y){ return x + y } add('Hello', 11) Flow 检查上述代码时检查不出任何错误，因为从语法层面考虑， + 既可以用在字符串上，也可以用在数字上，我们并没有明确指出 add() 的参数必须为数字。 在这种情况下，我们可以借助类型注释来指明期望的类型。类型注释是以冒号 : 开头，可以在函数参数，返回值，变量声明中使用。 如果我们在上段代码中添加类型注释，就会变成如下： /*@flow*/ function add(x: number, y: number): number { return x + y } add('Hello', 11) 现在 Flow 就能检查出错误，因为函数参数的期待类型为数字，而我们提供了字符串。 上面的例子是针对函数的类型注释。接下来我们来看看 Flow 能支持的一些常见的类型注释。 数组/*@flow*/ var arr: Array&lt;number> = [1, 2, 3] arr.push('Hello') 数组类型注释的格式是 Array&lt;T&gt;，T 表示数组中每项的数据类型。在上述代码中，arr 是每项均为数字的数组。如果我们给这个数组添加了一个字符串，Flow 能检查出错误。 类和对象/*@flow*/ class Bar { x: string; // x 是字符串 y: string | number; // y 可以是字符串或者数字 z: boolean; constructor(x: string, y: string | number) { this.x = x this.y = y this.z = false } } var bar: Bar = new Bar('hello', 4) var obj: { a: string, b: number, c: Array&lt;string>, d: Bar } = { a: 'hello', b: 11, c: ['hello', 'world'], d: new Bar('hello', 3) } 类的类型注释格式如上，可以对类自身的属性做类型检查，也可以对构造函数的参数做类型检查。这里需要注意的是，属性 y 的类型中间用 | 做间隔，表示 y 的类型即可以是字符串也可以是数字。 对象的注释类型类似于类，需要指定对象属性的类型。 Null若想任意类型 T 可以为 null 或者 undefined，只需类似如下写成 ?T 的格式即可。 /*@flow*/ var foo: ?string = null 此时，foo 可以为字符串，也可以为 null。 目前我们只列举了 Flow 的一些常见的类型注释。如果想了解所有类型注释，请移步 Flow 的官方文档。 Flow 在 Vue.js 源码中的应用有时候我们想引用第三方库，或者自定义一些类型，但 Flow 并不认识，因此检查的时候会报错。为了解决这类问题，Flow 提出了一个 libdef 的概念，可以用来识别这些第三方库或者是自定义类型，而 Vue.js 也利用了这一特性。 在 Vue.js 的主目录下有 .flowconfig 文件， 它是 Flow 的配置文件，可以看官方文档。这其中的 [libs] 部分用来描述包含指定库定义的目录，默认是名为 flow-typed 的目录。 这里 [libs] 配置的是 flow，表示指定的库定义都在 flow 文件夹内。我们打开这个目录，会发现文件如下： flow ├── compiler.js # 编译相关 ├── component.js # 组件数据结构 ├── global-api.js # Global API 结构 ├── modules.js # 第三方库定义 ├── options.js # 选项相关 ├── ssr.js # 服务端渲染相关 ├── vnode.js # 虚拟 node 相关 可以看到，Vue.js 有很多自定义类型的定义，在阅读源码的时候，如果遇到某个类型并想了解它完整的数据结构的时候，可以回来翻阅这些数据结构的定义。 总结通过对 Flow 的认识，有助于我们阅读 Vue 的源码，并且这种静态类型检查的方式非常有利于大型项目源码的开发和维护。类似 Flow 的工具还有如 TypeScript等。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"async-await使用","slug":"004.koa学习/001.基础篇/001.koa2开始/002. async-await使用","date":"2018-01-06T05:32:12.000Z","updated":"2019-09-16T01:57:01.495Z","comments":true,"path":"2018/01/06/004.koa学习/001.基础篇/001.koa2开始/002. async-await使用/","link":"","permalink":"http://www.chenya.site/2018/01/06/004.koa学习/001.基础篇/001.koa2开始/002. async-await使用/","excerpt":"","text":"async/await使用快速上手理解 先复制以下这段代码，在粘贴在chrome的控制台console中，按回车键执行 function getSyncTime() { return new Promise((resolve, reject) => { try { let startTime = new Date().getTime() setTimeout(() => { let endTime = new Date().getTime() let data = endTime - startTime resolve( data ) }, 500) } catch ( err ) { reject( err ) } }) } async function getSyncData() { let time = await getSyncTime() let data = `endTime - startTime = ${time}` return data } async function getData() { let data = await getSyncData() console.log( data ) } getData() 在chrome的console中执行结果如下 async 从上述例子可以看出 async/await 的特点： 可以让异步逻辑用同步写法实现 最底层的await返回需要是Promise对象 可以通过多层 async function 的同步写法代替传统的callback嵌套","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"Koa 框架介绍以及 Koa2.x 环境搭建","slug":"004.koa学习/001.基础篇/001.koa2开始/001.Koa 框架介绍以及 Koa2.x 环境搭 建","date":"2018-01-05T15:12:03.000Z","updated":"2019-09-16T01:57:01.495Z","comments":true,"path":"2018/01/05/004.koa学习/001.基础篇/001.koa2开始/001.Koa 框架介绍以及 Koa2.x 环境搭 建/","link":"","permalink":"http://www.chenya.site/2018/01/05/004.koa学习/001.基础篇/001.koa2开始/001.Koa 框架介绍以及 Koa2.x 环境搭 建/","excerpt":"","text":"目录 内容 一 Koa 框架介绍 二 Koa2.x 框架的安装使用 一、 Koa 框架介绍Node.js 是一个异步的世界， 官方 API 支持的都是 callback 形式的异步编程模型， 这会带来许多问题例如：1、callback嵌套问题2、 异步函数中可能同步调用 callback返回数据， 带来不一致性为了解决以上问题Koa出现了 Koa -- 基于 Node.js 平台的下一代 web 开发框架 koa是由Express原班人马打造的， 致力于成为一个更小、 更富有表现力、 更健壮的Web 框架。 使用koa编写 web 应用，可以免除重复繁琐的回调函数嵌套koa 不在内核方法中绑定任何中间件， 它仅仅提供了一个轻量优雅的函数库， 使得编写 Web 应用变得得心应手开发思路和 express 差不多， 最大的特点就是可以避免异步嵌套。 阿里是业界最早的一批使用 Node.js来做线上大流量应用的公司，早在 2011 年的就已经开始在生产环境中使用。众所周知， 在阿里的技术栈中，Java是最最核心的， 那 Node.js扮演怎么样的一个角色呢？1、 基础设施大部分采用 Java 实现， 变化较少， 有事务要求的 Business Services 通常使用Java。2、 而 Node.js 则替代过去PHP/Java Web的场景， 用在需要快速迭代， 需求变化非常快的用户侧。3、 很多内部的工程化支撑系统也逐渐基于 Node.js 了。据不完全统计， 目前阿里 Node.js的开发者几百号人， 线上的应用也非常之多， 仅次于Java应用， 光对外服务的进程数就超过 1w+。阿里内部就在使用Koa框架， 并在Koa基础上面做了一些扩展和封装。 并且基于 koa开发了一个开源框架 egg Koa 学习网站：英语官网中文官网 二、 Koa2.x 框架的安装使用1、安装 Node.js 8.x 以上的版本开发 Koa2 之前， Node.js 是有要求的， 它要求 Node.js 版本高于 V7.6。 因为 node.js 7.6 版本开始完全支持 async/await， 所以才能完全你支持我们的 Koa2。 node.js环境 版本v7.6以上 直接安装node.js 7.6：node.js官网地址https://nodejs.org nvm管理多版本node.js：可以用nvm 进行node版本进行管理 Mac系统安装nvm https://github.com/creationix/nvm#manual-install windows系统安装nvm https://github.com/coreybutler/nvm-windows Ubuntu系统安装nvm https://github.com/creationix/nvm npm 版本3.x以上 2、初始化package.jsonnpm init 3、 安装 Koa安装 Koa 框架和我们以前安装其他模块是一样的。 npm install --save koa 或者 cnpm install --save koa –save 参数， 表示自动修改 package.json 文件，自动添加依赖项。 4、 hello world 代码const Koa = require('koa') const app = new Koa() app.use( async ( ctx ) => { ctx.body = 'hello koa2' }) app.listen(3000) console.log('[demo] start-quick is starting at port 3000') 5、启动demo 由于koa2是基于async/await操作中间件，目前node.js 7.x的harmony模式下才能使用，所以启动的时的脚本如下： node index.js 访问http:localhost:3000，效果如下 start-result-01","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"koa学习","slug":"koa学习","permalink":"http://www.chenya.site/tags/koa学习/"}]},{"title":"Vue源码学习 - Vue源码学习内容","slug":"005.vue源码学习/001.源码目录/001.学习内容","date":"2018-01-05T15:12:03.000Z","updated":"2019-09-16T01:57:01.500Z","comments":true,"path":"2018/01/05/005.vue源码学习/001.源码目录/001.学习内容/","link":"","permalink":"http://www.chenya.site/2018/01/05/005.vue源码学习/001.源码目录/001.学习内容/","excerpt":"","text":"Vue源码内容分析 | ├ 目录结构 | ├ Flow | ├ 源码构建 | ├ 核心 | ├ 数据驱动 | | ├ 数据 -&gt; DOM创建完整流程 | ├ 组件化 | | ├ 组件创建、组件相关核心概念 │ ├ 响应式原理 | | ├ 响应式实现原理 | ├ 编译 │ ├ parse | | ├ 模板 -&gt; AST树 │ ├ optimize | | ├ 优化AST树 │ ├ codegen | | ├ AST树 -&gt; 代码 | ├ 扩展 │ ├ event | | ├ 事件实现原理 │ ├ v-model | | ├ v-model实现原理 │ ├ slot | | ├ 内置组件实现原理 │ ├ keep-alive | | ├ 内置组件实现原理 │ └ transition | | ├ 过渡实现原理 | ├ 生态 │ ├ Vue-Router | | ├ 官方路由实现原理 │ ├ Vuex | | ├ 官方状态管理实现原理 │","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端资源","slug":"前端资源","permalink":"http://www.chenya.site/tags/前端资源/"},{"name":"Vue源码学习","slug":"Vue源码学习","permalink":"http://www.chenya.site/tags/Vue源码学习/"}]},{"title":"js实现元素拖拽","slug":"003.日常学习/js实现元素拖拽","date":"2017-09-05T15:12:03.000Z","updated":"2019-09-16T01:57:01.495Z","comments":true,"path":"2017/09/05/003.日常学习/js实现元素拖拽/","link":"","permalink":"http://www.chenya.site/2017/09/05/003.日常学习/js实现元素拖拽/","excerpt":"","text":"js实现元素拖拽被移动元素必须为绝对定位 position:absolute; Dom &lt;div class = \"move-container\" > &lt;div class = \"move\" style=\"position:absolute; width:100px; height:100px; background:gray\"> &lt;/div> &lt;/div> Javasrtiptvar moveElem = document.querySelector('.move'); //待拖拽元素 var dragging; //是否激活拖拽状态 var tLeft, tTop; //鼠标按下时相对于选中元素的位移 //监听鼠标按下事件 document.addEventListener('mousedown', function(e) { if (e.target == moveElem) { dragging = true; //激活拖拽状态 var moveElemRect = moveElem.getBoundingClientRect(); tLeft = e.clientX - moveElemRect.left; //鼠标按下时和选中元素的坐标偏移:x坐标 tTop = e.clientY - moveElemRect.top; //鼠标按下时和选中元素的坐标偏移:y坐标 } }); //监听鼠标放开事件 document.addEventListener('mouseup', function(e) { dragging = false; }); //监听鼠标移动事件 document.addEventListener('mousemove', function(e) { if (dragging) { var moveX = e.clientX - tLeft, moveY = e.clientY - tTop; moveElem.style.left = moveX + 'px'; moveElem.style.top = moveY + 'px'; } });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"日常学习","slug":"日常学习","permalink":"http://www.chenya.site/tags/日常学习/"},{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"}]},{"title":"综合篇-01.前端综合知识","slug":"002.前端知识体系/007.综合篇/001.综合篇之前端综合知识","date":"2017-08-12T04:22:39.000Z","updated":"2019-09-16T01:57:01.495Z","comments":true,"path":"2017/08/12/002.前端知识体系/007.综合篇/001.综合篇之前端综合知识/","link":"","permalink":"http://www.chenya.site/2017/08/12/002.前端知识体系/007.综合篇/001.综合篇之前端综合知识/","excerpt":"","text":"一、基础1.1 HTML html5新标签有哪些 canvas、svg、webGL 你是如何理解 HTML语义化的，有什么好处 前端需要注意哪些SEO? manifest、worker、socket input和textarea的区别 用一个div模拟textarea的实现 1.2 CSS css3有什么新特性，浏览器支持怎么样 伪类是什么？有哪些？会有哪些兼容性问题？如何处理？ css预处理器知道吗？用过哪些？有什么优劣？后处理器知道吗？ 盒模型有哪几种？怪异模式和标准模式？ less、sass、postcss、prefix 层叠优先级 圣杯、双飞燕布局 float清除浮动 flex布局、 grid布局、table布局 css以及中轴旋转、动画变换 绘制三角形、矩形、菱形、梯形（奇巧淫技，可以不问） sprite图（雪碧图）知道吗？svg雪碧图了解吗？ px、em、rem、vw、vh？rem的根节点样式在什么时候设置？ position有哪些？他们的定位原点是什么？ 媒体查询用css好还是用js好？ link和@import的区别？ 响应式布局的原理 css低版本浏览器兼容问题，额外需要什么后缀来声明浏览器兼容 !important意义，是否应当规避使用？ BFC块级上下文、IFC，实现双栏高度对齐 BEM命名法，有什么优势，有什么劣势 1px边框问题 （水平）居中有哪些实现方式、（垂直）居中有哪些实现方式 1.3 JavaScript typeof以及弱类型转换规则？NaN、undefined、null dom的节点操作？能够背api还是知道api？ ajax是什么？知道底层实现原理吗？知道fetch吗？自己封装过吗？ GET、POST意义？restful架构下还有别的什么请求？OPTION请求是什么？ 事件冒泡和事件捕获是怎样的？对应的默认方法有什么？一般在什么情况使用？ call、apply、bind 如何判断数据类型？ hoisting是什么？具体表现是怎样的？ 匿名函数是什么？函数表达式和函数声明的区别？ let、const暂时性锁区知道吗？表现是怎样的？ 严格模式是什么？有什么好处？use strict arguments是什么类型？callee和caller有什么区别？ Date.format实现过吗？思路是怎样的？ 动画：setTimeout何时执行，requestAnimationFrame的优点 你知道new一个对象有几步吗？ 二、高级2.1 Browser 打开一个网页经历了那些过程？ 浏览器加载白屏是什么原因？ 千万访问量的项目，前端需要注意些什么？ 2.2 JavaScript 表达式和语句有什么区别？如何把语句转换为表达式？ 什么叫执行上下文栈(·Execution Context Stack)·? 一个函数调用会产生多少个上下文环境？如何激活一个上下文，什么叫caller(调用者)，什么叫callee(被调用者)？给你一段代码能否画出执行过程中的上下文堆栈变化？ 执行上下文包括哪些结构(状态/属性)，如何追踪关联代码的执行进度？ eval在调用的时候有哪些特别的地方？eval函数自身会产生上下文吗？会影响当前的调用上下文吗？ 什么叫变量对象？什么叫活动对象？ 词法作用域是什么？闭包是如何形成的？ var foo = function bar () {}命名函数表达式中(上述的foo函数)bar变量是定义在哪一层作用域的？ (0, 1, 2) 的结果是什么？ var foo = { value: 2, bar: function () { return this.value; } 中(foo.bar, foo.bar)()的this值是什么？(foo.bar = foo.bar)()、(false || foo.bar)()呢? 2.3 HTTP http1.0和http1.1的区别 http请求码有哪些？206、302、303、304、307 能说下304具体怎样实现吗？ http缓存逻辑是怎样的？协商缓存与强缓存？Last-Modified / Etag / Expires / Cache-Control？ osi七层协议和tcp/ip四层协议 三次握手和四次握手 跨域是什么？http协议中如何判断跨域？如何解决跨域问题？ http2具体内容？SDPY了解么？ HTTPS如何实现？tsl/ssl是什么？对称加密、非对称加密在什么时候、对什么数据加密？ DNS劫持是什么？ 浏览器在一次 HTTP 请求中，需要传输一个 4097 字节的文本数据给服务端，可以采用那些方式? 2.4 优化 首屏优化 预加载资源、预解析DNS 懒加载图片怎么做 iframe一般怎么使用？ window.onload、document.ready顺序？iframe会阻塞吗？ cdn是什么？如何查找最近的cdn？ gzip、chucked 前端安全：xss攻击和防范、CSRF、CORS 硬件加速怎样开启 优化中会提到缓存的问题，问：静态资源或者接口等如何做缓存优化 页面DOM节点太多，会出现什么问题？如何优化？ 2.5 Products 这里主要是一些生产中真实存在的问题 一个feed流，有哪些展现方式？如果当前页面可视区有5个格子，而你有20条信息需要展示，请问有哪些自动展示的算法？ 移动端的缓存机制有哪几种？ 小程序如何与native通信？react-native实现原理？jsbridge如何实现？ 过万条数据如何加载和渲染？ 如何在前端解析二进制，流媒体、图片二进制数据怎样渲染到页面上？ 如何解析二进制音频、视频？ 文件如何显示上传百分比？ 如何制作一个富文本，需要考虑哪些结构？ html5的播放器怎么做？视频直播如何在浏览器里面实现？HLS、RTMP 如何在浏览器里面裁剪图片？如何裁剪视频，对视频做逐帧分析？ 如何实现一个具有引导功能的组件库？ 如何封装一个Form和FormItem，使其能够跟input、select、checkbox、radio等组件进行 数据存储、数据校验（自定义逻辑）、校验反馈？ echart这类图像库的实现原理？ i18n的国际化方案应该是怎样的？ 数据埋点的意义是什么？应当针对哪些数据进行埋点？如何构建一个埋点系统？ 小程序的实现原理是什么？这【五篇】文章将带你深入了解「微信小程序」 三、 Framework3.1 React React的生命周期mount和update描述下 React的生命周期中的isBatchingUpdates了解吗？Transaction知道吗 React的vdom如何实现？jsx是怎样解析的？ React的Fiber`是什么？具有什么样的特性？ React的diff/patch算法原理 React的组件逻辑（受控、非受控）？如何设计一个组件库 React的数据流，Redux、Mobx、Rxjs，发布订阅模式、观察者模式，flux和no-flux React的事件注册和事件分发知道吗？ Redux解决了什么痛点（有什么优点），又有什么缺点 Redux的中间件有哪些？redux-actions、redux-promise、redux-thunk、redux-saga、redux-immutable了解过哪些？说说中间件的意义 Redux有什么优化方案？ SSR了解过吗？怎样做？了解Koa么？ React-Native了解过吗？JavascriptCore是什么？ 3.2 Vue Vue是如何设计响应式系统的？（依赖收集） 什么时候使用computed, methods,watch？之间有什么样区别？ template 和 render(jsx) 有什么的联系？ this.$nextTick是如何设计的？ Vue 组件 data 为什么必须是函数？ 3.3 AngularJS 尽管angularJS已经基本退出了历史舞台，但是相信有的同学还是做过相关的项目，并很有可能被面试官问起 angularJS的数据绑定采用什么机制？详述原理 如果通过angularJS的 directive/component 规划一套全组件化体系，可能遇到哪些挑战？ 一个angularJS应用应当如何良好地分层？ ng-click中写的表达式，能使用JS原生对象上的方法，比如Math.max之类的吗？为什么","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"综合篇","slug":"综合篇","permalink":"http://www.chenya.site/tags/综合篇/"},{"name":"高频考点","slug":"高频考点","permalink":"http://www.chenya.site/tags/高频考点/"}]},{"title":"简版篇-05.网络基础类知识","slug":"002.前端知识体系/006.精简篇/005.简版篇之网络基础类知识","date":"2017-07-20T02:25:39.000Z","updated":"2019-09-16T01:57:01.495Z","comments":true,"path":"2017/07/20/002.前端知识体系/006.精简篇/005.简版篇之网络基础类知识/","link":"","permalink":"http://www.chenya.site/2017/07/20/002.前端知识体系/006.精简篇/005.简版篇之网络基础类知识/","excerpt":"","text":"五、网络基础类5.1 跨域 很多种方法，但万变不离其宗，都是为了搞定同源策略。重用的有 jsonp、iframe、cors、img、HTML5 postMessage等等。其中用到 html 标签进行跨域的原理就是 html 不受同源策略影响。但只是接受 Get 的请求方式，这个得清楚。 延伸1：img iframe script 来发送跨域请求有什么优缺点？ 1. iframe 优点：跨域完毕之后DOM操作和互相之间的JavaScript调用都是没有问题的 缺点：1.若结果要以URL参数传递，这就意味着在结果数据量很大的时候需要分割传递，巨烦。2.还有一个是iframe本身带来的，母页面和iframe本身的交互本身就有安全性限制。 2. script 优点：可以直接返回json格式的数据，方便处理 缺点：只接受GET请求方式 3. 图片ping 优点：可以访问任何url，一般用来进行点击追踪，做页面分析常用的方法 缺点：不能访问响应文本，只能监听是否响应 延伸2：配合 webpack 进行反向代理？ webpack 在 devServer 选项里面提供了一个 proxy 的参数供开发人员进行反向代理 '/api': { target: 'http://www.example.com', // your target host changeOrigin: true, // needed for virtual hosted sites pathRewrite: { '^/api': '' // rewrite path } }, 然后再配合 http-proxy-middleware 插件对 api 请求地址进行代理 const express = require('express'); const proxy = require('http-proxy-middleware'); // proxy api requests const exampleProxy = proxy(options); // 这里的 options 就是 webpack 里面的 proxy 选项对应的每个选项 // mount `exampleProxy` in web server const app = express(); app.use('/api', exampleProxy); app.listen(3000); 然后再用 nginx 把允许跨域的源地址添加到报头里面即可 说到 nginx ，可以再谈谈 CORS 配置，大致如下 location / { if ($request_method = 'OPTIONS') { add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Headers' 'DNT, X-Mx-ReqToken, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type'; add_header 'Access-Control-Max-Age' 86400; add_header 'Content-Type' 'text/plain charset=UTF-8'; add_header 'Content-Length' 0; return 200; } } 5.2 http 无状态无连接 http 协议对于事务处理没有记忆能力 对同一个url请求没有上下文关系 每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器 人生若只如初见，请求过的资源下一次会继续进行请求 http协议无状态中的 状态 到底指的是什么？！ 【状态】的含义就是：客户端和服务器在某次会话中产生的数据 那么对应的【无状态】就意味着：这些数据不会被保留 通过增加cookie和session机制，现在的网络请求其实是有状态的 在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话 5.3 http-cache：就是 http 缓存1. 首先得明确 http 缓存的好处 减少了冗余的数据传输，减少网费 减少服务器端的压力 Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间 加快客户端加载网页的速度 2. 常见 http 缓存的类型 私有缓存（一般为本地浏览器缓存） 代理缓存 3. 然后谈谈本地缓存 本地缓存是指浏览器请求资源时命中了浏览器本地的缓存资源，浏览器并不会发送真正的请求给服务器了。它的执行过程是 第一次浏览器发送请求给服务器时，此时浏览器还没有本地缓存副本，服务器返回资源给浏览器，响应码是200 OK，浏览器收到资源后，把资源和对应的响应头一起缓存下来 第二次浏览器准备发送请求给服务器时候，浏览器会先检查上一次服务端返回的响应头信息中的Cache-Control，它的值是一个相对值，单位为秒，表示资源在客户端缓存的最大有效期，过期时间为第一次请求的时间减去Cache-Control的值，过期时间跟当前的请求时间比较，如果本地缓存资源没过期，那么命中缓存，不再请求服务器 如果没有命中，浏览器就会把请求发送给服务器，进入缓存协商阶段。 与本地缓存相关的头有：Cache-Control、Expires，Cache-Control有多个可选值代表不同的意义，而Expires就是一个日期格式的绝对值。 3.1 Cache-Control Cache-Control是HTPP缓存策略中最重要的头，它是HTTP/1.1中出现的，它由如下几个值 no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载 no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源 public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 max-age：从当前请求开始，允许获取的响应被重用的最长时间（秒）。 # 例如： Cache-Control: public, max-age=1000 # 表示资源可以被所有用户以及代理服务器缓存，最长时间为1000秒。 3.2 Expires Expires是HTTP/1.0出现的头信息，同样是用于决定本地缓存策略的头，它是一个绝对时间，时间格式是如Mon, 10 Jun 2015 21:31:12 GMT，只要发送请求时间是在Expires之前，那么本地缓存始终有效，否则就会去服务器发送请求获取新的资源。如果同时出现Cache-Control：max-age和Expires，那么max-age优先级更高。他们可以这样组合使用 Cache-Control: public Expires: Wed, Jan 10 2018 00:27:04 GMT 3.3 所谓的缓存协商 当第一次请求时服务器返回的响应头中存在以下情况时 没有 Cache-Control 和 Expires Cache-Control 和 Expires 过期了 Cache-Control 的属性设置为 no-cache 时 那么浏览器第二次请求时就会与服务器进行协商，询问浏览器中的缓存资源是不是旧版本，需不需要更新，此时，服务器就会做出判断，如果缓存和服务端资源的最新版本是一致的，那么就无需再次下载该资源，服务端直接返回304 Not Modified 状态码，如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是200 Ok，那么服务端是根据什么来判断浏览器的缓存是不是最新的呢？其实是根据HTTP的另外两组头信息，分别是：Last-Modified/If-Modified-Since 与 ETag/If-None-Match。 Last-Modified 与 If-Modified-Since 浏览器第一次请求资源时，服务器会把资源的最新修改时间Last-Modified:Thu, 29 Dec 2011 18:23:55 GMT放在响应头中返回给浏览器 第二次请求时，浏览器就会把上一次服务器返回的修改时间放在请求头If-Modified-Since:Thu, 29 Dec 2011 18:23:55发送给服务器，服务器就会拿这个时间跟服务器上的资源的最新修改时间进行对比 如果两者相等或者大于服务器上的最新修改时间，那么表示浏览器的缓存是有效的，此时缓存会命中，服务器就不再返回内容给浏览器了，同时Last-Modified头也不会返回，因为资源没被修改，返回了也没什么意义。如果没命中缓存则最新修改的资源连同Last-Modified头一起返回 # 第一次请求返回的响应头 Cache-Control:max-age=3600 Expires: Fri, Jan 12 2018 00:27:04 GMT Last-Modified: Wed, Jan 10 2018 00:27:04 GMT # 第二次请求的请求头信息 If-Modified-Since: Wed, Jan 10 2018 00:27:04 GMT 这组头信息是基于资源的修改时间来判断资源有没有更新，另一种方式就是根据资源的内容来判断，就是接下来要讨论的 ETag 与 If-None-Match ETag与If-None-Match ETag/If-None-Match与Last-Modified/If-Modified-Since的流程其实是类似的，唯一的区别是它基于资源的内容的摘要信息（比如MD5 hash）来判断 浏览器发送第二次请求时，会把第一次的响应头信息ETag的值放在If-None-Match的请求头中发送到服务器，与最新的资源的摘要信息对比，如果相等，取浏览器缓存，否则内容有更新，最新的资源连同最新的摘要信息返回。用ETag的好处是如果因为某种原因到时资源的修改时间没改变，那么用ETag就能区分资源是不是有被更新。 # 第一次请求返回的响应头： Cache-Control: public, max-age=31536000 ETag: \"15f0fff99ed5aae4edffdd6496d7131f\" # 第二次请求的请求头信息： If-None-Match: \"15f0fff99ed5aae4edffdd6496d7131f\" 5.4 cookie 和 session session： 是一个抽象概念，开发者为了实现中断和继续等操作，将 user agent和 server 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念 cookie：它是一个世纪存在的东西，http 协议中定义在 header 中的字段，可以认为是 session 的一种后端无状态实现 现在我们常说的 session，是为了绕开 cookie 的各种限制，通常借助 cookie本身和后端存储实现的，一种更高级的会话状态实现 session 的常见实现要借助cookie来发送 sessionID 5.5 安全问题，如 XSS 和 CSRF XSS：跨站脚本攻击，是一种网站应用程序的安全漏洞攻击，是代码注入的一种。常见方式是将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动 防范：记住一点 “所有用户输入都是不可信的”，所以得做输入过滤和转义 CSRF：跨站请求伪造，也称 XSRF，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。与 XSS 相比，XSS利用的是用户对指定网站的信任，CSRF利用的是网站对用户网页浏览器的信任。 防范：用户操作验证（验证码），额外验证机制（token使用）等","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"简版篇","slug":"简版篇","permalink":"http://www.chenya.site/tags/简版篇/"},{"name":"网络","slug":"网络","permalink":"http://www.chenya.site/tags/网络/"}]},{"title":"简版篇-04.框架相关知识","slug":"002.前端知识体系/006.精简篇/004.简版篇之框架相关知识","date":"2017-07-02T12:15:19.000Z","updated":"2019-09-16T01:57:01.494Z","comments":true,"path":"2017/07/02/002.前端知识体系/006.精简篇/004.简版篇之框架相关知识/","link":"","permalink":"http://www.chenya.site/2017/07/02/002.前端知识体系/006.精简篇/004.简版篇之框架相关知识/","excerpt":"","text":"四、框架相关4.1 数据双向绑定原理：常见数据绑定的方案 Object.defineProperty（vue）：劫持数据的 getter 和 setter 脏值检测（angularjs）：通过特定事件进行轮循发布/订阅模式：通过消息发布并将消息进行订阅 4.2 VDOM：三个 part 虚拟节点类，将真实 DOM节点用 js 对象的形式进行展示，并提供 render 方法，将虚拟节点渲染成真实 DOM 节点 diff 比较：对虚拟节点进行 js 层面的计算，并将不同的操作都记录到 patch 对象 re-render：解析 patch 对象，进行 re-render 补充1：VDOM 的必要性？ 创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。 触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流。 补充2：vue 为什么采用 vdom？ 引入 Virtual DOM 在性能方面的考量仅仅是一方面。 性能受场景的影响是非常大的，不同的场景可能造成不同实现方案之间成倍的性能差距，所以依赖细粒度绑定及 Virtual DOM 哪个的性能更好还真不是一个容易下定论的问题。 Vue 之所以引入了 Virtual DOM，更重要的原因是为了解耦 HTML依赖，这带来两个非常重要的好处是： 不再依赖 HTML 解析器进行模版解析，可以进行更多的 AOT 工作提高运行时效率：通过模版 AOT 编译，Vue 的运行时体积可以进一步压缩，运行时效率可以进一步提升； 可以渲染到 DOM 以外的平台，实现 SSR、同构渲染这些高级特性，Weex等框架应用的就是这一特性。 综上，Virtual DOM 在性能上的收益并不是最主要的，更重要的是它使得 Vue 具备了现代框架应有的高级特性。 4.3 vue 和 react 区别 相同点：都支持 ssr，都有 vdom，组件化开发，实现 webComponents 规范，数据驱动等 不同点：vue 是双向数据流（当然为了实现单数据流方便管理组件状态，vuex 便出现了），react 是单向数据流。vue的 vdom 是追踪每个组件的依赖关系，不会渲染整个组件树，react 每当应该状态被改变时，全部子组件都会 re-render 4.4 为什么用 vue 简洁、轻快、舒服","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"简版篇","slug":"简版篇","permalink":"http://www.chenya.site/tags/简版篇/"},{"name":"框架","slug":"框架","permalink":"http://www.chenya.site/tags/框架/"}]},{"title":"简版篇-03.JS基础（ES6）知识","slug":"002.前端知识体系/006.精简篇/003.简版篇之JS基础（ES6）知识","date":"2017-06-26T15:16:37.000Z","updated":"2019-09-16T01:57:01.494Z","comments":true,"path":"2017/06/26/002.前端知识体系/006.精简篇/003.简版篇之JS基础（ES6）知识/","link":"","permalink":"http://www.chenya.site/2017/06/26/002.前端知识体系/006.精简篇/003.简版篇之JS基础（ES6）知识/","excerpt":"","text":"三、JS 基础（ES6）3.1 let，const let 产生块级作用域（通常配合 for 循环或者 {} 进行使用产生块级作用域），const 申明的变量是常量（内存地址不变） 3.2 Promise 这里你谈 promise的时候，除了将他解决的痛点以及常用的 API 之外，最好进行拓展把 eventloop 带进来好好讲一下，microtask(微任务)、macrotask(任务) 的执行顺序，如果看过 promise 源码，最好可以谈一谈 原生 Promise 是如何实现的。Promise 的关键点在于callback 的两个参数，一个是 resovle，一个是 reject。还有就是 Promise 的链式调用（Promise.then()，每一个 then 都是一个责任人） 3.3 Generator 遍历器对象生成函数，最大的特点是可以交出函数的执行权 function 关键字与函数名之间有一个星号； 函数体内部使用 yield表达式，定义不同的内部状态； next指针移向下一个状态 这里你可以说说 Generator的异步编程，以及它的语法糖 async 和 awiat，传统的异步编程。ES6 之前，异步编程大致如下 回调函数 事件监听 发布/订阅 传统异步编程方案之一：协程，多个线程互相协作，完成异步任务。 3.4 async、await Generator 函数的语法糖。有更好的语义、更好的适用性、返回值是 Promise。 async =&gt; * await =&gt; yield // 基本用法 async function timeout (ms) { await new Promise((resolve) => { setTimeout(resolve, ms) }) } async function asyncConsole (value, ms) { await timeout(ms) console.log(value) } asyncConsole('hello async and await', 1000) 注：最好把2，3，4 连到一起讲 3.5 AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点 AMD：requirejs 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置 CMD：seajs 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近 CommonJs：模块输出的是一个值的 copy，运行时加载，加载的是一个对象（module.exports 属性），该对象只有在脚本运行完才会生成 ES6 Module：模块输出的是一个值的引用，编译时输出接口，ES6模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"简版篇","slug":"简版篇","permalink":"http://www.chenya.site/tags/简版篇/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenya.site/tags/JavaScript/"}]},{"title":"简版篇-02.JS基础（ES5）知识","slug":"002.前端知识体系/006.精简篇/002.简版篇之JS基础（ES5）知识","date":"2017-06-18T11:35:21.000Z","updated":"2019-09-16T01:57:01.494Z","comments":true,"path":"2017/06/18/002.前端知识体系/006.精简篇/002.简版篇之JS基础（ES5）知识/","link":"","permalink":"http://www.chenya.site/2017/06/18/002.前端知识体系/006.精简篇/002.简版篇之JS基础（ES5）知识/","excerpt":"","text":"二、JS 基础（ES5）2.1 原型 这里可以谈很多，只要围绕 [[ prototype ]] 谈，都没啥问题 2.2 闭包 牵扯作用域，可以两者联系起来一起谈 2.3 作用域 词法作用域，动态作用域 2.4 this 不同情况的调用，this指向分别如何。顺带可以提一下 es6 中箭头函数没有 this, arguments, super 等，这些只依赖包含箭头函数最接近的函数 2.5 call，apply，bind 三者用法和区别 参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（call，apply 立即执行，bind 是return 出一个 this “固定”的函数，这也是为什么 bind 是强绑定的一个原因） 注：“固定”这个词的含义，它指的固定是指只要传进去了 context，则 bind 中 return 出来的函数 this 便一直指向 context，除非 context 是个变量 2.6 变量声明提升 js 代码在运行前都会进行 AST 解析，函数申明默认会提到当前作用域最前面，变量申明也会进行提升。但赋值不会得到提升。关于 AST 解析，这里也可以说是形成词法作用域的主要原因","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"简版篇","slug":"简版篇","permalink":"http://www.chenya.site/tags/简版篇/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenya.site/tags/JavaScript/"}]},{"title":"简版篇-01.CSS相关知识","slug":"002.前端知识体系/006.精简篇/001.简版篇之CSS相关知识","date":"2017-06-12T15:12:47.000Z","updated":"2019-09-16T01:57:01.494Z","comments":true,"path":"2017/06/12/002.前端知识体系/006.精简篇/001.简版篇之CSS相关知识/","link":"","permalink":"http://www.chenya.site/2017/06/12/002.前端知识体系/006.精简篇/001.简版篇之CSS相关知识/","excerpt":"","text":"一、CSS相关1.1 左边定宽，右边自适应方案：float + margin，float + calc/* 方案1 */ .left { width: 120px; float: left; } .right { margin-left: 120px; } /* 方案2 */ .left { width: 120px; float: left; } .right { width: calc(100% - 120px); float: left; } 1.2 左右两边定宽，中间自适应：float，float + calc, 圣杯布局（设置BFC，margin负值法），flex.wrap { width: 100%; height: 200px; } .wrap > div { height: 100%; } /* 方案1 */ .left { width: 120px; float: left; } .right { float: right; width: 120px; } .center { margin: 0 120px; } /* 方案2 */ .left { width: 120px; float: left; } .right { float: right; width: 120px; } .center { width: calc(100% - 240px); margin-left: 120px; } /* 方案3 */ .wrap { display: flex; } .left { width: 120px; } .right { width: 120px; } .center { flex: 1; } 1.3 左右居中 行内元素: text-align: center 定宽块状元素: 左右 margin 值为 auto 不定宽块状元素: table布局，position + transform /* 方案1 */ .wrap { text-align: center } .center { display: inline; /* or */ /* display: inline-block; */ } /* 方案2 */ .center { width: 100px; margin: 0 auto; } /* 方案2 */ .wrap { position: relative; } .center { position: absulote; left: 50%; transform: translateX(-50%); } 1.4 上下垂直居中 定高：margin，position + margin(负值) 不定高：position + transform，flex，IFC + vertical-align:middle /* 定高方案1 */ .center { height: 100px; margin: 50px 0; } /* 定高方案2 */ .center { height: 100px; position: absolute; top: 50%; margin-top: -25px; } /* 不定高方案1 */ .center { position: absolute; top: 50%; transform: translateY(-50%); } /* 不定高方案2 */ .wrap { display: flex; align-items: center; } .center { width: 100%; } /* 不定高方案3 */ /* 设置 inline-block 则会在外层产生 IFC，高度设为 100% 撑开 wrap 的高度 */ .wrap::before { content: ''; height: 100%; display: inline-block; vertical-align: middle; } .wrap { text-align: center; } .center { display: inline-block; vertical-align: middle; } 1.5 盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距） 延伸： box-sizing content-box：默认值，总宽度 = margin + border + padding + width border-box：盒子宽度包含 padding 和 border，总宽度 = margin + width inherit：从父元素继承 box-sizing 属性 1.6 BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文 BFC：块级格式化上下文，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此(按照这个理念来想，只要脱离文档流，肯定就能产生 BFC)。产生 BFC 方式如下 float 的值不为 none。 overflow 的值不为 visible。 position 的值不为 relative 和 static。 display 的值为 table-cell, table-caption, inline-block中的任何一个 用处？常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行 IFC：内联格式化上下文，IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)。 IFC中的line box一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与 line box 之间，使得 line box 宽度缩短。 同个 ifc 下的多个 line box 高度会不同。 IFC中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个匿名块与 div 分隔开，即产生两个 IFC ，每个 IFC 对外表现为块级元素，与 div 垂直排列。 用处？ 水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生IFC，通过 text-align 则可以使其水平居中。 垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align: middle，其他行内元素则可以在此父元素下垂直居中 GFC：网格布局格式化上下文（display: grid） FFC：自适应格式化上下文（display: flex）","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"简版篇","slug":"简版篇","permalink":"http://www.chenya.site/tags/简版篇/"},{"name":"CSS","slug":"CSS","permalink":"http://www.chenya.site/tags/CSS/"}]},{"title":"精华篇-01.高频考点知识","slug":"002.前端知识体系/005.精华篇/001.精华篇之高频考点知识","date":"2017-06-04T14:52:06.000Z","updated":"2019-09-16T01:57:01.494Z","comments":true,"path":"2017/06/04/002.前端知识体系/005.精华篇/001.精华篇之高频考点知识/","link":"","permalink":"http://www.chenya.site/2017/06/04/002.前端知识体系/005.精华篇/001.精华篇之高频考点知识/","excerpt":"","text":"1 typeof类型判断 typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么 typeof 对于原始类型来说，除了 null 都可以显示正确的类型 typeof 1 // 'number' typeof '1' // 'string' typeof undefined // 'undefined' typeof true // 'boolean' typeof Symbol() // 'symbol' typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型 typeof [] // 'object' typeof {} // 'object' typeof console.log // 'function' 如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的 const Person = function() {} const p1 = new Person() p1 instanceof Person // true var str = 'hello world' str instanceof String // false var str1 = new String('hello world') str1 instanceof String // true 对于原始类型来说，你想直接通过 instanceof来判断类型是不行的 2 类型转换 首先我们要知道，在 JS 中类型转换只有三种情况，分别是： 转换为布尔值 转换为数字 转换为字符串 image.png 转Boolean 在条件判断时，除了 undefined，null， false， NaN， &#39;&#39;， 0， -0，其他所有值都转为 true，包括所有对象 对象转原始类型 对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下 如果已经是原始类型了，那就不需要转换了 调用 x.valueOf()，如果转换为基础类型，就返回转换的值 调用 x.toString()，如果转换为基础类型，就返回转换的值 如果都没有返回原始类型，就会报错 当然你也可以重写 Symbol.toPrimitive，该方法在转原始类型时调用优先级最高。 let a = { valueOf() { return 0 }, toString() { return '1' }, [Symbol.toPrimitive]() { return 2 } } 1 + a // => 3 四则运算符 它有以下几个特点： 运算中其中一方为字符串，那么就会把另一方也转换为字符串 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串 1 + '1' // '11' true + true // 2 4 + [1,2,3] // \"41,2,3\" 对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 &#39;11&#39; 对于第二行代码来说，触发特点二，所以将 true 转为数字 1 对于第三行代码来说，触发特点二，所以将数组通过 toString转为字符串 1,2,3，得到结果 41,2,3 另外对于加法还需要注意这个表达式 &#39;a&#39; + + &#39;b&#39; &#39;a&#39; + + &#39;b&#39; // -&gt; &quot;aNaN&quot; 因为 + &#39;b&#39; 等于 NaN，所以结果为 &quot;aNaN&quot;，你可能也会在一些代码中看到过 + &#39;1&#39;的形式来快速获取 number 类型。 那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字 4 * '3' // 12 4 * [] // 0 4 * [1, 2] // NaN 比较运算符 如果是对象，就通过 toPrimitive 转换对象 如果是字符串，就通过 unicode 字符索引来比较 let a = { valueOf() { return 0 }, toString() { return '1' } } a > -1 // true 在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。 3 This 我们先来看几个函数调用的场景 function foo() { console.log(this.a) } var a = 1 foo() const obj = { a: 2, foo: foo } obj.foo() const c = new foo() 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是window 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象 对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this 说完了以上几种情况，其实很多代码中的 this 应该就没什么问题了，下面让我们看看箭头函数中的 this function a() { return () => { return () => { console.log(this) } } } console.log(a()()()) 首先箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外对箭头函数使用 bind这类函数是无效的。 最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。 那么说到 bind，不知道大家是否考虑过，如果对一个函数进行多次 bind，那么上下文会是什么呢？ let a = {} let fn = function () { console.log(this) } fn.bind().bind(a)() // => ? 如果你认为输出结果是 a，那么你就错了，其实我们可以把上述代码转换成另一种形式 // fn.bind().bind(a) 等于 let fn2 = function fn1() { return function() { return fn.apply() }.apply(a) } fn2() 可以从上述代码中发现，不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window let a = { name: 'poetries' } function foo() { console.log(this.name) } foo.bind(a)() // => 'poetries' 以上就是 this 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 this 最终指向哪里。 首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。 image.png 4 == 和 === 有什么区别 对于 == 来说，如果对比双方的类型不一样的话，就会进行类型转换 假如我们需要对比 x 和 y 是否相同，就会进行如下判断流程 首先会判断两者类型是否相同。相同的话就是比大小了 类型不相同的话，那么就会进行类型转换 会先判断是否在对比 null 和 undefined，是的话就会返回 true 判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number 1 == &#39;1&#39; ↓ 1 == 1 判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断 &#39;1&#39; == true ↓ &#39;1&#39; == 1 ↓ 1 == 1 判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断 &#39;1&#39; == { name: &#39;yck&#39; } ↓ &#39;1&#39; == &#39;[object Object]&#39; image.png 对于 === 来说就简单多了，就是判断两者类型和值是否相同 5 闭包 闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包 function A() { let a = 1 window.B = function () { console.log(a) } } A() B() // 1 闭包存在的意义就是让我们可以间接访问函数内部的变量 经典面试题，循环中使用闭包解决 var 定义函数的问题 for (var i = 1; i &lt;= 5; i++) { setTimeout(function timer() { console.log(i) }, i * 1000) } 首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i就是 6 了，所以会输出一堆 6 解决办法有三种 第一种是使用闭包的方式 for (var i = 1; i &lt;= 5; i++) { ;(function(j) { setTimeout(function timer() { console.log(j) }, j * 1000) })(i) } 在上述代码中，我们首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的 第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入 for (var i = 1; i &lt;= 5; i++) { setTimeout( function timer(j) { console.log(j) }, i * 1000, i ) } 第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式 for (let i = 1; i &lt;= 5; i++) { setTimeout(function timer() { console.log(i) }, i * 1000) } 6 深浅拷贝浅拷贝 首先可以通过 Object.assign 来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是，Object.assign 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝 let a = { age: 1 } let b = Object.assign({}, a) a.age = 2 console.log(b.age) // 1 另外我们还可以通过展开运算符 ... 来实现浅拷贝 let a = { age: 1 } let b = { ...a } a.age = 2 console.log(b.age) // 1 通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了 let a = { age: 1, jobs: { first: 'FE' } } let b = { ...a } a.jobs.first = 'native' console.log(b.jobs.first) // native 浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。 深拷贝 这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。 let a = { age: 1, jobs: { first: 'FE' } } let b = JSON.parse(JSON.stringify(a)) a.jobs.first = 'native' console.log(b.jobs.first) // FE 但是该方法也是有局限性的： 会忽略 undefined 会忽略 symbol 不能序列化函数 不能解决循环引用的对象 let obj = { a: 1, b: { c: 2, d: 3, }, } obj.c = obj.b obj.e = obj.a obj.b.c = obj.c obj.b.d = obj.b obj.b.e = obj.b.c let newObj = JSON.parse(JSON.stringify(obj)) console.log(newObj) 更多详情 https://www.jianshu.com/p/2d8a26b3958f 7 原型 原型链就是多个对象通过 __proto__ 的方式连接了起来。为什么 obj 可以访问到 valueOf 函数，就是因为 obj 通过原型链找到了 valueOf 函数 Object 是所有对象的爸爸，所有对象都可以通过 __proto__找到它 Function 是所有函数的爸爸，所有函数都可以通过 __proto__ 找到它 函数的 prototype 是一个对象 对象的__proto__ 属性指向原型， __proto__ 将对象和原型连接起来组成了原型链 8 var、let 及 const 区别 涉及面试题：什么是提升？什么是暂时性死区？var、let 及 const 区别？ 函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部 var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用 var 在全局作用域下声明变量会导致变量挂载在 window上，其他两者不会 let 和 const 作用基本一致，但是后者声明的变量不能再次赋值 9 原型继承和 Class 继承 涉及面试题：原型如何实现继承？Class 如何实现继承？Class 本质是什么？ 首先先来讲下 class，其实在 JS中并不存在类，class 只是语法糖，本质还是函数 class Person {} Person instanceof Function // true 组合继承 组合继承是最常用的继承方式 function Parent(value) { this.val = value } Parent.prototype.getValue = function() { console.log(this.val) } function Child(value) { Parent.call(this, value) } Child.prototype = new Parent() const child = new Child(1) child.getValue() // 1 child instanceof Parent // true 以上继承的方式核心是在子类的构造函数中通过 Parent.call(this) 继承父类的属性，然后改变子类的原型为 new Parent() 来继承父类的函数。 这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费 寄生组合继承 这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了 function Parent(value) { this.val = value } Parent.prototype.getValue = function() { console.log(this.val) } function Child(value) { Parent.call(this, value) } Child.prototype = Object.create(Parent.prototype, { constructor: { value: Child, enumerable: false, writable: true, configurable: true } }) const child = new Child(1) child.getValue() // 1 child instanceof Parent // true 以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。 Class 继承 以上两种继承方式都是通过原型去解决的，在 ES6 中，我们可以使用 class 去实现继承，并且实现起来很简单 class Parent { constructor(value) { this.val = value } getValue() { console.log(this.val) } } class Child extends Parent { constructor(value) { super(value) this.val = value } } let child = new Child(1) child.getValue() // 1 child instanceof Parent // true class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。 10 模块化 涉及面试题：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？ 使用一个技术肯定是有原因的，那么使用模块化可以给我们带来以下好处 解决命名冲突 提供复用性 提高代码可维护性 立即执行函数 在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题 (function(globalVariable){ globalVariable.test = function() {} // ... 声明各种变量、函数都不会污染全局作用域 })(globalVariable) AMD 和 CMD 鉴于目前这两种实现方式已经很少见到，所以不再对具体特性细聊，只需要了解这两者是如何使用的。 // AMD define(['./a', './b'], function(a, b) { // 加载模块完毕可以使用 a.do() b.do() }) // CMD define(function(require, exports, module) { // 加载模块 // 可以把 require 写在函数体的任意地方实现延迟加载 var a = require('./a') a.doSomething() }) CommonJS CommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS有一些区别了 // a.js module.exports = { a: 1 } // or exports.a = 1 // b.js var module = require('./a.js') module.a // -> log 1 ar module = require('./a.js') module.a // 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了， // 重要的是 module 这里，module 是 Node 独有的一个变量 module.exports = { a: 1 } // module 基本实现 var module = { id: 'xxxx', // 我总得知道怎么去找到他吧 exports: {} // exports 就是个空对象 } // 这个是为什么 exports 和 module.exports 用法相似的原因 var exports = module.exports var load = function (module) { // 导出的东西 var a = 1 module.exports = a return module.exports }; // 然后当我 require 的时候去找到独特的 // id，然后将要使用的东西用立即执行函数包装下，over 另外虽然 exports 和 module.exports 用法相似，但是不能对 exports 直接赋值。因为 var exports = module.exports 这句代码表明了 exports 和 module.exports享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 exports 赋值就会导致两者不再指向同一个内存地址，修改并不会对 module.exports 起效 ES Module ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别 CommonJS 支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案 CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响 CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化 ES Module 会编译成 require/exports来执行的 // 引入模块 API import XXX from './a.js' import { XXX } from './a.js' // 导出模块 API export function a() {} export default function() {} 11 实现一个简洁版的promise// 三个常量用于表示状态 const PENDING = 'pending' const RESOLVED = 'resolved' const REJECTED = 'rejected' function MyPromise(fn) { const that = this this.state = PENDING // value 变量用于保存 resolve 或者 reject 中传入的值 this.value = null // 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用 that.resolvedCallbacks = [] that.rejectedCallbacks = [] function resolve(value) { // 首先两个函数都得判断当前状态是否为等待中 if(that.state === PENDING) { that.state = RESOLVED that.value = value // 遍历回调数组并执行 that.resolvedCallbacks.map(cb=>cb(that.value)) } } function reject(value) { if(that.state === PENDING) { that.state = REJECTED that.value = value that.rejectedCallbacks.map(cb=>cb(that.value)) } } // 完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了 try { fn(resolve,reject) }cach(e){ reject(e) } } // 最后我们来实现较为复杂的 then 函数 MyPromise.prototype.then = function(onFulfilled,onRejected){ const that = this // 判断两个参数是否为函数类型，因为这两个参数是可选参数 onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v=>v onRejected = typeof onRejected === 'function' ? onRejected : e=>throw e // 当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数 if(this.state === PENDING) { this.resolvedCallbacks.push(onFulfilled) this.rejectedCallbacks.push(onRejected) } if(this.state === RESOLVED) { onFulfilled(that.value) } if(this.state === REJECTED) { onRejected(that.value) } } 12 Event Loop12.1 进程与线程 涉及面试题：进程与线程区别？JS 单线程带来的好处？ JS 是单线程执行的，但是你是否疑惑过什么是线程？ 讲到线程，那么肯定也得说一下进程。本质上来说，两个名词都是 CPU 工作时间片的一个描述。 进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间 把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁 上文说到了 JS 引擎线程和渲染线程，大家应该都知道，在 JS 运行的时候可能会阻止 UI 渲染，这说明了两个线程是互斥的。这其中的原因是因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。这其实也是一个单线程的好处，得益于 JS 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处 12.2 执行栈 涉及面试题：什么是执行栈？ 可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则 当开始执行 JS 代码时，首先会执行一个 main 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，在图中我们也可以发现，foo 函数后执行，当执行完毕后就从栈中弹出了 在开发中，大家也可以在报错中找到执行栈的痕迹 function foo() { throw new Error('error') } function bar() { foo() } bar() 大家可以在上图清晰的看到报错在 foo 函数，foo 函数又是在 bar 函数中调用的 当我们使用递归的时候，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题 function bar() { bar() } bar() 12.3 浏览器中的 Event Loop 涉及面试题：异步代码执行顺序？解释一下什么是 Event Loop ？ 众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点） JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为 console.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); console.log('script end'); 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task console.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); new Promise((resolve) => { console.log('Promise') resolve() }).then(function() { console.log('promise1'); }).then(function() { console.log('promise2'); }); console.log('script end'); // script start => Promise => script end => promise1 => promise2 => setTimeout 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务 微任务 process.nextTick promise Object.observe MutationObserver 宏任务 script setTimeout setInterval setImmediate I/O UI rendering 宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务 所以正确的一次 Event loop 顺序是这样的 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的响应界面响应，我们可以把操作 DOM 放入微任务中 12.4 Node 中的 Event loop Node 中的 Event loop 和浏览器中的不相同。 Node 的 Event loop 分为6个阶段，它们会按照顺序反复运行 ┌───────────────────────┐ ┌─&gt;│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │&lt;──connections─── │ │ └──────────┬────────────┘ │ data, etc. │ │ ┌──────────┴────────────┐ └───────────────┘ │ │ check │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ └──┤ close callbacks │ └───────────────────────┘ timer timers 阶段会执行 setTimeout 和 setInterval 一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟 I/O I/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调 poll poll 阶段很重要，这一阶段中，系统会做两件事情 执行到点的定时器 执行 poll 队列中的事件 并且当 poll 中没有定时器的情况下，会发现以下两件事情 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制 如果 poll 队列为空，会有两件事发生 如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate 如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调 如果有别的定时器需要被执行，会回到 timer 阶段执行回调。 check check 阶段执行 setImmediate close callbacks close callbacks 阶段执行 close 事件 并且在 Node 中，有些情况下的定时器执行顺序是随机的 setTimeout(() => { console.log('setTimeout'); }, 0); setImmediate(() => { console.log('setImmediate'); }) // 这里可能会输出 setTimeout，setImmediate // 可能也会相反的输出，这取决于性能 // 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate // 否则会执行 setTimeout 上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行 setTimeout(()=>{ console.log('timer1') Promise.resolve().then(function() { console.log('promise1') }) }, 0) setTimeout(()=>{ console.log('timer2') Promise.resolve().then(function() { console.log('promise2') }) }, 0) // 以上代码在浏览器和 node 中打印情况是不同的 // 浏览器中一定打印 timer1, promise1, timer2, promise2 // node 中可能打印 timer1, timer2, promise1, promise2 // 也可能打印 timer1, promise1, timer2, promise2 Node 中的 process.nextTick 会先于其他 microtask 执行 setTimeout(() => { console.log(\"timer1\"); Promise.resolve().then(function() { console.log(\"promise1\"); }); }, 0); process.nextTick(() => { console.log(\"nextTick\"); }); // nextTick, timer1, promise1 对于 microtask 来说，它会在以上每个阶段完成前清空 microtask 队列，下图中的 Tick 就代表了 microtask 13 手写 call、apply 及 bind 函数 首先从以下几点来考虑如何实现这几个函数 不传入第一个参数，那么上下文默认为 window 改变了 this 指向，让新的对象可以执行该函数，并能接受参数 实现 call 首先 context为可选参数，如果不传的话默认上下文为 window 接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数 因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来 然后调用函数并将对象上的函数删除 Function.prototype.myCall = function(context) { if (typeof this !== 'function') { throw new TypeError('Error') } context = context || window context.fn = this const args = [...arguments].slice(1) const result = context.fn(...args) delete context.fn return result } apply实现 apply 的实现也类似，区别在于对参数的处理 Function.prototype.myApply = function(context) { if (typeof this !== 'function') { throw new TypeError('Error') } context = context || window context.fn = this let result // 处理参数和 call 有区别 if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } bind 的实现 bind 的实现对比其他两个函数略微地复杂了一点，因为 bind 需要返回一个函数，需要判断一些边界问题，以下是 bind 的实现 bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式，我们先来说直接调用的方式 对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2)，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(...arguments) 最后来说通过 new 的方式，在之前的章节中我们学习过如何判断 this，对于 new 的情况来说，不会被任何方式改变 this，所以对于这种情况我们需要忽略传入的 this Function.prototype.myBind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } const _this = this const args = [...arguments].slice(1) // 返回一个函数 return function F() { // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) { return new _this(...args, ...arguments) } return _this.apply(context, args.concat(...arguments)) } } 14 new 涉及面试题：new 的原理是什么？通过 new的方式创建对象和通过字面量创建有什么区别？ 在调用 new 的过程中会发生四件事情 新生成了一个对象 链接到原型 绑定 this 返回新对象 根据以上几个过程，我们也可以试着来自己实现一个 new 创建一个空对象 获取构造函数 设置空对象的原型 绑定 this 并执行构造函数 确保返回值为对象 function create() { let obj = {} let Con = [].shift.call(arguments) obj.__proto__ = Con.prototype let result = Con.apply(obj, arguments) return result instanceof Object ? result : obj } 对于对象来说，其实都是通过 new 产生的，无论是 function Foo() 还是 let a = { b : 1 }。 对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题 function Foo() {} // function 就是个语法糖 // 内部等同于 new Function() let a = { b: 1 } // 这个字面量内部也是使用了 new Object() 15 instanceof 的原理 涉及面试题：instanceof 的原理是什么？ instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype 实现一下 instanceof 首先获取类型的原型 然后获得对象的原型 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null function myInstanceof(left, right) { let prototype = right.prototype left = left.__proto__ while (true) { if (left === null || left === undefined) return false if (prototype === left) return true left = left.__proto__ } } 16 为什么 0.1 + 0.2 != 0.3 涉及面试题：为什么 0.1 + 0.2 != 0.3？如何解决这个问题？ 原因，因为 JS 采用 IEEE 754双精度版本（64位），并且只要采用 IEEE 754的语言都有该问题 我们都知道计算机是通过二进制来存储东西的，那么 0.1 在二进制中会表示为 // (0011) 表示循环 0.1 = 2^-4 * 1.10011(0011) 我们可以发现，0.1 在二进制中是无限循环的一些数字，其实不只是 0.1，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 JS采用的浮点数标准却会裁剪掉我们的数字。 IEEE 754 双精度版本（64位）将 64 位分为了三段 第一位用来表示符号 接下去的 11 位用来表示指数 其他的位数用来表示有效位，也就是用二进制表示 0.1 中的 10011(0011) 那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 0.1 不再是 0.1 了，而是变成了 0.100000000000000002 0.100000000000000002 === 0.1 // true 那么同样的，0.2 在二进制也是无限循环的，被裁剪后也失去了精度变成了 0.200000000000000002 0.200000000000000002 === 0.2 // true 所以这两者相加不等于 0.3 而是 0.300000000000000004 0.1 + 0.2 === 0.30000000000000004 // true 那么可能你又会有一个疑问，既然 0.1 不是 0.1，那为什么 console.log(0.1) 却是正确的呢？ 因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证 console.log(0.100000000000000002) // 0.1 解决 parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true 17 事件机制 涉及面试题：事件的触发过程是怎么样的？知道什么是事件代理嘛？ 17.1 事件触发三阶段事件触发有三个阶段： window往事件触发处传播，遇到注册的捕获事件会触发 传播到事件触发处时触发注册的事件 从事件触发处往 window 传播，遇到注册的冒泡事件会触发 事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行 // 以下会先打印冒泡然后是捕获 node.addEventListener( 'click', event => { console.log('冒泡') }, false ) node.addEventListener( 'click', event => { console.log('捕获 ') }, true ) 17.2 注册事件 通常我们使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false ，useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性 capture：布尔值，和 useCapture 作用一样 once：布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听 passive：布尔值，表示永远不会调用 preventDefault 一般来说，如果我们只希望事件只触发在目标上，这时候可以使用 stopPropagation来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。 node.addEventListener( 'click', event => { event.stopImmediatePropagation() console.log('冒泡') }, false ) // 点击 node 只会执行上面的函数，该函数不会执行 node.addEventListener( 'click', event => { console.log('捕获 ') }, true ) 17.3 事件代理 如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上 &lt;ul id=\"ul\"> &lt;li>1&lt;/li> &lt;li>2&lt;/li> &lt;li>3&lt;/li> &lt;li>4&lt;/li> &lt;li>5&lt;/li> &lt;/ul> &lt;script> let ul = document.querySelector('#ul') ul.addEventListener('click', (event) => { console.log(event.target); }) &lt;/script> 事件代理的方式相较于直接给目标注册事件来说，有以下优点： 节省内存 不需要给子节点注销事件 18 跨域 涉及面试题：什么是跨域？为什么浏览器要使用同源策略？你有几种方式可以解决跨域问题？了解预检请求嘛？ 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。 那么是出于什么安全考虑才会引入这种机制呢？ 其实主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。 也就是说，没有同源策略的情况下，A 网站可以被任意其他来源的 Ajax 访问到内容。如果你当前 A 网站还存在登录态，那么对方就可以通过 Ajax 获得你的任何信息。当然跨域并不能完全阻止 CSRF。 然后我们来考虑一个问题，请求跨域了，那么请求到底发出去没有？ 请求必然是发出去了，但是浏览器拦截了响应。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax就不会。因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。 接下来我们将来学习几种常见的方式来解决跨域的问题 18.1 JSONP JSONP 的原理很简单，就是利用 &lt;script&gt; 标签没有跨域限制的漏洞。通过 &lt;script&gt;标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时 &lt;script src=\"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp\">&lt;/script> &lt;script> function jsonp(data) { console.log(data) } &lt;/script> JSONP 使用简单且兼容性不错，但是只限于 get 请求。 在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP，以下是简单实现 function jsonp(url, jsonpCallback, success) { let script = document.createElement('script') script.src = url script.async = true script.type = 'text/javascript' window[jsonpCallback] = function(data) { success &amp;&amp; success(data) } document.body.appendChild(script) } jsonp('http://xxx', 'callback', function(value) { console.log(value) }) 18.2 CORS CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。 浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。虽然设置 CORS和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。 简单请求 以 Ajax 为例，当满足以下条件时，会触发简单请求 使用下列方法之一： GET HEAD POST Content-Type 的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问 复杂请求 对于复杂请求来说，首先会发起一个预检请求，该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。 对于预检请求来说，如果你使用过 Node 来设置 CORS 的话，可能会遇到过这么一个坑。 以下以 express框架举例 app.use((req, res, next) => { res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Allow-Methods', 'PUT, GET, POST, DELETE, OPTIONS') res.header( 'Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials' ) next() }) 该请求会验证你的 Authorization 字段，没有的话就会报错。 当前端发起了复杂请求后，你会发现就算你代码是正确的，返回结果也永远是报错的。因为预检请求也会进入回调中，也会触发 next 方法，因为预检请求并不包含 Authorization 字段，所以服务端会报错。 想解决这个问题很简单，只需要在回调中过滤 option 方法即可 res.statusCode = 204 res.setHeader('Content-Length', '0') res.end() 18.3 document.domain 该方式只能用于主域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain = &#39;test.com&#39; 表示主域名都相同就可以实现跨域 18.4 postMessage 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息 // 发送消息端 window.parent.postMessage('message', 'http://test.com') // 接收消息端 var mc = new MessageChannel() mc.addEventListener('message', event => { var origin = event.origin || event.originalEvent.origin if (origin === 'http://test.com') { console.log('验证通过') } }) 19 存储 涉及面试题：有几种方式可以实现存储功能，分别有什么优缺点？什么是 Service Worker？ cookie，localStorage，sessionStorage，indexDB 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在 header 中，对于请求性能影响 不参与 不参与 不参与 从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage存储 对于 cookie 来说，我们还需要注意安全性。 属性 作用 value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 Service Worker Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现： // index.js if (navigator.serviceWorker) { navigator.serviceWorker .register('sw.js') .then(function(registration) { console.log('service worker 注册成功') }) .catch(function(err) { console.log('servcie worker 注册失败') }) } // sw.js // 监听 `install` 事件，回调中缓存所需文件 self.addEventListener('install', e => { e.waitUntil( caches.open('my-cache').then(function(cache) { return cache.addAll(['./index.html', './index.js']) }) ) }) // 拦截所有请求事件 // 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据 self.addEventListener('fetch', e => { e.respondWith( caches.match(e.request).then(function(response) { if (response) { return response } console.log('fetch source') }) ) }) 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了 在 Cache 中也可以发现我们所需的文件已被缓存 当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的 20 浏览器缓存机制 注意：该知识点属于性能优化领域，并且整一章节都是一个面试题 缓存可以说是性能优化中简单高效的一种优化方式了，它可以显著减少网络传输所带来的损耗。 对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。 接下来的内容中我们将通过以下几个部分来探讨浏览器缓存机制： 缓存位置 缓存策略 实际场景应用缓存策略 20.1 缓存位置 从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络 Service Worker Memory Cache Disk Cache Push Cache 网络请求 1. Service Worker service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 2. Memory Cache Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存 那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？ 先说结论，这是不可能的。首先计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。内存中其实可以存储大部分的文件，比如说 JS、HTML、CSS、图片等等 当然，我通过一些实践和猜测也得出了一些结论： 对于大文件来说，大概率是不存储在内存中的，反之优先当前系统内存使用率高的话，文件优先存储进硬盘 3. Disk Cache Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 ·HTTP Herder· 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据 4. Push Cache Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。 Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及，但是 HTTP/2 将会是日后的一个趋势 结论 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好 可以推送 no-cache 和 no-store 的资源 一旦连接被关闭，Push Cache 就被释放 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存 Push Cache 中的缓存只能被使用一次 浏览器可以拒绝接受已经存在的资源推送 你可以给其他域名推送资源 5. 网络请求 如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，接下来我们就来学习缓存策略这部分的内容 20.2 缓存策略 通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的 20.2.1 强缓存 强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code为 200 Expires Expires: Wed, 22 Oct 2018 08:41:00 GMT Expires 是 HTTP/1 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 Cache-control Cache-control: max-age=30 Cache-Control 出现于 HTTP/1.1，优先级高于 Expires 。该属性值表示资源会在 30 秒后过期，需要再次请求。 Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令 从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等 一些常见指令的作用 20.2.2 协商缓存 如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 304 状态码，并且更新浏览器缓存有效期。 Last-Modified 和 If-Modified-Since Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。 但是 Last-Modified存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源因为以上这些弊端，所以在 HTTP / 1.1 出现了 ETag ETag 和 If-None-Match ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag优先级比 Last-Modified 高。 以上就是缓存策略的所有内容了，看到这里，不知道你是否存在这样一个疑问。如果什么缓存策略都没设置，那么浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。 20.3 实际场景应用缓存策略频繁变动的资源 对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。 代码文件 这里特指除了 HTML 外的代码文件，因为 HTML 文件一般不缓存或者缓存时间很短。 一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 Cache-Control: max-age=31536000，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存 更多缓存知识详解 http://blog.poetries.top/2019/01/02/browser-cache 21 浏览器渲染原理 注意：该章节都是一个面试题。 21.1 渲染过程1. 浏览器接收到 HTML 文件并转换为 DOM 树 当我们打开一个网页时，浏览器都会去请求对应的 HTML 文件。虽然平时我们写代码时都会分为 JS、CSS、HTML 文件，也就是字符串，但是计算机硬件是不理解这些字符串的，所以在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。 当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记（token），这一过程在词法分析中叫做标记化（tokenization） 那么什么是标记呢？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思 当结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树 以上就是浏览器从网络中接收到 HTML 文件然后一系列的转换过程 当然，在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件，接下来就让我们先来学习浏览器如何解析 CSS 文件 2. 将 CSS 文件转换为 CSSOM 树 其实转换 CSS 到 CSSOM 树的过程和上一小节的过程是极其类似的 在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。 如果你有点不理解为什么会消耗资源的话，我这里举个例子 &lt;div> &lt;a> &lt;span>&lt;/span> &lt;/a> &lt;/div> &lt;style> span { color: red; } div > a > span { color: red; } &lt;/style> 对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平 3. 生成渲染树 当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树 在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。 当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 GPU绘制，合成图层，显示在屏幕上。对于这一部分的内容因为过于底层，还涉及到了硬件相关的知识，这里就不再继续展开内容了。 21.2 为什么操作 DOM 慢 想必大家都听过操作 DOM 性能很差，但是这其中的原因是什么呢？ 因为 DOM是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。 经典面试题：插入几万个 DOM，如何实现页面不卡顿？ 对于这道题目来说，首先我们肯定不能一次性把几万个 DOM 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 DOM。大部分人应该可以想到通过 requestAnimationFrame 的方式去循环的插入 DOM，其实还有种方式去解决这个问题：虚拟滚动（virtualized scroller）。 这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容 从上图中我们可以发现，即使列表很长，但是渲染的 DOM 元素永远只有那么几个，当我们滚动页面的时候就会实时去更新 DOM，这个技术就能顺利解决这道经典面试题 21.3 什么情况阻塞渲染 首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。 然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS文件，这也是都建议将 script 标签放在 body 标签底部的原因。 当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。 当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script标签放在任意位置。 对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。 21.4 重绘（Repaint）和回流（Reflow） 重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘 回流是布局或者几何属性需要改变就称为回流。 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。 以下几个动作可能会导致性能问题： 改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 并且很多人不知道的是，重绘和回流其实也和 Eventloop 有关。 当 Eventloop 执行完 Microtasks 后，会判断 document 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次。 然后判断是否有 resize 或者 scroll 事件，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback回调 21.5 减少重绘和回流 使用 transform 替代 top &lt;div class=\"test\">&lt;/div> &lt;style> .test { position: absolute; top: 10px; width: 100px; height: 100px; background: red; } &lt;/style> &lt;script> setTimeout(() => { // 引起回流 document.querySelector('.test').style.top = '100px' }, 1000) &lt;/script> 使用 visibility 替换display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要把节点的属性值放在一个循环里当成循环里的变量 for(let i = 0; i &lt; 1000; i++) { // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector('.test').style.offsetTop) } 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免节点层级过多 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。 设置节点为图层的方式有很多，我们可以通过以下几个常用属性可以生成新图层 will-change video、iframe 标签 22 安全防范22.1 XSS 涉及面试题：什么是 XSS 攻击？如何防范 XSS 攻击？什么是 CSP？ XSS 简单点来说，就是攻击者想尽一切办法将可以执行的代码注入到网页中。 XSS 可以分为多种类型，但是总体上我认为分为两类：持久型和非持久型。 持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。 举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容 image.png 这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。 非持久型相比于前者危害就小的多了，一般通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。 举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行 &lt;!-- http://www.domain.com?name=&lt;script>alert(1)&lt;/script> --> &lt;div>{{name}}&lt;/div> 但是对于这种攻击方式来说，如果用户使用 Chrome 这类浏览器的话，浏览器就能自动帮助用户防御攻击。但是我们不能因此就不防御此类攻击了，因为我不能确保用户都使用了该类浏览器。 对于 XSS 攻击来说，通常有两种方式可以用来防御。 转义字符 首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义 function escape(str) { str = str.replace(/&amp;/g, '&amp;amp;') str = str.replace(/&lt;/g, '&amp;lt;') str = str.replace(/>/g, '&amp;gt;') str = str.replace(/\"/g, '&amp;quto;') str = str.replace(/'/g, '&amp;#39;') str = str.replace(/`/g, '&amp;#96;') str = str.replace(/\\//g, '&amp;#x2F;') return str } 通过转义可以将攻击代码 &lt;script&gt;alert(1)&lt;/script&gt; 变成 // -> &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt; escape('&lt;script>alert(1)&lt;/script>') 但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式 const xss = require('xss') let html = xss('&lt;h1 id=\"title\">XSS Demo&lt;/h1>&lt;script>alert(\"xss\");&lt;/script>') // -> &lt;h1>XSS Demo&lt;/h1>&amp;lt;script&amp;gt;alert(\"xss\");&amp;lt;/script&amp;gt; console.log(html) 以上示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script标签 CSP CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。 通常可以通过两种方式来开启 CSP： 设置 HTTP Header 中的 Content-Security-Policy 设置 meta 标签的方式 &lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt; 这里以设置 HTTP Header 来举例 只允许加载本站资源 Content-Security-Policy: default-src ‘self’ 只允许加载 HTTPS 协议图片 Content-Security-Policy: img-src https://* 允许加载任何来源框架 Content-Security-Policy: child-src &#39;none&#39; 当然可以设置的属性远不止这些，你可以通过查阅 文档 的方式来学习，这里就不过多赘述其他的属性了。 对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。 22.2 CSRF 涉及面试题：什么是 CSRF 攻击？如何防范 CSRF 攻击？ CSRF 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。 举个例子，假设网站中有一个通过 GET 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口 &lt;img src=\"http://www.domain.com/xxx?comment='attack'\"/> 那么你是否会想到使用 POST 方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交 POST 请求。 如何防御 Get 请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 Token SameSite 可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。 验证 Referer 对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。 Token 服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效 22.3 点击劫持 涉及面试题：什么是点击劫持？如何防范点击劫持？ 点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击 image.png 对于这种攻击方式，推荐防御的方法有两种 1. X-FRAME-OPTIONS X-FRAME-OPTIONS 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用iframe 嵌套的点击劫持攻击。 该响应头有三个值可选，分别是 DENY，表示页面不允许通过 iframe 的方式展示 SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示 ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示 2. JS 防御 对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。 &lt;head> &lt;style id=\"click-jack\"> html { display: none !important; } &lt;/style> &lt;/head> &lt;body> &lt;script> if (self == top) { var style = document.getElementById('click-jack') document.body.removeChild(style) } else { top.location = self.location } &lt;/script> &lt;/body> 以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了 23 从 V8 中看 JS 性能优化 注意：该知识点属于性能优化领域。 23.1 测试性能工具 Chrome 已经提供了一个大而全的性能测试工具 Audits 点我们点击 Audits 后，可以看到如下的界面 在这个界面中，我们可以选择想测试的功能然后点击 Run audits ，工具就会自动运行帮助我们测试问题并且给出一个完整的报告 上图是给掘金首页测试性能后给出的一个报告，可以看到报告中分别为性能、体验、SEO 都给出了打分，并且每一个指标都有详细的评估 评估结束后，工具还提供了一些建议便于我们提高这个指标的分数 我们只需要一条条根据建议去优化性能即可。 除了 Audits 工具之外，还有一个 Performance工具也可以供我们使用。 在这张图中，我们可以详细的看到每个时间段中浏览器在处理什么事情，哪个过程最消耗时间，便于我们更加详细的了解性能瓶颈 23.2 JS 性能优化 JS 是编译型还是解释型语言其实并不固定。首先 JS 需要有引擎才能运行起来，无论是浏览器还是在 Node 中，这是解释型语言的特性。但是在 V8 引擎下，又引入了 TurboFan 编译器，他会在特定的情况下进行优化，将代码编译成执行效率更高的 Machine Code，当然这个编译器并不是 JS 必须需要的，只是为了提高代码执行性能，所以总的来说 JS 更偏向于解释型语言。 那么这一小节的内容主要会针对于 Chrome 的 V8 引擎来讲解。 在这一过程中，JS 代码首先会解析为抽象语法树（AST），然后会通过解释器或者编译器转化为 Bytecode 或者Machine Code 从上图中我们可以发现，JS 会首先被解析为 AST，解析的过程其实是略慢的。代码越多，解析的过程也就耗费越长，这也是我们需要压缩代码的原因之一。另外一种减少解析时间的方式是预解析，会作用于未执行的函数，这个我们下面再谈 这里需要注意一点，对于函数来说，应该尽可能避免声明嵌套函数（类也是函数），因为这样会造成函数的重复解析 function test1() { // 会被重复解析 function test2() {} } 然后 Ignition 负责将 AST 转化为 Bytecode，TurboFan 负责编译出优化后的 Machine Code，并且 Machine Code 在执行效率上优于 Bytecode 那么我们就产生了一个疑问，什么情况下代码会编译为 Machine Code？ JS 是一门动态类型的语言，并且还有一大堆的规则。简单的加法运算代码，内部就需要考虑好几种规则，比如数字相加、字符串相加、对象和字符串相加等等。这样的情况也就势必导致了内部要增加很多判断逻辑，降低运行效率。 function test(x) { return x + x } test(1) test(2) test(3) test(4) 对于以上代码来说，如果一个函数被多次调用并且参数一直传入 number 类型，那么 V8 就会认为该段代码可以编译为 Machine Code，因为你固定了类型，不需要再执行很多判断逻辑了。 但是如果一旦我们传入的参数类型改变，那么 Machine Code 就会被 DeOptimized为 Bytecode，这样就有性能上的一个损耗了。所以如果我们希望代码能多的编译为 Machine Code 并且 DeOptimized的次数减少，就应该尽可能保证传入的类型一致。 那么你可能会有一个疑问，到底优化前后有多少的提升呢，接下来我们就来实践测试一下到底有多少的提升 const { performance, PerformanceObserver } = require('perf_hooks') function test(x) { return x + x } // node 10 中才有 PerformanceObserver // 在这之前的 node 版本可以直接使用 performance 中的 API const obs = new PerformanceObserver((list, observer) => { console.log(list.getEntries()) observer.disconnect() }) obs.observe({ entryTypes: ['measure'], buffered: true }) performance.mark('start') let number = 10000000 // 不优化代码 %NeverOptimizeFunction(test) while (number--) { test(1) } performance.mark('end') performance.measure('test', 'start', 'end') 以上代码中我们使用了 performance API，这个 API 在性能测试上十分好用。不仅可以用来测量代码的执行时间，还能用来测量各种网络连接中的时间消耗等等，并且这个 API 也可以在浏览器中使 从上图中我们可以发现，优化过的代码执行时间只需要 9ms，但是不优化过的代码执行时间却是前者的二十倍，已经接近 200ms 了。在这个案例中，我相信大家已经看到了 V8 的性能优化到底有多强，只需要我们符合一定的规则书写代码，引擎底层就能帮助我们自动优化代码。 另外，编译器还有个骚操作 Lazy-Compile，当函数没有被执行的时候，会对函数进行一次预解析，直到代码被执行以后才会被解析编译。对于上述代码来说，test 函数需要被预解析一次，然后在调用的时候再被解析编译。但是对于这种函数马上就被调用的情况来说，预解析这个过程其实是多余的，那么有什么办法能够让代码不被预解析呢？ (function test(obj) { return x + x }) 但是不可能我们为了性能优化，给所有的函数都去套上括号，并且也不是所有函数都需要这样做。我们可以通过 optimize-js 实现这个功能，这个库会分析一些函数的使用情况，然后给需要的函数添加括号，当然这个库很久没人维护了，如果需要使用的话，还是需要测试过相关内容的。 其实很简单，我们只需要给函数套上括号就可以了 24 性能优化 总的来说性能优化这个领域的很多内容都很碎片化，这一章节我们将来学习这些碎片化的内容。 24.1 图片优化计算图片大小 对于一张 100 * 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1个字节），所以该图片大小大概为 39KB（10000 * 1 * 4 / 1024）。 但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。 了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了： 减少像素点 减少每个像素点能够显示的颜色 24.2 图片加载优化 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。 小图使用 base64 格式 将多个图标文件整合到一张图片中（雪碧图） 选择正确的图片格式： 对于能够显示 WebP格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG代替 照片使用 JPEG 24.3 DNS 预解析 DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。 &lt;link rel=\"dns-prefetch\" href=\"//blog.poetries.top\"> 24.4 节流 考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流。 理解了节流的用途，我们就来实现下这个函数 // func是用户传入需要防抖的函数 // wait是等待时间 const throttle = (func, wait = 50) => { // 上一次执行该函数的时间 let lastTime = 0 return function(...args) { // 当前时间 let now = +new Date() // 将当前时间和上一次执行函数时间对比 // 如果差值大于设置的等待时间就执行函数 if (now - lastTime > wait) { lastTime = now func.apply(this, args) } } } setInterval( throttle(() => { console.log(1) }, 500), 1 ) 24.5 防抖 考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。 理解了防抖的用途，我们就来实现下这个函数 // func是用户传入需要防抖的函数 // wait是等待时间 const debounce = (func, wait = 50) => { // 缓存一个定时器id let timer = 0 // 这里返回的函数是每次用户实际调用的防抖函数 // 如果已经设定过定时器了就清空上一次的定时器 // 开始一个新的定时器，延迟执行用户传入的方法 return function(...args) { if (timer) clearTimeout(timer) timer = setTimeout(() => { func.apply(this, args) }, wait) } } 24.6 预加载 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。 预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载 &lt;link rel=\"preload\" href=\"http://blog.poetries.top\"> 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。 24.7 预渲染 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染 &lt;link rel=\"prerender\" href=\"http://blog.poetries.top\"> 预渲染虽然可以提高页面的加载速度，但是要确保该页面大概率会被用户在之后打开，否则就是白白浪费资源去渲染。 24.8 懒执行 懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。 24.9 懒加载 懒加载就是将不关键的资源延后加载。 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。 懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。 24.10 CDN CDN的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。 因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量 25 Webpack 性能优化 在这部分的内容中，我们会聚焦于以下两个知识点，并且每一个知识点都属于高频考点： 有哪些方式可以减少 Webpack 的打包时间 有哪些方式可以让 Webpack 打出来的包更小 25.1 减少 Webpack 打包时间1. 优化 Loader 对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，我们是有办法优化的 首先我们可以优化 Loader 的文件搜索范围 module.exports = { module: { rules: [ { // js 文件才使用 babel test: /\\.js$/, loader: 'babel-loader', // 只在 src 文件夹下查找 include: [resolve('src')], // 不会去查找的路径 exclude: /node_modules/ } ] } } 对于 Babel 来说，我们肯定是希望只作用在 JS代码上的，然后 node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍 当然这样做还不够，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间 loader: 'babel-loader?cacheDirectory=true' 2. HappyPack 受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。 HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了 module: { loaders: [ { test: /\\.js$/, include: [resolve('src')], exclude: /node_modules/, // id 后面的内容对应下面 loader: 'happypack/loader?id=happybabel' } ] }, plugins: [ new HappyPack({ id: 'happybabel', loaders: ['babel-loader?cacheDirectory'], // 开启 4 个线程 threads: 4 }) ] 3. DllPlugin DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。 接下来我们就来学习如何使用 DllPlugin // 单独配置在一个文件中 // webpack.dll.conf.js const path = require('path') const webpack = require('webpack') module.exports = { entry: { // 想统一打包的类库 vendor: ['react'] }, output: { path: path.join(__dirname, 'dist'), filename: '[name].dll.js', library: '[name]-[hash]' }, plugins: [ new webpack.DllPlugin({ // name 必须和 output.library 一致 name: '[name]-[hash]', // 该属性需要与 DllReferencePlugin 中一致 context: __dirname, path: path.join(__dirname, 'dist', '[name]-manifest.json') }) ] } 然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 DllReferencePlugin 将依赖文件引入项目中 // webpack.conf.js module.exports = { // ...省略其他配置 plugins: [ new webpack.DllReferencePlugin({ context: __dirname, // manifest 就是之前打包出来的 json 文件 manifest: require('./dist/vendor-manifest.json'), }) ] } 4. 代码压缩 在 Webpack3 中，我们一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 webpack-parallel-uglify-plugin 来并行运行 UglifyJS，从而提高效率。 在 Webpack4 中，我们就不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能。 5. 一些小的优化点 我们还可以通过一些小的优化点来加快打包速度 resolve.extensions：用来表明文件后缀列表，默认查找顺序是 [&#39;.js&#39;, &#39;.json&#39;]，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面 resolve.alias：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径 module.noParse：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助 25.2 减少 Webpack 打包后的文件体积1. 按需加载 想必大家在开发 SPA 项目的时候，项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 JS文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 loadash 这种大型类库同样可以使用这个功能。 按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 Promise，当 Promise成功以后去执行回调。 2. Scope Hoisting Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。 比如我们希望打包两个文件 // test.js export const a = 1 // index.js import { a } from './test.js' 对于这种情况，我们打包出来的代码会类似这样 [ /* 0 */ function (module, exports, require) { //... }, /* 1 */ function (module, exports, require) { //... } ] 但是如果我们使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码 [ /* 0 */ function (module, exports, require) { //... } ] 这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules就可以了。 module.exports = { optimization: { concatenateModules: true } } 3. Tree Shaking Tree Shaking 可以实现删除项目中未被引用的代码，比如 // test.js export const a = 1 export const b = 2 // index.js import { a } from './test.js' 对于以上情况，test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中。 如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。 26 实现小型打包工具 该工具可以实现以下两个功能 将 ES6 转换为 ES5 支持在 JS 文件中 import CSS 文件 通过这个工具的实现，大家可以理解到打包工具的原理到底是什么 实现 因为涉及到 ES6 转 ES5，所以我们首先需要安装一些 Babel 相关的工具 yarn add babylon babel-traverse babel-core babel-preset-env 接下来我们将这些工具引入文件中 const fs = require('fs') const path = require('path') const babylon = require('babylon') const traverse = require('babel-traverse').default const { transformFromAst } = require('babel-core') 首先，我们先来实现如何使用 Babel 转换代码 function readCode(filePath) { // 读取文件内容 const content = fs.readFileSync(filePath, 'utf-8') // 生成 AST const ast = babylon.parse(content, { sourceType: 'module' }) // 寻找当前文件的依赖关系 const dependencies = [] traverse(ast, { ImportDeclaration: ({ node }) => { dependencies.push(node.source.value) } }) // 通过 AST 将代码转为 ES5 const { code } = transformFromAst(ast, null, { presets: ['env'] }) return { filePath, dependencies, code } } 首先我们传入一个文件路径参数，然后通过 fs 将文件中的内容读取出来 接下来我们通过 babylon 解析代码获取 AST，目的是为了分析代码中是否还引入了别的文件 通过 dependencies 来存储文件中的依赖，然后再将 AST 转换为 ES5 代码 最后函数返回了一个对象，对象中包含了当前文件路径、当前文件依赖和当前文件转换后的代码 接下来我们需要实现一个函数，这个函数的功能有以下几点 调用 readCode 函数，传入入口文件 分析入口文件的依赖 识别 JS 和 CSS 文件 function getDependencies(entry) { // 读取入口文件 const entryObject = readCode(entry) const dependencies = [entryObject] // 遍历所有文件依赖关系 for (const asset of dependencies) { // 获得文件目录 const dirname = path.dirname(asset.filePath) // 遍历当前文件依赖关系 asset.dependencies.forEach(relativePath => { // 获得绝对路径 const absolutePath = path.join(dirname, relativePath) // CSS 文件逻辑就是将代码插入到 `style` 标签中 if (/\\.css$/.test(absolutePath)) { const content = fs.readFileSync(absolutePath, 'utf-8') const code = ` const style = document.createElement('style') style.innerText = ${JSON.stringify(content).replace(/\\\\r\\\\n/g, '')} document.head.appendChild(style) ` dependencies.push({ filePath: absolutePath, relativePath, dependencies: [], code }) } else { // JS 代码需要继续查找是否有依赖关系 const child = readCode(absolutePath) child.relativePath = relativePath dependencies.push(child) } }) } return dependencies } 首先我们读取入口文件，然后创建一个数组，该数组的目的是存储代码中涉及到的所有文件 接下来我们遍历这个数组，一开始这个数组中只有入口文件，在遍历的过程中，如果入口文件有依赖其他的文件，那么就会被 push 到这个数组中 在遍历的过程中，我们先获得该文件对应的目录，然后遍历当前文件的依赖关系 在遍历当前文件依赖关系的过程中，首先生成依赖文件的绝对路径，然后判断当前文件是 CSS 文件还是 JS 文件 如果是 CSS 文件的话，我们就不能用 Babel 去编译了，只需要读取 CSS 文件中的代码，然后创建一个 style 标签，将代码插入进标签并且放入 head 中即可 如果是 JS 文件的话，我们还需要分析 JS 文件是否还有别的依赖关系 最后将读取文件后的对象 push 进数组中 现在我们已经获取到了所有的依赖文件，接下来就是实现打包的功能了 function bundle(dependencies, entry) { let modules = '' // 构建函数参数，生成的结构为 // { './entry.js': function(module, exports, require) { 代码 } } dependencies.forEach(dep => { const filePath = dep.relativePath || entry modules += `'${filePath}': ( function (module, exports, require) { ${dep.code} } ),` }) // 构建 require 函数，目的是为了获取模块暴露出来的内容 const result = ` (function(modules) { function require(id) { const module = { exports : {} } modules[id](module, module.exports, require) return module.exports } require('${entry}') })({${modules}}) ` // 当生成的内容写入到文件中 fs.writeFileSync('./bundle.js', result) } 这段代码需要结合着 Babel 转换后的代码来看，这样大家就能理解为什么需要这样写了 // entry.js var _a = require('./a.js') var _a2 = _interopRequireDefault(_a) function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj } } console.log(_a2.default) // a.js Object.defineProperty(exports, '__esModule', { value: true }) var a = 1 exports.default = a Babel 将我们 ES6的模块化代码转换为了 CommonJS的代码，但是浏览器是不支持 CommonJS 的，所以如果这段代码需要在浏览器环境下运行的话，我们需要自己实现 CommonJS 相关的代码，这就是 bundle 函数做的大部分事情。 接下来我们再来逐行解析 bundle 函数 首先遍历所有依赖文件，构建出一个函数参数对象 对象的属性就是当前文件的相对路径，属性值是一个函数，函数体是当前文件下的代码，函数接受三个参数 module、exports、 require module 参数对应 CommonJS 中的 module exports 参数对应 CommonJS 中的 module.export require 参数对应我们自己创建的 require 函数 接下来就是构造一个使用参数的函数了，函数做的事情很简单，就是内部创建一个 require函数，然后调用 require(entry)，也就是 require(&#39;./entry.js&#39;)，这样就会从函数参数中找到 ./entry.js 对应的函数并执行，最后将导出的内容通过 module.export 的方式让外部获取到 最后再将打包出来的内容写入到单独的文件中 如果你对于上面的实现还有疑惑的话，可以阅读下打包后的部分简化代码 ;(function(modules) { function require(id) { // 构造一个 CommonJS 导出代码 const module = { exports: {} } // 去参数中获取文件对应的函数并执行 modules[id](module, module.exports, require) return module.exports } require('./entry.js') })({ './entry.js': function(module, exports, require) { // 这里继续通过构造的 require 去找到 a.js 文件对应的函数 var _a = require('./a.js') console.log(_a2.default) }, './a.js': function(module, exports, require) { var a = 1 // 将 require 函数中的变量 module 变成了这样的结构 // module.exports = 1 // 这样就能在外部取到导出的内容了 exports.default = a } // 省略 }) 虽然实现这个工具只写了不到 100 行的代码，但是打包工具的核心原理就是这些了 找出入口文件所有的依赖关系 然后通过构建 CommonJS 代码来获取 exports 导出的内容 27 MVVM/虚拟DOM/前端路由27.1 MVVM 涉及面试题：什么是 MVVM？比之 MVC 有什么区别？ 首先先来说下 View 和 Model View 很简单，就是用户看到的视图 Model 同样很简单，一般就是本地数据和数据库中的数据 基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。 传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新 但是 MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。 在 MVVM 架构中，引入了 ViewModel 的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。 以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。 除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定 同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。 对于 MVVM来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓 27.2 Virtual DOM 涉及面试题：什么是 Virtual DOM？为什么 Virtual DOM比原生 DOM 快？ 大家都知道操作 DOM 是很慢的，为什么慢的原因以及在「浏览器渲染原理」章节中说过，这里就不再赘述了- 那么相较于 DOM来说，操作 JS 对象会快很多，并且我们也可以通过 JS来模拟 DOM const ul = { tag: 'ul', props: { class: 'list' }, children: { tag: 'li', children: '1' } } 上述代码对应的 DOM 就是 &lt;ul class='list'> &lt;li>1&lt;/li> &lt;/ul> 那么既然 DOM 可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM。当然了，通过 JS 来模拟 DOM 并且渲染对应的 DOM 只是第一步，难点在于如何判断新旧两个 JS 对象的最小差异并且实现局部更新 DOM 首先 DOM 是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。 实现 O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。 所以判断差异的算法就分为了两步 首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异 一旦节点有子元素，就去判断子元素是否有不同 在第一步算法中我们需要判断新旧节点的 tagName 是否相同，如果不相同的话就代表节点被替换了。如果没有更改 tagName 的话，就需要判断是否有子元素，有的话就进行第二步算法。 在第二步算法中，我们需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动。 举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更 // 假设这里模拟一个 ul，其中包含了 5 个 li [1, 2, 3, 4, 5] // 这里替换上面的 li [1, 2, 5, 4] 从上述例子中，我们一眼就可以看出先前的 ul 中的第三个li被移除了，四五替换了位置。 那么在实际的算法中，我们如何去识别改动的是哪个节点呢？这就引入了 key 这个属性，想必大家在 Vue 或者 React 的列表中都用过这个属性。这个属性是用来给每一个节点打标志的，用于判断是否是同一个节点。 当然在判断以上差异的过程中，我们还需要判断节点的属性是否有变化等等。 当我们判断出以上的差异后，就可以把这些差异记录下来。当对比完两棵树以后，就可以通过差异去局部更新 DOM，实现性能的最优化。 当然了 Virtual DOM 提高性能是其中一个优势，其实最大的优势还是在于： 将 Virtual DOM作为一个兼容层，让我们还能对接非 Web 端的系统，实现跨端开发。 同样的，通过 Virtual DOM我们可以渲染到其他的平台，比如实现 SSR、同构渲染等等。 实现组件的高度抽象化 27.3 路由原理 涉及面试题：前端路由原理？两种实现方式有什么区别？ 前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式 Hash 模式 History 模式 1. Hash 模式 www.test.com/#/ 就是 Hash URL，当 # 后面的哈希值发生变化时，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 www.test.com window.addEventListener('hashchange', () => { // ... 具体逻辑 }) Hash 模式相对来说更简单，并且兼容性也更好 2. History 模式 History 模式是 HTML5 新推出的功能，主要使用 history.pushState 和 history.replaceState 改变 URL 通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。 // 新增历史记录 history.pushState(stateObject, title, URL) // 替换当前历史记录 history.replaceState(stateObject, title, URL) 当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件 window.addEventListener('popstate', e => { // e.state 就是 pushState(stateObject) 中的 stateObject console.log(e.state) }) 两种模式对比 Hash模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串 Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候 27.4 Vue 和 React 之间的区别 Vue 的表单可以使用 v-model 支持双向绑定，相比于 React 来说开发上更加方便，当然了 v-model 其实就是个语法糖，本质上和 React 写表单的方式没什么区别 改变数据方式不同，Vue 修改状态相比来说要简单许多，React 需要使用 setState 来改变状态，并且使用这个 API 也有一些坑点。并且 Vue 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 React 还是需要用户手动去优化这方面的问题。 React 16以后，有些钩子函数会执行多次，这是因为引入 Fiber 的原因 React 需要使用 JSX，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 JS 来控制页面，更加的灵活。Vue 使用了模板语法，相比于 JSX 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写 render 函数就能在浏览器中运行。 在生态上来说，两者其实没多大的差距，当然 React的用户是远远高于Vue 的 28 Vue常考知识点28.1 生命周期钩子函数 在 beforeCreate 钩子函数调用的时候，是获取不到 props 或者 data 中的数据的，因为这些数据的初始化都在 initState 中。 然后会执行 created 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。 接下来会先执行 beforeMount 钩子函数，开始创建 VDOM，最后执行 mounted 钩子，并将 VDOM渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。 接下来是数据更新时会调用的钩子函数 beforeUpdate 和 updated，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。 另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。 最后就是销毁组件的钩子函数 beforeDestroy 和 destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 destroyed 钩子函数 28.2 组件通信 组件通信一般分为以下几种情况： 父子组件通信 兄弟组件通信 跨多层级组件通信 对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。 1. 父子通信 父组件通过 props 传递数据给子组件，子组件通过 emit 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。 这种父子通信方式也就是典型的单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props，而是必须通过发送事件的方式告知父组件修改数据。 另外这两种方式还可以使用语法糖 v-model 来直接实现，因为 v-model 默认会解析成名为 value 的 prop 和名为 input 的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。 当然我们还可以通过访问 $parent 或者 $children 对象来访问组件实例中的方法和数据。 另外如果你使用 Vue 2.3 及以上版本的话还可以使用 $listeners 和 .sync 这两个属性。 $listeners 属性会将父组件中的 (不含 .native 修饰器的) v-on 事件监听器传递给子组件，子组件可以通过访问 $listeners 来自定义监听器。 .sync 属性是个语法糖，可以很简单的实现子组件与父组件通信 &lt;!--父组件中--> &lt;input :value.sync=\"value\" /> &lt;!--以上写法等同于--> &lt;input :value=\"value\" @update:value=\"v => value = v\">&lt;/comp> &lt;!--子组件中--> &lt;script> this.$emit('update:value', 1) &lt;/script> 2. 兄弟组件通信 对于这种情况可以通过查找父组件中的子组件实现，也就是 this.$parent.$children，在 $children 中可以通过组件 name 查询到需要的组件实例，然后进行通信。 3. 跨多层次组件通信 对于这种情况可以使用 Vue 2.2 新增的 API provide / inject，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。 假设有父组件 A，然后有一个跨多层级的子组件 B // 父组件 A export default { provide: { data: 1 } } // 子组件 B export default { inject: ['data'], mounted() { // 无论跨几层都能获得父组件的 data 属性 console.log(this.data) // => 1 } } 终极办法解决一切通信问题 只要你不怕麻烦，可以使用 Vuex 或者 Event Bus 解决上述所有的通信情况。 28.3 extend 能做什么 这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 $mount 一起使用。 // 创建组件构造器 let Component = Vue.extend({ template: '&lt;div>test&lt;/div>' }) // 挂载到 #app 上 new Component().$mount('#app') // 除了上面的方式，还可以用来扩展已有的组件 let SuperComponent = Vue.extend(Component) new SuperComponent({ created() { console.log(1) } }) new SuperComponent().$mount('#app') 28.4 mixin 和 mixins 区别 mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的 Vue.mixin({ beforeCreate() { // ...逻辑 // 这种方式会影响到每个组件的 beforeCreate 钩子函数 } }) 虽然文档不建议我们在应用中直接使用 mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 ajax 或者一些工具函数等等。 mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。 另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读 文档。 28.5 computed 和 watch 区别 computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。 watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。 所以一般来说需要依赖别的属性来动态获得值的时候可以使用 computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 watch。 另外 computer 和 watch 还都支持对象的写法，这种方式知道的人并不多。 vm.$watch('obj', { // 深度遍历 deep: true, // 立即触发 immediate: true, // 执行的函数 handler: function(val, oldVal) {} }) var vm = new Vue({ data: { a: 1 }, computed: { aPlus: { // this.aPlus 时触发 get: function () { return this.a + 1 }, // this.aPlus = 1 时触发 set: function (v) { this.a = v - 1 } } } }) 28.6 keep-alive 组件有什么作用 如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。 对于 keep-alive 组件来说，它拥有两个独有的生命周期钩子函数，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。 28.7 v-show 与 v-if 区别 v-show 只是在 display: none 和 display: block 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说 v-show 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。 v-if 的话就得说到 Vue 底层的编译了。当属性初始为 false 时，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。 并且基于 v-if 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。 28.8 组件中 data 什么时候可以使用对象 这道题目其实更多考的是 JS 功底。 组件复用时所有组件实例都会共享 data，如果 data 是对象的话，就会造成一个组件修改 data 以后会影响到其他所有组件，所以需要将 data 写成函数，每次用到就调用一次函数获得新的数据。 当我们使用 new Vue() 的方式的时候，无论我们将 data 设置为对象还是函数都是可以的，因为 new Vue() 的方式是生成一个根组件，该组件不会复用，也就不存在共享 data 的情况了 以下是进阶部分 28.9 响应式原理 Vue 内部使用了 Object.defineProperty() 来实现数据响应式，通过这个函数可以监听到 set 和 get 的事件 var data = { name: 'poetries' } observe(data) let name = data.name // -> get value data.name = 'yyy' // -> change value function observe(obj) { // 判断类型 if (!obj || typeof obj !== 'object') { return } Object.keys(obj).forEach(key => { defineReactive(obj, key, obj[key]) }) } function defineReactive(obj, key, val) { // 递归子属性 observe(val) Object.defineProperty(obj, key, { // 可枚举 enumerable: true, // 可配置 configurable: true, // 自定义函数 get: function reactiveGetter() { console.log('get value') return val }, set: function reactiveSetter(newVal) { console.log('change value') val = newVal } }) } 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，从能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集 &lt;div> {{name}} &lt;/div> 在解析如上模板代码时，遇到 就会进行依赖收集。 接下来我们先来实现一个 Dep 类，用于解耦属性的依赖收集和派发更新操作 // 通过 Dep 解耦属性的依赖和更新操作 class Dep { constructor() { this.subs = [] } // 添加依赖 addSub(sub) { this.subs.push(sub) } // 更新 notify() { this.subs.forEach(sub => { sub.update() }) } } // 全局属性，通过该属性配置 Watcher Dep.target = null 以上的代码实现很简单，当需要依赖收集的时候调用 addSub，当需要派发更新的时候调用 notify。 接下来我们先来简单的了解下 Vue组件挂载时添加响应式的过程。在组件挂载时，会先对所有需要的属性调用 Object.defineProperty()，然后实例化 Watcher，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。 因为这一小节主要目的是学习响应式原理的细节，所以接下来的代码会简略的表达触发依赖收集时的操作。 class Watcher { constructor(obj, key, cb) { // 将 Dep.target 指向自己 // 然后触发属性的 getter 添加监听 // 最后将 Dep.target 置空 Dep.target = this this.cb = cb this.obj = obj this.key = key this.value = obj[key] Dep.target = null } update() { // 获得新值 this.value = this.obj[this.key] // 调用 update 方法更新 Dom this.cb(this.value) } } 以上就是 Watcher的简单实现，在执行构造函数的时候将 Dep.target指向自身，从而使得收集到了对应的 Watcher，在派发更新的时候取出对应的 Watcher 然后执行 update 函数。 接下来，需要对defineReactive 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码 function defineReactive(obj, key, val) { // 递归子属性 observe(val) let dp = new Dep() Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter() { console.log('get value') // 将 Watcher 添加到订阅 if (Dep.target) { dp.addSub(Dep.target) } return val }, set: function reactiveSetter(newVal) { console.log('change value') val = newVal // 执行 watcher 的 update 方法 dp.notify() } }) } 以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 getter 来实现依赖收集。 现在我们就来测试下代码的效果，只需要把所有的代码复制到浏览器中执行，就会发现页面的内容全部被替换了 var data = { name: 'poetries' } observe(data) function update(value) { document.querySelector('div').innerText = value } // 模拟解析到 `{{name}}` 触发的操作 new Watcher(data, 'name', update) // update Dom innerText data.name = 'yyy' 28.9.1 Object.defineProperty 的缺陷 以上已经分析完了 Vue 的响应式原理，接下来说一点 Object.defineProperty 中的缺陷。 如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为Object.defineProperty 不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。 对于第一个问题，Vue 提供了一个 API 解决 export function set (target: Array&lt;any> | Object, key: any, val: any): any { // 判断是否为数组且下标是否有效 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) { // 调用 splice 函数触发派发更新 // 该函数已被重写 target.length = Math.max(target.length, key) target.splice(key, 1, val) return val } // 判断 key 是否已经存在 if (key in target &amp;&amp; !(key in Object.prototype)) { target[key] = val return val } const ob = (target: any).__ob__ // 如果对象不是响应式对象，就赋值返回 if (!ob) { target[key] = val return val } // 进行双向绑定 defineReactive(ob.value, key, val) // 手动派发更新 ob.dep.notify() return val } 对于数组而言，Vue内部重写了以下函数实现派发更新 // 获得数组原型 const arrayProto = Array.prototype export const arrayMethods = Object.create(arrayProto) // 重写以下函数 const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse' ] methodsToPatch.forEach(function (method) { // 缓存原生函数 const original = arrayProto[method] // 重写函数 def(arrayMethods, method, function mutator (...args) { // 先调用原生函数获得结果 const result = original.apply(this, args) const ob = this.__ob__ let inserted // 调用以下几个函数时，监听新数据 switch (method) { case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break } if (inserted) ob.observeArray(inserted) // 手动派发更新 ob.dep.notify() return result }) }) 28.9.2 编译过程 想必大家在使用 Vue 开发的过程中，基本都是使用模板的方式。那么你有过「模板是怎么在浏览器中运行的」这种疑虑嘛？ 首先直接把模板丢到浏览器中肯定是不能运行的，模板只是为了方便开发者进行开发。Vue 会通过编译器将模板通过几个阶段最终编译为 render 函数，然后通过执行 render 函数生成 Virtual DOM 最终映射为真实 DOM。 接下来我们就来学习这个编译的过程，了解这个过程中大概发生了什么事情。这个过程其中又分为三个阶段，分别为： 将模板解析为 AST 优化 AST 将 AST转换为 render函数 在第一个阶段中，最主要的事情还是通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 AST对象 { // 类型 type: 1, // 标签 tag, // 属性列表 attrsList: attrs, // 属性映射 attrsMap: makeAttrsMap(attrs), // 父节点 parent, // 子节点 children: [] } 然后会根据这个最基本的 AST 对象中的属性，进一步扩展 AST。 当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 HTML5 Content Model规范等等问题。 接下来就是优化 AST 的阶段。在当前版本下，Vue 进行的优化内容其实还是不多的。只是对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 Virtual DOM，跳过对比算法的功能。在下一个大版本中，Vue 会在优化 AST 的阶段继续发力，实现更多的优化功能，尽可能的在编译阶段压榨更多的性能，比如说提取静态的属性等等优化行为。 最后一个阶段就是通过 AST 生成 render 函数了。其实这一阶段虽然分支有很多，但是最主要的目的就是遍历整个 AST，根据不同的条件生成不同的代码罢了。 28.9.3 NextTick 原理分析 nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。 在 Vue 2.4 之前都是使用的 microtasks，但是microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。 对于实现 macrotasks ，会先判断是否能使用 setImmediate ，不能的话降级为 MessageChannel ，以上都不行的话就使用 setTimeout if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) { macroTimerFunc = () => { setImmediate(flushCallbacks) } } else if ( typeof MessageChannel !== 'undefined' &amp;&amp; (isNative(MessageChannel) || // PhantomJS MessageChannel.toString() === '[object MessageChannelConstructor]') ) { const channel = new MessageChannel() const port = channel.port2 channel.port1.onmessage = flushCallbacks macroTimerFunc = () => { port.postMessage(1) } } else { macroTimerFunc = () => { setTimeout(flushCallbacks, 0) } } 以上代码很简单，就是判断能不能使用相应的API 29 React常考知识点29.1 生命周期 在 V16 版本中引入了 Fiber 机制。这个机制一定程度上的影响了部分生命周期的调用，并且也引入了新的 2 个 API 来解决问题 在之前的版本中，如果你拥有一个很复杂的复合组件，然后改动了最上层组件的 state，那么调用栈可能会很长 调用栈过长，再加上中间进行了复杂的操作，就可能导致长时间阻塞主线程，带来不好的用户体验。Fiber 就是为了解决该问题而生 Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新 对于如何区别优先级，React 有自己的一套逻辑。对于动画这种实时性很高的东西，也就是 16 ms 必须渲染一次保证不卡顿的情况下，React 会每 16 ms（以内） 暂停一下更新，返回来继续渲染动画 对于异步渲染，现在渲染有两个阶段：reconciliation 和 commit 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。 1. Reconciliation 阶段 componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate 2. Commit 阶段 componentDidMount componentDidUpdate componentWillUnmount 因为 Reconciliation 阶段是可以被打断的，所以 Reconciliation 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 Bug。由此对于 Reconciliation 阶段调用的几个函数，除了 shouldComponentUpdate 以外，其他都应该避免去使用，并且 V16 中也引入了新的 API 来解决这个问题。 getDerivedStateFromProps 用于替换 componentWillReceiveProps ，该函数会在初始化和 update 时被调用 class ExampleComponent extends React.Component { // Initialize state in constructor, // Or with a property initializer. state = {}; static getDerivedStateFromProps(nextProps, prevState) { if (prevState.someMirroredValue !== nextProps.someValue) { return { derivedData: computeDerivedState(nextProps), someMirroredValue: nextProps.someValue }; } // Return null to indicate no change to state. return null; } } getSnapshotBeforeUpdate 用于替换 componentWillUpdate ，该函数会在 update 后 DOM 更新前被调用，用于读取最新的 DOM 数据 更多详情 http://blog.poetries.top/2018/11/18/react-lifecircle 29.2 setState setState 在 React 中是经常使用的一个 API，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个 API 是异步的。 首先 setState 的调用并不会马上引起 state 的改变，并且如果你一次调用了多个 setState ，那么结果可能并不如你期待的一样。 handle() { // 初始化 `count` 为 0 console.log(this.state.count) // -> 0 this.setState({ count: this.state.count + 1 }) this.setState({ count: this.state.count + 1 }) this.setState({ count: this.state.count + 1 }) console.log(this.state.count) // -> 0 } 第一，两次的打印都为 0，因为 setState 是个异步 API，只有同步代码运行完毕才会执行。setState 异步的原因我认为在于，setState 可能会导致 DOM 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。 第一，两次的打印都为 0，因为 setState 是个异步 API，只有同步代码运行完毕才会执行。setState 异步的原因我认为在于，setState 可能会导致 DOM 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。 Object.assign( {}, { count: this.state.count + 1 }, { count: this.state.count + 1 }, { count: this.state.count + 1 }, ) 当然你也可以通过以下方式来实现调用三次 setState使得 count 为 3 handle() { this.setState((prevState) => ({ count: prevState.count + 1 })) this.setState((prevState) => ({ count: prevState.count + 1 })) this.setState((prevState) => ({ count: prevState.count + 1 })) } 如果你想在每次调用 setState 后获得正确的 state，可以通过如下代码实现 handle() { this.setState((prevState) => ({ count: prevState.count + 1 }), () => { console.log(this.state) }) } 更多详情 http://blog.poetries.top/2018/12/20/react-setState 29.3 性能优化 在 shouldComponentUpdate 函数中我们可以通过返回布尔值来决定当前组件是否需要更新。这层代码逻辑可以是简单地浅比较一下当前 state 和之前的 state 是否相同，也可以是判断某个值更新了才触发组件更新。一般来说不推荐完整地对比当前 state 和之前的 state 是否相同，因为组件更新触发可能会很频繁，这样的完整对比性能开销会有点大，可能会造成得不偿失的情况。 当然如果真的想完整对比当前 state 和之前的 state 是否相同，并且不影响性能也是行得通的，可以通过 immutable 或者 immer 这些库来生成不可变对象。这类库对于操作大规模的数据来说会提升不错的性能，并且一旦改变数据就会生成一个新的对象，对比前后 state 是否一致也就方便多了，同时也很推荐阅读下 immer 的源码实现 另外如果只是单纯的浅比较一下，可以直接使用 PureComponent，底层就是实现了浅比较 state class Test extends React.PureComponent { render() { return ( &lt;div> PureComponent &lt;/div> ) } } 这时候你可能会考虑到函数组件就不能使用这种方式了，如果你使用 16.6.0 之后的版本的话，可以使用 React.memo 来实现相同的功能 const Test = React.memo(() => ( &lt;div> PureComponent &lt;/div> )) 通过这种方式我们就可以既实现了 shouldComponentUpdate 的浅比较，又能够使用函数组件 29.4 通信1. 父子通信 父组件通过 props 传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。 这种父子通信方式也就是典型的单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props， 而是必须通过调用父组件函数的方式告知父组件修改数据。 2. 兄弟组件通信 对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件 3. 跨多层次组件通信 如果你使用 16.3 以上版本的话，对于这种情况可以使用 Context API // 创建 Context，可以在开始就传入值 const StateContext = React.createContext() class Parent extends React.Component { render () { return ( // value 就是传入 Context 中的值 &lt;StateContext.Provider value='yck'> &lt;Child /> &lt;/StateContext.Provider> ) } } class Child extends React.Component { render () { return ( &lt;ThemeContext.Consumer> // 取出值 {context => ( name is { context } )} &lt;/ThemeContext.Consumer> ); } } 4. 任意组件 这种方式可以通过 Redux 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况 30 监控 更新中… 31 TCP/UDP 更新中… 32 HTTP/TLS 更新中… 33 HTTP2.0 更新中… 34 输入URL到页面渲染流程 更新中… 35 设计模式 更新中… 36 常见数据结构 更新中… 37 常考算法题解析 更新中… 38 css常考面试题解析 更新中…","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"高频考点","slug":"高频考点","permalink":"http://www.chenya.site/tags/高频考点/"},{"name":"精华篇","slug":"精华篇","permalink":"http://www.chenya.site/tags/精华篇/"}]},{"title":"通识篇-03.计算机基础算法知识","slug":"002.前端知识体系/004.通识篇/003.通识篇之计算机基础算法知识","date":"2017-05-26T12:42:05.000Z","updated":"2019-09-16T01:57:01.493Z","comments":true,"path":"2017/05/26/002.前端知识体系/004.通识篇/003.通识篇之计算机基础算法知识/","link":"","permalink":"http://www.chenya.site/2017/05/26/002.前端知识体系/004.通识篇/003.通识篇之计算机基础算法知识/","excerpt":"","text":"三、算法3.1 时间复杂度 通常使用最差的时间复杂度来衡量一个算法的好坏。 常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。 对于一个算法来说，可能会计算出如下操作次数 aN +1，N 代表数据量。那么该算法的时间复杂度就是 O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。 当然可能会出现两个算法都是 O(N) 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了 3.2 位运算 位运算在算法中很有用，速度可以比四则运算快很多。 在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式 十进制 33 可以看成是 32 + 1 ，并且 33 应该是六位二进制的（因为 33近似 32，而 32 是 2的五次方，所以是六位），那么 十进制 33 就是 100001 ，只要是 2 的次方，那么就是 1否则都为 0那么二进制 100001 同理，首位是 2^5，末位是 2^0 ，相加得出 33 左移 &lt;&lt; 10 &lt;&lt; 1 // -> 20 左移就是将二进制全部往左移动，10在二进制中表示为 1010 ，左移一位后变成 10100 ，转换为十进制也就是 20，所以基本可以把左移看成以下公式 a * (2 ^ b) 算数右移 &gt;&gt; 10 >> 1 // -> 5 算数右移就是将二进制全部往右移动并去除多余的右边，10 在二进制中表示为 1010 ，右移一位后变成 101 ，转换为十进制也就是 5，所以基本可以把右移看成以下公式 int v = a / (2 ^ b) 右移很好用，比如可以用在二分算法中取中间值 13 >> 1 // -> 6 按位操作 按位与 每一位都为 1，结果才为 1 8 &amp; 7 // -> 0 // 1000 &amp; 0111 -> 0000 -> 0 按位或 其中一位为 1，结果就是 1 8 | 7 // -> 15 // 1000 | 0111 -> 1111 -> 15 按位异或 每一位都不同，结果才为 1 8 ^ 7 // -> 15 8 ^ 8 // -> 0 // 1000 ^ 0111 -> 1111 -> 15 // 1000 ^ 1000 -> 0000 -> 0 面试题：两个数不使用四则运算得出和 这道题中可以按位异或，因为按位异或就是不进位加法，8 ^ 8 = 0 如果进位了，就是 16 了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是 1 的位置，左边应该有一个进位 1，所以可以得出以下公式 a + b = (a ^ b) + ((a &amp; b) &lt;&lt; 1) ，然后通过迭代的方式模拟加法 function sum(a, b) { if (a == 0) return b if (b == 0) return a let newA = a ^ b let newB = (a &amp; b) &lt;&lt; 1 return sum(newA, newB) } 3.3 排序冒泡排序 冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 length - 1 的位置 以下是实现该算法的代码 function bubble(array) { checkArray(array); for (let i = array.length - 1; i > 0; i--) { // 从 0 到 `length - 1` 遍历 for (let j = 0; j &lt; i; j++) { if (array[j] > array[j + 1]) swap(array, j, j + 1) } } return array; } 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是O(n * n) 插入排序 入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作 以下是实现该算法的代码 function insertion(array) { checkArray(array); for (let i = 1; i &lt; array.length; i++) { for (let j = i - 1; j >= 0 &amp;&amp; array[j] > array[j + 1]; j--) swap(array, j, j + 1); } return array; } 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 选择排序 选择排序的原理如下。遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引 1 开始重复上述操作 以下是实现该算法的代码 function selection(array) { checkArray(array); for (let i = 0; i &lt; array.length - 1; i++) { let minIndex = i; for (let j = i + 1; j &lt; array.length; j++) { minIndex = array[j] &lt; array[minIndex] ? j : minIndex; } swap(array, i, minIndex); } return array; } 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 归并排序 归并排序的原理如下。递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组 [3, 1, 2, 8, 9, 7, 6]，中间数索引是 3，先排序数组 [3, 1, 2, 8] 。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组 [3, 1] 和 [2, 8] ，然后再排序数组 [1, 3, 2, 8] ，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组 [1, 2, 3, 8] 和 [6, 7, 9] 排序 以下是实现该算法的代码 function sort(array) { checkArray(array); mergeSort(array, 0, array.length - 1); return array; } function mergeSort(array, left, right) { // 左右索引相同说明已经只有一个数 if (left === right) return; // 等同于 `left + (right - left) / 2` // 相比 `(left + right) / 2` 来说更加安全，不会溢出 // 使用位运算是因为位运算比四则运算快 let mid = parseInt(left + ((right - left) >> 1)); mergeSort(array, left, mid); mergeSort(array, mid + 1, right); let help = []; let i = 0; let p1 = left; let p2 = mid + 1; while (p1 &lt;= mid &amp;&amp; p2 &lt;= right) { help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++]; } while (p1 &lt;= mid) { help[i++] = array[p1++]; } while (p2 &lt;= right) { help[i++] = array[p2++]; } for (let i = 0; i &lt; help.length; i++) { array[left + i] = help[i]; } return array; } 以上算法使用了递归的思想。递归的本质就是压栈，每递归执行一次函数，就将该函数的信息（比如参数，内部的变量，执行到的行数）压栈，直到遇到终止条件，然后出栈并继续执行函数。对于以上递归函数的调用轨迹如下 mergeSort(data, 0, 6) // mid = 3 mergeSort(data, 0, 3) // mid = 1 mergeSort(data, 0, 1) // mid = 0 mergeSort(data, 0, 0) // 遇到终止，回退到上一步 mergeSort(data, 1, 1) // 遇到终止，回退到上一步 // 排序 p1 = 0, p2 = mid + 1 = 1 // 回退到 `mergeSort(data, 0, 3)` 执行下一个递归 mergeSort(2, 3) // mid = 2 mergeSort(3, 3) // 遇到终止，回退到上一步 // 排序 p1 = 2, p2 = mid + 1 = 3 // 回退到 `mergeSort(data, 0, 3)` 执行合并逻辑 // 排序 p1 = 0, p2 = mid + 1 = 2 // 执行完毕回退 // 左边数组排序完毕，右边也是如上轨迹 该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的一半，并且最后把整个数组迭代了一次，所以得出表达式 2T(N / 2) + T(N) （T 代表时间，N 代表数据量）。根据该表达式可以套用 该公式 得出时间复杂度为 O(N * logN) 快排 快排的原理如下。随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。 以下是实现该算法的代码 function sort(array) { checkArray(array); quickSort(array, 0, array.length - 1); return array; } function quickSort(array, left, right) { if (left &lt; right) { swap(array, , right) // 随机取值，然后和末尾交换，这样做比固定取一个位置的复杂度略低 let indexs = part(array, parseInt(Math.random() * (right - left + 1)) + left, right); quickSort(array, left, indexs[0]); quickSort(array, indexs[1] + 1, right); } } function part(array, left, right) { let less = left - 1; let more = right; while (left &lt; more) { if (array[left] &lt; array[right]) { // 当前值比基准值小，`less` 和 `left` 都加一 ++less; ++left; } else if (array[left] > array[right]) { // 当前值比基准值大，将当前值和右边的值交换 // 并且不改变 `left`，因为当前换过来的值还没有判断过大小 swap(array, --more, left); } else { // 和基准值相同，只移动下标 left++; } } // 将基准值和比基准值大的第一个值交换位置 // 这样数组就变成 `[比基准值小, 基准值, 比基准值大]` swap(array, right, more); return [less, more]; } 该算法的复杂度和归并排序是相同的，但是额外空间复杂度比归并排序少，只需 O(logN)，并且相比归并排序来说，所需的常数时间也更少 面试题 Sort Colors：该题目来自 LeetCode，题目需要我们将 [2,0,2,1,1,0] 排序成 [0,0,1,1,2,2]，这个问题就可以使用三路快排的思想 var sortColors = function(nums) { let left = -1; let right = nums.length; let i = 0; // 下标如果遇到 right，说明已经排序完成 while (i &lt; right) { if (nums[i] == 0) { swap(nums, i++, ++left); } else if (nums[i] == 1) { i++; } else { swap(nums, i, --right); } } }; 3.4 链表反转单向链表 该题目来自 LeetCode，题目需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是一道面试常考题 var reverseList = function(head) { // 判断下变量边界问题 if (!head || !head.next) return head // 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null let pre = null let current = head let next // 判断当前节点是否为空 // 不为空就先获取当前节点的下一节点 // 然后把当前节点的 next 设为上一个节点 // 然后把 current 设为下一个节点，pre 设为当前节点 while(current) { next = current.next current.next = pre pre = current current = next } return pre }; 3.5 树二叉树的先序，中序，后序遍历 先序遍历表示先访问根节点，然后访问左节点，最后访问右节点。 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点 递归实现 递归实现相当简单，代码如下 function TreeNode(val) { this.val = val; this.left = this.right = null; } var traversal = function(root) { if (root) { // 先序 console.log(root); traversal(root.left); // 中序 // console.log(root); traversal(root.right); // 后序 // console.log(root); } }; 对于递归的实现来说，只需要理解每个节点都会被访问三次就明白为什么这样实现了 非递归实现 非递归实现使用了栈的结构，通过栈的先进后出模拟递归实现。 以下是先序遍历代码实现 function pre(root) { if (root) { let stack = []; // 先将根节点 push stack.push(root); // 判断栈中是否为空 while (stack.length > 0) { // 弹出栈顶元素 root = stack.pop(); console.log(root); // 因为先序遍历是先左后右，栈是先进后出结构 // 所以先 push 右边再 push 左边 if (root.right) { stack.push(root.right); } if (root.left) { stack.push(root.left); } } } } 以下是中序遍历代码实现 function mid(root) { if (root) { let stack = []; // 中序遍历是先左再根最后右 // 所以首先应该先把最左边节点遍历到底依次 push 进栈 // 当左边没有节点时，就打印栈顶元素，然后寻找右节点 // 对于最左边的叶节点来说，可以把它看成是两个 null 节点的父节点 // 左边打印不出东西就把父节点拿出来打印，然后再看右节点 while (stack.length > 0 || root) { if (root) { stack.push(root); root = root.left; } else { root = stack.pop(); console.log(root); root = root.right; } } } } 以下是后序遍历代码实现，该代码使用了两个栈来实现遍历，相比一个栈的遍历来说要容易理解很多 function pos(root) { if (root) { let stack1 = []; let stack2 = []; // 后序遍历是先左再右最后根 // 所以对于一个栈来说，应该先 push 根节点 // 然后 push 右节点，最后 push 左节点 stack1.push(root); while (stack1.length > 0) { root = stack1.pop(); stack2.push(root); if (root.left) { stack1.push(root.left); } if (root.right) { stack1.push(root.right); } } while (stack2.length > 0) { console.log(s2.pop()); } } } 中序遍历的前驱后继节点 实现这个算法的前提是节点有一个 parent 的指针指向父节点，根节点指向 null 如图所示，该树的中序遍历结果是 4, 2, 5, 1, 6, 3, 7 前驱节点 对于节点 2 来说，他的前驱节点就是 4 ，按照中序遍历原则，可以得出以下结论 如果选取的节点的左节点不为空，就找该左节点最右的节点。对于节点 1 来说，他有左节点 2 ，那么节点 2 的最右节点就是 5 如果左节点为空，且目标节点是父节点的右节点，那么前驱节点为父节点。对于节点 5 来说，没有左节点，且是节点 2 的右节点，所以节点 2 是前驱节点 如果左节点为空，且目标节点是父节点的左节点，向上寻找到第一个是父节点的右节点的节点。对于节点 6 来说，没有左节点，且是节点 3 的左节点，所以向上寻找到节点 1 ，发现节点 3 是节点 1 的右节点，所以节点 1 是节点 6 的前驱节点 以下是算法实现 function predecessor(node) { if (!node) return // 结论 1 if (node.left) { return getRight(node.left) } else { let parent = node.parent // 结论 2 3 的判断 while(parent &amp;&amp; parent.right === node) { node = parent parent = node.parent } return parent } } function getRight(node) { if (!node) return node = node.right while(node) node = node.right return node } 后继节点 对于节点 2 来说，他的后继节点就是 5 ，按照中序遍历原则，可以得出以下结论 如果有右节点，就找到该右节点的最左节点。对于节点 1 来说，他有右节点 3 ，那么节点 3 的最左节点就是 6 如果没有右节点，就向上遍历直到找到一个节点是父节点的左节点。对于节点 5 来说，没有右节点，就向上寻找到节点 2 ，该节点是父节点 1 的左节点，所以节点 1 是后继节点以下是算法实现 function successor(node) { if (!node) return // 结论 1 if (node.right) { return getLeft(node.right) } else { // 结论 2 let parent = node.parent // 判断 parent 为空 while(parent &amp;&amp; parent.left === node) { node = parent parent = node.parent } return parent } } function getLeft(node) { if (!node) return node = node.left while(node) node = node.left return node } 树的深度 树的最大深度：该题目来自 Leetcode，题目需要求出一颗二叉树的最大深度 以下是算法实现 var maxDepth = function(root) { if (!root) return 0 return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1 }; 对于该递归函数可以这样理解：一旦没有找到节点就会返回 0，每弹出一次递归函数就会加一，树有三层就会得到3","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"通识篇","slug":"通识篇","permalink":"http://www.chenya.site/tags/通识篇/"},{"name":"算法","slug":"算法","permalink":"http://www.chenya.site/tags/算法/"}]},{"title":"通识篇-02.计算机基础数据结构知识","slug":"002.前端知识体系/004.通识篇/002.通识篇之计算机基础数据结构知识","date":"2017-05-14T15:52:32.000Z","updated":"2019-09-16T01:57:01.492Z","comments":true,"path":"2017/05/14/002.前端知识体系/004.通识篇/002.通识篇之计算机基础数据结构知识/","link":"","permalink":"http://www.chenya.site/2017/05/14/002.前端知识体系/004.通识篇/002.通识篇之计算机基础数据结构知识/","excerpt":"","text":"二、数据结构2.1 栈概念 栈是一个线性结构，在计算机中是一个相当常见的数据结构。 栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则 实现 每种数据结构都可以用很多种方式来实现，其实可以把栈看成是数组的一个子集，所以这里使用数组来实现 class Stack { constructor() { this.stack = [] } push(item) { this.stack.push(item) } pop() { this.stack.pop() } peek() { return this.stack[this.getCount() - 1] } getCount() { return this.stack.length } isEmpty() { return this.getCount() === 0 } } 应用 匹配括号，可以通过栈的特性来完成 var isValid = function (s) { let map = { '(': -1, ')': 1, '[': -2, ']': 2, '{': -3, '}': 3 } let stack = [] for (let i = 0; i &lt; s.length; i++) { if (map[s[i]] &lt; 0) { stack.push(s[i]) } else { let last = stack.pop() if (map[last] + map[s[i]] != 0) return false } } if (stack.length > 0) return false return true }; 2.2 队列概念 队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则 实现 这里会讲解两种实现队列的方式，分别是单链队列和循环队列 单链队列 class Queue { constructor() { this.queue = [] } enQueue(item) { this.queue.push(item) } deQueue() { return this.queue.shift() } getHeader() { return this.queue[0] } getLength() { return this.queue.length } isEmpty() { return this.getLength() === 0 } } 因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 O(1) 的时间复杂度 循环队列 class SqQueue { constructor(length) { this.queue = new Array(length + 1) // 队头 this.first = 0 // 队尾 this.last = 0 // 当前队列大小 this.size = 0 } enQueue(item) { // 判断队尾 + 1 是否为队头 // 如果是就代表需要扩容数组 // % this.queue.length 是为了防止数组越界 if (this.first === (this.last + 1) % this.queue.length) { this.resize(this.getLength() * 2 + 1) } this.queue[this.last] = item this.size++ this.last = (this.last + 1) % this.queue.length } deQueue() { if (this.isEmpty()) { throw Error('Queue is empty') } let r = this.queue[this.first] this.queue[this.first] = null this.first = (this.first + 1) % this.queue.length this.size-- // 判断当前队列大小是否过小 // 为了保证不浪费空间，在队列空间等于总长度四分之一时 // 且不为 2 时缩小总长度为当前的一半 if (this.size === this.getLength() / 4 &amp;&amp; this.getLength() / 2 !== 0) { this.resize(this.getLength() / 2) } return r } getHeader() { if (this.isEmpty()) { throw Error('Queue is empty') } return this.queue[this.first] } getLength() { return this.queue.length - 1 } isEmpty() { return this.first === this.last } resize(length) { let q = new Array(length) for (let i = 0; i &lt; length; i++) { q[i] = this.queue[(i + this.first) % this.queue.length] } this.queue = q this.first = 0 this.last = this.size } } 2.3 链表概念 链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大 实现 单向链表 class Node { constructor(v, next) { this.value = v this.next = next } } class LinkList { constructor() { // 链表长度 this.size = 0 // 虚拟头部 this.dummyNode = new Node(null, null) } find(header, index, currentIndex) { if (index === currentIndex) return header return this.find(header.next, index, currentIndex + 1) } addNode(v, index) { this.checkIndex(index) // 当往链表末尾插入时，prev.next 为空 // 其他情况时，因为要插入节点，所以插入的节点 // 的 next 应该是 prev.next // 然后设置 prev.next 为插入的节点 let prev = this.find(this.dummyNode, index, 0) prev.next = new Node(v, prev.next) this.size++ return prev.next } insertNode(v, index) { return this.addNode(v, index) } addToFirst(v) { return this.addNode(v, 0) } addToLast(v) { return this.addNode(v, this.size) } removeNode(index, isLast) { this.checkIndex(index) index = isLast ? index - 1 : index let prev = this.find(this.dummyNode, index, 0) let node = prev.next prev.next = node.next node.next = null this.size-- return node } removeFirstNode() { return this.removeNode(0) } removeLastNode() { return this.removeNode(this.size, true) } checkIndex(index) { if (index &lt; 0 || index > this.size) throw Error('Index error') } getNode(index) { this.checkIndex(index) if (this.isEmpty()) return return this.find(this.dummyNode, index, 0).next } isEmpty() { return this.size === 0 } getSize() { return this.size } } 2.4 树二叉树 树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。 二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树 二分搜索树 二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小 这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率 实现 class Node { constructor(value) { this.value = value this.left = null this.right = null } } class BST { constructor() { this.root = null this.size = 0 } getSize() { return this.size } isEmpty() { return this.size === 0 } addNode(v) { this.root = this._addChild(this.root, v) } // 添加节点时，需要比较添加的节点值和当前 // 节点值的大小 _addChild(node, v) { if (!node) { this.size++ return new Node(v) } if (node.value > v) { node.left = this._addChild(node.left, v) } else if (node.value &lt; v) { node.right = this._addChild(node.right, v) } return node } } 以上是最基本的二分搜索树实现，接下来实现树的遍历。 对于树的遍历来说，有三种遍历方法，分别是先序遍历、中序遍历、后序遍历。三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可 // 先序遍历可用于打印树的结构 // 先序遍历先访问根节点，然后访问左节点，最后访问右节点。 preTraversal() { this._pre(this.root) } _pre(node) { if (node) { console.log(node.value) this._pre(node.left) this._pre(node.right) } } // 中序遍历可用于排序 // 对于 BST 来说，中序遍历可以实现一次遍历就 // 得到有序的值 // 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。 midTraversal() { this._mid(this.root) } _mid(node) { if (node) { this._mid(node.left) console.log(node.value) this._mid(node.right) } } // 后序遍历可用于先操作子节点 // 再操作父节点的场景 // 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。 backTraversal() { this._back(this.root) } _back(node) { if (node) { this._back(node.left) this._back(node.right) console.log(node.value) } } 以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成 breadthTraversal() { if (!this.root) return null let q = new Queue() // 将根节点入队 q.enQueue(this.root) // 循环判断队列是否为空，为空 // 代表树遍历完毕 while (!q.isEmpty()) { // 将队首出队，判断是否有左右子树 // 有的话，就先左后右入队 let n = q.deQueue() console.log(n.value) if (n.left) q.enQueue(n.left) if (n.right) q.enQueue(n.right) } } 接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反 getMin() { return this._getMin(this.root).value } _getMin(node) { if (!node.left) return node return this._getMin(node.left) } getMax() { return this._getMax(this.root).value } _getMax(node) { if (!node.right) return node return this._getMin(node.right) } 向上取整和向下取整，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断 floor(v) { let node = this._floor(this.root, v) return node ? node.value : null } _floor(node, v) { if (!node) return null if (node.value === v) return v // 如果当前节点值还比需要的值大，就继续递归 if (node.value > v) { return this._floor(node.left, v) } // 判断当前节点是否拥有右子树 let right = this._floor(node.right, v) if (right) return right return node } 排名，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 size 属性。该属性表示该节点下有多少子节点（包含自身） class Node { constructor(value) { this.value = value this.left = null this.right = null // 修改代码 this.size = 1 } } // 新增代码 _getSize(node) { return node ? node.size : 0 } _addChild(node, v) { if (!node) { return new Node(v) } if (node.value > v) { // 修改代码 node.size++ node.left = this._addChild(node.left, v) } else if (node.value &lt; v) { // 修改代码 node.size++ node.right = this._addChild(node.right, v) } return node } select(k) { let node = this._select(this.root, k) return node ? node.value : null } _select(node, k) { if (!node) return null // 先获取左子树下有几个节点 let size = node.left ? node.left.size : 0 // 判断 size 是否大于 k // 如果大于 k，代表所需要的节点在左节点 if (size > k) return this._select(node.left, k) // 如果小于 k，代表所需要的节点在右节点 // 注意这里需要重新计算 k，减去根节点除了右子树的节点数量 if (size &lt; k) return this._select(node.right, k - size - 1) return node } 接下来讲解的是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况 需要删除的节点没有子树 需要删除的节点只有一条子树 需要删除的节点有左右两条树 对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述 delectMin() { this.root = this._delectMin(this.root) console.log(this.root) } _delectMin(node) { // 一直递归左子树 // 如果左子树为空，就判断节点是否拥有右子树 // 有右子树的话就把需要删除的节点替换为右子树 if ((node != null) &amp; !node.left) return node.right node.left = this._delectMin(node.left) // 最后需要重新维护下节点的 `size` node.size = this._getSize(node.left) + this._getSize(node.right) + 1 return node } 最后讲解的就是如何删除任意节点了。对于这个操作，T.Hibbard 在 1962年提出了解决这个难题的办法，也就是如何解决第三种情况。 当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。 你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点 delect(v) { this.root = this._delect(this.root, v) } _delect(node, v) { if (!node) return null // 寻找的节点比当前节点小，去左子树找 if (node.value &lt; v) { node.right = this._delect(node.right, v) } else if (node.value > v) { // 寻找的节点比当前节点大，去右子树找 node.left = this._delect(node.left, v) } else { // 进入这个条件说明已经找到节点 // 先判断节点是否拥有拥有左右子树中的一个 // 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样 if (!node.left) return node.right if (!node.right) return node.left // 进入这里，代表节点拥有左右子树 // 先取出当前节点的后继结点，也就是取当前节点右子树的最小值 let min = this._getMin(node.right) // 取出最小值后，删除最小值 // 然后把删除节点后的子树赋值给最小值节点 min.right = this._delectMin(node.right) // 左子树不动 min.left = node.left node = min } // 维护 size node.size = this._getSize(node.left) + this._getSize(node.right) + 1 return node } 2.5 堆概念 堆通常是一个可以被看做一棵树的数组对象。 堆的实现通过构造二叉堆，实为二叉树的一种。这种数据结构具有以下性质。 任意节点小于（或大于）它的所有子节点堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。 优先队列也完全可以用堆来实现，操作是一模一样的。 实现大根堆 堆的每个节点的左边子节点索引是 i * 2 + 1，右边是 i * 2 + 2，父节点是 (i - 1) /2。 堆有两个核心的操作，分别是 shiftUp 和 shiftDown 。前者用于添加元素，后者用于删除根节点。 shiftUp 的核心思路是一路将节点与父节点对比大小，如果比父节点大，就和父节点交换位置。 shiftDown 的核心思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断父节点和两个子节点的大小，如果子节点大，就把最大的子节点和父节点交换 class MaxHeap { constructor() { this.heap = [] } size() { return this.heap.length } empty() { return this.size() == 0 } add(item) { this.heap.push(item) this._shiftUp(this.size() - 1) } removeMax() { this._shiftDown(0) } getParentIndex(k) { return parseInt((k - 1) / 2) } getLeftIndex(k) { return k * 2 + 1 } _shiftUp(k) { // 如果当前节点比父节点大，就交换 while (this.heap[k] > this.heap[this.getParentIndex(k)]) { this._swap(k, this.getParentIndex(k)) // 将索引变成父节点 k = this.getParentIndex(k) } } _shiftDown(k) { // 交换首位并删除末尾 this._swap(k, this.size() - 1) this.heap.splice(this.size() - 1, 1) // 判断节点是否有左孩子，因为二叉堆的特性，有右必有左 while (this.getLeftIndex(k) &lt; this.size()) { let j = this.getLeftIndex(k) // 判断是否有右孩子，并且右孩子是否大于左孩子 if (j + 1 &lt; this.size() &amp;&amp; this.heap[j + 1] > this.heap[j]) j++ // 判断父节点是否已经比子节点都大 if (this.heap[k] >= this.heap[j]) break this._swap(k, j) k = j } } _swap(left, right) { let rightValue = this.heap[right] this.heap[right] = this.heap[left] this.heap[left] = rightValue } }","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"通识篇","slug":"通识篇","permalink":"http://www.chenya.site/tags/通识篇/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.chenya.site/tags/数据结构/"}]},{"title":"通识篇-01.计算机基础网络知识","slug":"002.前端知识体系/004.通识篇/001.通识篇之计算机基础网络知识","date":"2017-05-04T04:34:12.000Z","updated":"2019-09-16T01:57:01.492Z","comments":true,"path":"2017/05/04/002.前端知识体系/004.通识篇/001.通识篇之计算机基础网络知识/","link":"","permalink":"http://www.chenya.site/2017/05/04/002.前端知识体系/004.通识篇/001.通识篇之计算机基础网络知识/","excerpt":"","text":"一、网络1 UDP1.1 面向报文 UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作 具体来说 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作 1.2 不可靠性 UDP 是无连接的，也就是说通信不需要建立和断开连接。 UDP 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的 UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP 1.3 高效 因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的 头部包含了以下几个数据 两个十六位的端口号，分别为源端口（可选字段）和目标端口整个数据报文的长度 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误 1.4 传输方式 UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能 2 TCP2.1 头部 TCP 头部比 UDP 头部复杂的多 对于 TCP 头部来说，以下几个字段是很重要的 Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文 Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到 Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制 标识符 URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。 ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。 RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。 SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。 FIN=1：该字段为一表示此报文段是一个释放连接的请求报文 2.2 状态机 HTTP 是无连接的，所以作为下层的 TCP 协议也是无连接的，虽然看似 TCP 将两端连接了起来，但是其实只是两端共同维护了一个状态 TCP 的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手。 在这之前需要了解一个重要的性能指标 RTT。该指标表示发送端发送数据到接收到对端数据所需的往返时间 建立连接三次握手 在 TCP 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据，所以 TCP 也是一个全双工的协议。 起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后遍进入 LISTEN 状态，此时开始等待客户端发送数据 第一次握手 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态，x 表示客户端的数据通信初始序号。 第二次握手 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。 第三次握手 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED状态，此时连接建立成功。 PS：第三次握手可以包含数据，通过 TCP 快速打开（TFO）技术。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同 cookie，下次握手时发出 cookie达到减少 RTT 的目的 你是否有疑惑明明两次握手就可以建立起连接，为什么还需要第三次应答？ 因为这是为了防止失效的连接请求报文段被服务端接收，从而产生错误 可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费 PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求 断开链接四次握手 TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。 第一次握手 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。 第二次握手 B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A。 第三次握手 B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。 PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。 第四次握手 A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。 为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？ 为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭 3 HTTP HTTP 协议是个无状态协议，不会保存状态 3.1 Post 和 Get 的区别 Get请求能缓存，Post 不能 Post 相对 Get安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。 Post 可以通过 request body来传输比 Get 更多的数据，Get没有这个技术 URL有长度限制，会影响 Get请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的 Post 支持更多的编码类型且不对数据类型限制 3.2 常见状态码 2XX 成功 200 OK，表示从客户端发来的请求在服务器端被正确处理 204 No content，表示请求成功，但响应报文不含实体的主体部分 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容 206 Partial Content，进行范围请求 3XX 重定向 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL 302 found，临时性重定向，表示资源临时被分配了新的 URL 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求 4XX 客户端错误 400 bad request，请求报文存在语法错误 401 unauthorized，表示发送的请求需要有通过 HTTP认证的认证信息 403 forbidden，表示对请求资源的访问被服务器拒绝 404 not found，表示在服务器上没有找到请求的资源 5XX 服务器错误 500 internal sever error，表示服务器端在执行请求时发生了错误 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 3.3 HTTP 首部 通用字段 作用 Cache-Control 控制缓存的行为 Connection 浏览器想要优先使用的连接类型，比如 keep-alive Date 创建报文时间 Pragma 报文指令 Via 代理服务器相关信息 Transfer-Encoding 传输编码方式 Upgrade 要求客户端升级协议 Warning 在内容中可能存在错误 请求字段 作用 Accept 能正确接收的媒体类型 Accept-Charset 能正确接收的字符集 Accept-Encoding 能正确接收的编码格式列表 Accept-Language 能正确接收的语言列表 Expect 期待服务端的指定行为 From 请求方邮箱地址 Host 服务器的域名 If-Match 两端资源标记比较 If-Modified-Since 本地资源未修改返回 304（比较时间） If-None-Match 本地资源未修改返回 304（比较标记） User-Agent 客户端信息 Max-Forwards 限制可被代理及网关转发的次数 Proxy-Authorization 向代理服务器发送验证信息 Range 请求某个内容的一部分 Referer 表示浏览器所访问的前一个页面 TE 传输编码方式 响应字段 作用 Accept-Ranges 是否支持某些种类的范围 Age 资源在代理缓存中存在的时间 ETag 资源标识 Location 客户端重定向到某个 URL Proxy-Authenticate 向代理服务器发送验证信息 Server 服务器名字 WWW-Authenticate 获取资源需要的验证信息 实体字段 作用 Allow 资源的正确请求方式 Content-Encoding 内容的编码格式 Content-Language 内容使用的语言 Content-Length request body 长度 Content-Location 返回数据的备用地址 Content-MD5 Base64加密格式的内容MD5检验值 Content-Range 内容的位置范围 Content-Type 内容的媒体类型 Expires 内容的过期时间 Last_modified 内容的最后修改时间 4 DNS DNS 的作用就是通过域名查询到具体的 IP。 因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么 在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 www.google.com 时，会进行一下操作 操作系统会首先在本地缓存中查询 没有的话会去系统配置的 DNS 服务器中查询 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器 然后去该服务器查询 google 这个二级域名 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"通识篇","slug":"通识篇","permalink":"http://www.chenya.site/tags/通识篇/"},{"name":"网络","slug":"网络","permalink":"http://www.chenya.site/tags/网络/"}]},{"title":"高级篇-08.框架通识进阶知识","slug":"002.前端知识体系/003.高级篇/008.高级篇之框架通识进阶知识","date":"2017-04-26T12:41:12.000Z","updated":"2019-09-16T01:57:01.492Z","comments":true,"path":"2017/04/26/002.前端知识体系/003.高级篇/008.高级篇之框架通识进阶知识/","link":"","permalink":"http://www.chenya.site/2017/04/26/002.前端知识体系/003.高级篇/008.高级篇之框架通识进阶知识/","excerpt":"","text":"八、框架通识1 MVVM MVVM 由以下三个内容组成 View：界面 Model：数据模型 ViewModel：作为桥梁负责沟通 View 和 Model 在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合。 ::: tip MVVM在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View复用这个 ViewModel。::: 在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。 脏数据检测 当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次。 脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数。所以低效也是相对的，这就仁者见仁智者见智了。 数据劫持 Vue 内部使用了 Object.defineProperty() 来实现双向绑定，通过这个函数可以监听到 set 和 get 的事件。 var data = { name: 'yck' } observe(data) let name = data.name // -> get value data.name = 'yyy' // -> change value function observe(obj) { // 判断类型 if (!obj || typeof obj !== 'object') { return } Object.keys(obj).forEach(key => { defineReactive(obj, key, obj[key]) }) } function defineReactive(obj, key, val) { // 递归子属性 observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter() { console.log('get value') return val }, set: function reactiveSetter(newVal) { console.log('change value') val = newVal } }) } 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅 &lt;div> {{name}} &lt;/div> 在解析如上模板代码时，遇到 就会给属性 name 添加发布订阅。 // 通过 Dep 解耦 class Dep { constructor() { this.subs = [] } addSub(sub) { // sub 是 Watcher 实例 this.subs.push(sub) } notify() { this.subs.forEach(sub => { sub.update() }) } } // 全局属性，通过该属性配置 Watcher Dep.target = null function update(value) { document.querySelector('div').innerText = value } class Watcher { constructor(obj, key, cb) { // 将 Dep.target 指向自己 // 然后触发属性的 getter 添加监听 // 最后将 Dep.target 置空 Dep.target = this this.cb = cb this.obj = obj this.key = key this.value = obj[key] Dep.target = null } update() { // 获得新值 this.value = this.obj[this.key] // 调用 update 方法更新 Dom this.cb(this.value) } } var data = { name: 'yck' } observe(data) // 模拟解析到 `{{name}}` 触发的操作 new Watcher(data, 'name', update) // update Dom innerText data.name = 'yyy' 接下来,对 defineReactive 函数进行改造 function defineReactive(obj, key, val) { // 递归子属性 observe(val) let dp = new Dep() Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter() { console.log('get value') // 将 Watcher 添加到订阅 if (Dep.target) { dp.addSub(Dep.target) } return val }, set: function reactiveSetter(newVal) { console.log('change value') val = newVal // 执行 watcher 的 update 方法 dp.notify() } }) } 以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加 Proxy 与 Object.defineProperty 对比 Object.defineProperty 虽然已经能够实现双向绑定了，但是他还是有缺陷的。 只能对属性进行数据劫持，所以需要深度遍历整个对象对于数组不能监听到数据的变化 虽然 Vue 中确实能检测到数组数据的变化，但是其实是使用了 hack的办法，并且也是有缺陷的。 const arrayProto = Array.prototype export const arrayMethods = Object.create(arrayProto) // hack 以下几个函数 const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse' ] methodsToPatch.forEach(function (method) { // 获得原生函数 const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) { // 调用原生函数 const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) { case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break } if (inserted) ob.observeArray(inserted) // 触发更新 ob.dep.notify() return result }) }) 反观 Proxy就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 Vue 也将在下个大版本中使用 Proxy 替换 Object.defineProperty let onWatch = (obj, setBind, getLogger) => { let handler = { get(target, property, receiver) { getLogger(target, property) return Reflect.get(target, property, receiver); }, set(target, property, value, receiver) { setBind(value); return Reflect.set(target, property, value); } }; return new Proxy(obj, handler); }; let obj = { a: 1 } let value let p = onWatch(obj, (v) => { value = v }, (target, property) => { console.log(`Get '${property}' = ${target[property]}`); }) p.a = 2 // bind `value` to `2` p.a // -> Get 'a' = 2 2 路由原理 前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式 hash 模式 history 模式 www.test.com/##/ 就是 Hash URL，当 ## 后面的哈希值发生变化时，不会向服务器请求数据，可以通过hashchange 事件来监听到 URL 的变化，从而进行跳转页面。 History模式是 HTML5 新推出的功能，比之 Hash URL 更加美观 3 Virtual Dom为什么需要 Virtual Dom 众所周知，操作 DOM 是很耗费性能的一件事情，既然如此，我们可以考虑通过 JS 对象来模拟 DOM 对象，毕竟操作 JS 对象比操作 DOM 省时的多 // 假设这里模拟一个 ul，其中包含了 5 个 li [1, 2, 3, 4, 5] // 这里替换上面的 li [1, 2, 5, 4] 从上述例子中，我们一眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置。 如果以上操作对应到 DOM 中，那么就是以下代码 // 删除第三个 li ul.childNodes[2].remove() // 将第四个 li 和第五个交换位置 let fromNode = ul.childNodes[4] let toNode = node.childNodes[3] let cloneFromNode = fromNode.cloneNode(true) let cloenToNode = toNode.cloneNode(true) ul.replaceChild(cloneFromNode, toNode) ul.replaceChild(cloenToNode, fromNode) 当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 Vue 和 React 中官方推荐列表里的节点使用唯一的 key 来保证性能。 那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM 以下是一个 JS 对象模拟 DOM 对象的简单实现 export default class Element { /** * @param {String} tag 'div' * @param {Object} props { class: 'item' } * @param {Array} children [ Element1, 'text'] * @param {String} key option */ constructor(tag, props, children, key) { this.tag = tag this.props = props if (Array.isArray(children)) { this.children = children } else if (isString(children)) { this.key = children this.children = null } if (key) this.key = key } // 渲染 render() { let root = this._createElement( this.tag, this.props, this.children, this.key ) document.body.appendChild(root) return root } create() { return this._createElement(this.tag, this.props, this.children, this.key) } // 创建节点 _createElement(tag, props, child, key) { // 通过 tag 创建节点 let el = document.createElement(tag) // 设置节点属性 for (const key in props) { if (props.hasOwnProperty(key)) { const value = props[key] el.setAttribute(key, value) } } if (key) { el.setAttribute('key', key) } // 递归添加子节点 if (child) { child.forEach(element => { let child if (element instanceof Element) { child = this._createElement( element.tag, element.props, element.children, element.key ) } else { child = document.createTextNode(element) } el.appendChild(child) }) } return el } } Virtual Dom 算法简述 既然我们已经通过 JS 来模拟实现了 DOM，那么接下来的难点就在于如何判断旧的对象和新的对象之间的差异。 DOM 是多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React团队优化了算法，实现了 O(n) 的复杂度来对比差异。 实现O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素 所以判断差异的算法就分为了两步 首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异 一旦节点有子元素，就去判断子元素是否有不同 Virtual Dom 算法实现 树的递归 首先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对比会有几种情况 新的节点的 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了 新的节点的 tagName 和 key（可能都没有）和旧的相同，开始遍历子树 没有新的节点，那么什么都不用做 import { StateEnums, isString, move } from './util' import Element from './element' export default function diff(oldDomTree, newDomTree) { // 用于记录差异 let pathchs = {} // 一开始的索引为 0 dfs(oldDomTree, newDomTree, 0, pathchs) return pathchs } function dfs(oldNode, newNode, index, patches) { // 用于保存子树的更改 let curPatches = [] // 需要判断三种情况 // 1.没有新的节点，那么什么都不用做 // 2.新的节点的 tagName 和 `key` 和旧的不同，就替换 // 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树 if (!newNode) { } else if (newNode.tag === oldNode.tag &amp;&amp; newNode.key === oldNode.key) { // 判断属性是否变更 let props = diffProps(oldNode.props, newNode.props) if (props.length) curPatches.push({ type: StateEnums.ChangeProps, props }) // 遍历子树 diffChildren(oldNode.children, newNode.children, index, patches) } else { // 节点不同，需要替换 curPatches.push({ type: StateEnums.Replace, node: newNode }) } if (curPatches.length) { if (patches[index]) { patches[index] = patches[index].concat(curPatches) } else { patches[index] = curPatches } } } 判断属性的更改 判断属性的更改也分三个步骤 遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中 遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化 在第二步中同时查看是否有属性不存在与旧的属性列列表中 function diffProps(oldProps, newProps) { // 判断 Props 分以下三步骤 // 先遍历 oldProps 查看是否存在删除的属性 // 然后遍历 newProps 查看是否有属性值被修改 // 最后查看是否有属性新增 let change = [] for (const key in oldProps) { if (oldProps.hasOwnProperty(key) &amp;&amp; !newProps[key]) { change.push({ prop: key }) } } for (const key in newProps) { if (newProps.hasOwnProperty(key)) { const prop = newProps[key] if (oldProps[key] &amp;&amp; oldProps[key] !== newProps[key]) { change.push({ prop: key, value: newProps[key] }) } else if (!oldProps[key]) { change.push({ prop: key, value: newProps[key] }) } } } return change } 判断列表差异算法实现 这个算法是整个 Virtual Dom 中最核心的算法，且让我一一为你道来。 这里的主要步骤其实和判断属性差异是类似的，也是分为三步 遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中 遍历新的节点列表，判断是否有新的节点 在第二步中同时判断节点是否有移动 PS：该算法只对有 key 的节点做处理 function listDiff(oldList, newList, index, patches) { // 为了遍历方便，先取出两个 list 的所有 keys let oldKeys = getKeys(oldList) let newKeys = getKeys(newList) let changes = [] // 用于保存变更后的节点数据 // 使用该数组保存有以下好处 // 1.可以正确获得被删除节点索引 // 2.交换节点位置只需要操作一遍 DOM // 3.用于 `diffChildren` 函数中的判断，只需要遍历 // 两个树中都存在的节点，而对于新增或者删除的节点来说，完全没必要 // 再去判断一遍 let list = [] oldList &amp;&amp; oldList.forEach(item => { let key = item.key if (isString(item)) { key = item } // 寻找新的 children 中是否含有当前节点 // 没有的话需要删除 let index = newKeys.indexOf(key) if (index === -1) { list.push(null) } else list.push(key) }) // 遍历变更后的数组 let length = list.length // 因为删除数组元素是会更改索引的 // 所有从后往前删可以保证索引不变 for (let i = length - 1; i >= 0; i--) { // 判断当前元素是否为空，为空表示需要删除 if (!list[i]) { list.splice(i, 1) changes.push({ type: StateEnums.Remove, index: i }) } } // 遍历新的 list，判断是否有节点新增或移动 // 同时也对 `list` 做节点新增和移动节点的操作 newList &amp;&amp; newList.forEach((item, i) => { let key = item.key if (isString(item)) { key = item } // 寻找旧的 children 中是否含有当前节点 let index = list.indexOf(key) // 没找到代表新节点，需要插入 if (index === -1 || key == null) { changes.push({ type: StateEnums.Insert, node: item, index: i }) list.splice(i, 0, key) } else { // 找到了，需要判断是否需要移动 if (index !== i) { changes.push({ type: StateEnums.Move, from: index, to: i }) move(list, index, i) } } }) return { changes, list } } function getKeys(list) { let keys = [] let text list &amp;&amp; list.forEach(item => { let key if (isString(item)) { key = [item] } else if (item instanceof Element) { key = item.key } keys.push(key) }) return keys } 遍历子元素打标识 对于这个函数来说，主要功能就两个 判断两个列表差异 给节点打上标记 总体来说，该函数实现的功能很简单 function diffChildren(oldChild, newChild, index, patches) { let { changes, list } = listDiff(oldChild, newChild, index, patches) if (changes.length) { if (patches[index]) { patches[index] = patches[index].concat(changes) } else { patches[index] = changes } } // 记录上一个遍历过的节点 let last = null oldChild &amp;&amp; oldChild.forEach((item, i) => { let child = item &amp;&amp; item.children if (child) { index = last &amp;&amp; last.children ? index + last.children.length + 1 : index + 1 let keyIndex = list.indexOf(item.key) let node = newChild[keyIndex] // 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历 if (node) { dfs(item, node, index, patches) } } else index += 1 last = item }) } 渲染差异 通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新 DOM 了，下面就让我们来看看 Virtual Dom 算法的最后一步骤 这个函数主要两个功能 深度遍历树，将需要做变更操作的取出来 局部更新 DOM let index = 0 export default function patch(node, patchs) { let changes = patchs[index] let childNodes = node &amp;&amp; node.childNodes // 这里的深度遍历和 diff 中是一样的 if (!childNodes) index += 1 if (changes &amp;&amp; changes.length &amp;&amp; patchs[index]) { changeDom(node, changes) } let last = null if (childNodes &amp;&amp; childNodes.length) { childNodes.forEach((item, i) => { index = last &amp;&amp; last.children ? index + last.children.length + 1 : index + 1 patch(item, patchs) last = item }) } } function changeDom(node, changes, noChild) { changes &amp;&amp; changes.forEach(change => { let { type } = change switch (type) { case StateEnums.ChangeProps: let { props } = change props.forEach(item => { if (item.value) { node.setAttribute(item.prop, item.value) } else { node.removeAttribute(item.prop) } }) break case StateEnums.Remove: node.childNodes[change.index].remove() break case StateEnums.Insert: let dom if (isString(change.node)) { dom = document.createTextNode(change.node) } else if (change.node instanceof Element) { dom = change.node.create() } node.insertBefore(dom, node.childNodes[change.index]) break case StateEnums.Replace: node.parentNode.replaceChild(change.node.create(), node) break case StateEnums.Move: let fromNode = node.childNodes[change.from] let toNode = node.childNodes[change.to] let cloneFromNode = fromNode.cloneNode(true) let cloenToNode = toNode.cloneNode(true) node.replaceChild(cloneFromNode, toNode) node.replaceChild(cloenToNode, fromNode) break default: break } }) } Virtual Dom 算法的实现也就是以下三步 通过 JS 来模拟创建 DOM 对象 判断两个对象的差异 渲染差异 let test4 = new Element('div', { class: 'my-div' }, ['test4']) let test5 = new Element('ul', { class: 'my-div' }, ['test5']) let test1 = new Element('div', { class: 'my-div' }, [test4]) let test2 = new Element('div', { id: '11' }, [test5, test4]) let root = test1.render() let pathchs = diff(test1, test2) console.log(pathchs) setTimeout(() => { console.log('开始更新') patch(root, pathchs) console.log('结束更新') }, 1000)","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"高级篇","slug":"高级篇","permalink":"http://www.chenya.site/tags/高级篇/"},{"name":"框架通识","slug":"框架通识","permalink":"http://www.chenya.site/tags/框架通识/"}]},{"title":"高级篇-07.Vue进阶知识","slug":"002.前端知识体系/003.高级篇/007.高级篇之Vue进阶知识","date":"2017-04-23T15:43:55.000Z","updated":"2019-09-16T01:57:01.491Z","comments":true,"path":"2017/04/23/002.前端知识体系/003.高级篇/007.高级篇之Vue进阶知识/","link":"","permalink":"http://www.chenya.site/2017/04/23/002.前端知识体系/003.高级篇/007.高级篇之Vue进阶知识/","excerpt":"","text":"七、Vue1 对于MVVM的理解 MVVM 是 Model-View-ViewModel 的缩写 Model 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。 View 代表UI 组件，它负责将数据模型转化成UI 展现出来。 ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View 在MVVM架构下，View和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model层连接了起来，而View和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理 2 请详细说下你对vue生命周期的理解 答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后 创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后：当data变化时，会触发beforeUpdate和updated方法 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 什么是vue生命周期？ 答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。 vue生命周期的作用是什么？ 答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 vue生命周期总共有几个阶段？ 答：它可以总共分为8个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。 第一次页面加载会触发哪几个钩子？ 答：会触发下面这几个beforeCreate、created、beforeMount、mounted 。 DOM 渲染在哪个周期中就已经完成？ 答：DOM 渲染在 mounted 中就已经完成了 3 Vue实现数据双向绑定的原理：Object.defineProperty() vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty() 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue追踪依赖，在属性被访问和修改时通知变化。 vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 双大括号），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。 4 Vue组件间的参数传递父组件与子组件传值 父组件传给子组件：子组件通过props方法接受数据； 子组件传给父组件： $emit 方法传递参数 非父子组件间的数据传递，兄弟组件传值 eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用VUEX，具体来说看需求） 5 Vue的路由实现：hash模式 和 history模式 hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用 window.location.hash 读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。 history模式：history采用HTML5的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更 5 vue路由的钩子函数 首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。 beforeEach主要有3个参数to，from，next。 to：route即将进入的目标路由对象。 from：route当前导航正要离开的路由。 next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转 6 vuex是什么？怎么使用？哪种功能场景使用它？ 只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。 在main.js引入store，注入。新建了一个目录store，… export 场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车 vuex state：Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。 mutations：mutations定义的方法动态修改Vuex 的 store 中的状态或数据 getters：类似vue的计算属性，主要用来过滤一些数据。 action：actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action image.png modules：项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构非常清晰，方便管理 image.png 7 v-if 和 v-show 区别 答：v-if按照条件是否渲染，v-show是display的block或none； 8 $route和$router的区别 $route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。 而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等 9 如何让CSS只在当前组件中起作用? 将当前组件的&lt;style&gt;修改为&lt;style scoped&gt; 10 &lt;keep-alive&gt;&lt;/keep-alive&gt;的作用是什么? &lt;keep-alive&gt;&lt;/keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染 比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用&lt;keep-alive&gt;&lt;/keep-alive&gt;进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染 11 指令v-el的作用是什么? 提供一个在页面上已存在的 DOM元素作为 Vue实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例, 12 在Vue中使用插件的步骤 采用ES6的import ... from ...语法或CommonJS的require()方法引入插件 使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true }) 13 请列举出3个Vue中常用的生命周期钩子函数? created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见 mounted: el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted被调用时 vm.$el 也在文档内。 activated: keep-alive组件激活时调用 14 \bvue-cli 工程技术集合介绍问题一：构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？ vue.js：vue-cli工程的核心，主要特点是 双向数据绑定 和 组件系统。 vue-router：vue官方推荐使用的路由框架。 vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护vue组件间共用的一些 变量 和 方法。 axios（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http请求，基于 Promise 设计。 vuex等：一个专为vue设计的移动端UI组件库。 创建一个emit.js文件，用于vue事件机制的管理。 webpack：模块加载和vue-cli工程打包器。 问题二：vue-cli 工程常用的 npm 命令有哪些？ 下载 node_modules 资源包的命令： npm install 启动 vue-cli 开发环境的 npm命令： npm run dev vue-cli 生成 生产环境部署资源 的 npm命令： npm run build 用于查看 vue-cli 生产环境部署资源文件大小的 npm命令： npm run build --report 在浏览器上自动弹出一个 展示 vue-cli 工程打包后 app.js、manifest.js、vendor.js 文件里面所包含代码的页面。可以具此优化 vue-cli 生产环境部署的静态资源，提升 页面 的加载速度 15 NextTick nextTick可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM 16 vue的优点是什么？ 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的&quot;View&quot;上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写 17 路由之间跳转？声明式（标签跳转） &lt;router-link :to=&quot;index&quot;&gt; 编程式（ js跳转） router.push(&#39;index&#39;) 18 实现 Vue SSR 其基本实现原理 app.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。 webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。 服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。 客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store里取数据。首屏的动态数据通过 window.__INITIAL_STATE__发送到客户端 Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的 Vue SSR需要做的事多点（输出完整 HTML），除了complier -&gt; vnode，还需如数据获取填充至 HTML、客户端混合（hydration）、缓存等等。相比于其他模板引擎（ejs, jade 等），最终要实现的目的是一样的，性能上可能要差点 19 Vue 组件 data 为什么必须是函数 每个组件都是 Vue 的实例。 组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他 20 Vue computed 实现 建立与其他属性（如：data、 Store）的联系； 属性改变后，通知计算属性重新计算 实现时，主要如下 初始化 data， 使用 Object.defineProperty 把这些属性全部转为 getter/setter。 初始化 computed, 遍历 computed 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。 Object.defineProperty getter 依赖收集。用于依赖发生变化时，触发属性重新计算。 若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集 21 Vue complier 实现 模板解析这种事，本质是将数据转化为一段 html ，最开始出现在后端，经过各种处理吐给前端。随着各种 mv* 的兴起，模板解析交由前端处理。 总的来说，Vue complier 是将 template 转化成一个 render 字符串。 可以简单理解成以下步骤： parse 过程，将 template 利用正则转化成AST 抽象语法树。 optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。 generate 过程，生成 render 字符串 22 怎么快速定位哪个组件出现性能问题 用 timeline 工具。 大意是通过 timeline 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"高级篇","slug":"高级篇","permalink":"http://www.chenya.site/tags/高级篇/"},{"name":"Vue","slug":"Vue","permalink":"http://www.chenya.site/tags/Vue/"}]},{"title":"高级篇-06.React进阶知识","slug":"002.前端知识体系/003.高级篇/006.高级篇之React进阶知识","date":"2017-04-03T15:51:28.000Z","updated":"2019-09-16T01:57:01.491Z","comments":true,"path":"2017/04/03/002.前端知识体系/003.高级篇/006.高级篇之React进阶知识/","link":"","permalink":"http://www.chenya.site/2017/04/03/002.前端知识体系/003.高级篇/006.高级篇之React进阶知识/","excerpt":"","text":"六、React1 React 中 keys 的作用是什么？ Keys是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识 在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性 2 传入 setState 函数的第二个参数的作用是什么？ 该函数会在setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成： this.setState( { username: 'tylermcginnis33' }, () => console.log('setState has finished and the component has re-rendered.') ) this.setState((prevState, props) => { return { streak: prevState.streak + props.count } }) 3 React 中 refs 的作用是什么 Refs 是 React 提供给我们的安全访问 DOM元素或者某个组件实例的句柄 可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回 4 在生命周期中的哪一步你应该发起 AJAX 请求 我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下 React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。 如果我们将AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题 5 shouldComponentUpdate 的作用 shouldComponentUpdate 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新 6 如何告诉 React 它应该编译生产环境版 通常情况下我们会使用 Webpack 的 DefinePlugin 方法来将 NODE_ENV 变量值设置为 production。编译版本中 React会忽略 propType 验证以及其他的告警信息，同时还会降低代码库的大小，React 使用了 Uglify 插件来移除生产环境下不必要的注释等信息 7 概述下 React 中的事件处理逻辑 为了解决跨浏览器兼容性问题，React 会将浏览器原生事件（Browser Native Event）封装为合成事件（SyntheticEvent）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的 8 createElement 与 cloneElement 的区别是什么 createElement 函数是 JSX 编译之后使用的创建 React Element 的函数，而 cloneElement 则是用于复制某个元素并传入新的 Props 9 redux中间件 中间件提供第三方插件的模式，自定义拦截 action -&gt; reducer 的过程。变为 action -&gt; middlewares -&gt; reducer。这种机制可以让我们改变数据流，实现如异步action ，action 过滤，日志输出，异常报告等功能 redux-logger：提供日志输出 redux-thunk：处理异步操作 redux-promise：处理异步操作，actionCreator的返回值是promise 10 redux有什么缺点 一个组件所需要的数据，必须由父组件传过来，而不能像flux中直接从store取。 当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的shouldComponentUpdate进行判断。 11 react组件的划分业务组件技术组件？ 根据组件的职责通常把组件分为UI组件和容器组件。 UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。 两者通过React-Redux 提供connect方法联系起来 12 react生命周期函数初始化阶段 getDefaultProps:获取实例的默认属性 getInitialState:获取每个实例的初始化状态 componentWillMount：组件即将被装载、渲染到页面上 render:组件在这里生成虚拟的DOM节点 omponentDidMount:组件真正在被装载之后 运行中状态 componentWillReceiveProps:组件将要接收到属性的时候调用 shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止render调用，后面的函数不会被继续执行了） componentWillUpdate:组件即将更新不能修改属性和状态 render:组件重新描绘 componentDidUpdate:组件已经更新 销毁阶段 componentWillUnmount:组件即将销毁 13 react性能优化是哪个周期函数 shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom。因为dom的描绘非常消耗性能，如果我们能在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能 14 为什么虚拟dom会提高性能 虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能 具体实现步骤如下 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新 15 diff算法? 把树形结构按照层级分解，只比较同级元素。 给列表结构的每个单元添加唯一的key属性，方便比较。 React 只会匹配相同 class 的 component（这里面的class指的是组件的名字） 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 - dirty.到每一个事件循环结束, React 检查所有标记 dirty的 component重新绘制. 选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能 16 react性能优化方案 重写shouldComponentUpdate来避免不必要的dom操作 使用 production 版本的react.js 使用key来帮助React识别列表中所有子组件的最小变化 16 简述flux 思想 Flux 的最大特点，就是数据的”单向流动”。 用户访问 View View发出用户的 Action Dispatcher 收到Action，要求 Store 进行相应的更新 Store 更新后，发出一个&quot;change&quot;事件 View 收到&quot;change&quot;事件后，更新页面 17 说说你用react有什么坑点？1. JSX做表达式判断时候，需要强转为boolean类型 如果不使用 !!b 进行强转数据类型，会在页面里面输出 0。 render() { const b = 0; return &lt;div> { !!b &amp;&amp; &lt;div>这是一段文本&lt;/div> } &lt;/div> } 2. 尽量不要在 componentWillReviceProps 里使用 setState，如果一定要使用，那么需要判断结束条件，不然会出现无限重渲染，导致页面崩溃 3. 给组件添加ref时候，尽量不要使用匿名函数，因为当组件更新的时候，匿名函数会被当做新的prop处理，让ref属性接受到新函数的时候，react内部会先清空ref，也就是会以null为回调参数先执行一次ref这个props，然后在以该组件的实例执行一次ref，所以用匿名函数做ref的时候，有的时候去ref赋值后的属性会取到null 4. 遍历子节点的时候，不要用 index 作为组件的 key 进行传入 18 我现在有一个button，要用react在上面绑定点击事件，要怎么做？class Demo { render() { return &lt;button onClick={(e) => { alert('我点击了按钮') }}> 按钮 &lt;/button> } } 你觉得你这样设置点击事件会有什么问题吗？ 由于onClick使用的是匿名函数，所有每次重渲染的时候，会把该onClick当做一个新的prop来处理，会将内部缓存的onClick事件进行重新赋值，所以相对直接使用函数来说，可能有一点的性能下降 修改 class Demo { onClick = (e) => { alert('我点击了按钮') } render() { return &lt;button onClick={this.onClick}> 按钮 &lt;/button> } 19 react 的虚拟dom是怎么实现的 首先说说为什么要使用Virturl DOM，因为操作真实DOM的耗费的性能代价太高，所以react内部使用js实现了一套dom结构，在每次操作在和真实dom之前，使用实现好的diff算法，对虚拟dom进行比较，递归找出有变化的dom节点，然后对其进行更新操作。为了实现虚拟DOM，我们需要把每一种节点类型抽象成对象，每一种节点类型有自己的属性，也就是prop，每次进行diff的时候，react会先比较该节点类型，假如节点类型不一样，那么react会直接删除该节点，然后直接创建新的节点插入到其中，假如节点类型一样，那么会比较prop是否有更新，假如有prop不一样，那么react会判定该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，一层一层往下，直到没有子节点 20 react 的渲染过程中，兄弟节点之间是怎么处理的？也就是key值不一样的时候 通常我们输出节点的时候都是map一个数组然后返回一个ReactNode，为了方便react内部进行优化，我们必须给每一个reactNode添加key，这个key prop在设计值处不是给开发者用的，而是给react用的，大概的作用就是给每一个reactNode添加一个身份标识，方便react进行识别，在重渲染过程中，如果key一样，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新，如果key不一样，则react先销毁该组件，然后重新创建该组件 21 那给我介绍一下react 以前我们没有jquery的时候，我们大概的流程是从后端通过ajax获取到数据然后使用jquery生成dom结果然后更新到页面当中，但是随着业务发展，我们的项目可能会越来越复杂，我们每次请求到数据，或则数据有更改的时候，我们又需要重新组装一次dom结构，然后更新页面，这样我们手动同步dom和数据的成本就越来越高，而且频繁的操作dom，也使我我们页面的性能慢慢的降低。 这个时候mvvm出现了，mvvm的双向数据绑定可以让我们在数据修改的同时同步dom的更新，dom的更新也可以直接同步我们数据的更改，这个特定可以大大降低我们手动去维护dom更新的成本，mvvm为react的特性之一，虽然react属于单项数据流，需要我们手动实现双向数据绑定。 有了mvvm还不够，因为如果每次有数据做了更改，然后我们都全量更新dom结构的话，也没办法解决我们频繁操作dom结构(降低了页面性能)的问题，为了解决这个问题，react内部实现了一套虚拟dom结构，也就是用js实现的一套dom结构，他的作用是讲真实dom在js中做一套缓存，每次有数据更改的时候，react内部先使用算法，也就是鼎鼎有名的diff算法对dom结构进行对比，找到那些我们需要新增、更新、删除的dom节点，然后一次性对真实DOM进行更新，这样就大大降低了操作dom的次数。那么diff算法是怎么运作的呢，首先，diff针对类型不同的节点，会直接判定原来节点需要卸载并且用新的节点来装载卸载的节点的位置；针对于节点类型相同的节点，会对比这个节点的所有属性，如果节点的所有属性相同，那么判定这个节点不需要更新，如果节点属性不相同，那么会判定这个节点需要更新，react会更新并重渲染这个节点。 react设计之初是主要负责UI层的渲染，虽然每个组件有自己的state，state表示组件的状态，当状态需要变化的时候，需要使用setState更新我们的组件，但是，我们想通过一个组件重渲染它的兄弟组件，我们就需要将组件的状态提升到父组件当中，让父组件的状态来控制这两个组件的重渲染，当我们组件的层次越来越深的时候，状态需要一直往下传，无疑加大了我们代码的复杂度，我们需要一个状态管理中心，来帮我们管理我们状态state。 这个时候，redux出现了，我们可以将所有的state交给redux去管理，当我们的某一个state有变化的时候，依赖到这个state的组件就会进行一次重渲染，这样就解决了我们的我们需要一直把state往下传的问题。redux有action、reducer的概念，action为唯一修改state的来源，reducer为唯一确定state如何变化的入口，这使得redux的数据流非常规范，同时也暴露出了redux代码的复杂，本来那么简单的功能，却需要完成那么多的代码。 后来，社区就出现了另外一套解决方案，也就是mobx，它推崇代码简约易懂，只需要定义一个可观测的对象，然后哪个组价使用到这个可观测的对象，并且这个对象的数据有更改，那么这个组件就会重渲染，而且mobx内部也做好了是否重渲染组件的生命周期shouldUpdateComponent，不建议开发者进行更改，这使得我们使用mobx开发项目的时候可以简单快速的完成很多功能，连redux的作者也推荐使用mobx进行项目开发。但是，随着项目的不断变大，mobx也不断暴露出了它的缺点，就是数据流太随意，出了bug之后不好追溯数据的流向，这个缺点正好体现出了redux的优点所在，所以针对于小项目来说，社区推荐使用mobx，对大项目推荐使用redux","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"高级篇","slug":"高级篇","permalink":"http://www.chenya.site/tags/高级篇/"},{"name":"React","slug":"React","permalink":"http://www.chenya.site/tags/React/"}]},{"title":"高级篇-05.小程序进阶知识","slug":"002.前端知识体系/003.高级篇/005.高级篇之小程序进阶知识","date":"2017-03-09T02:25:48.000Z","updated":"2019-09-16T01:57:01.491Z","comments":true,"path":"2017/03/09/002.前端知识体系/003.高级篇/005.高级篇之小程序进阶知识/","link":"","permalink":"http://www.chenya.site/2017/03/09/002.前端知识体系/003.高级篇/005.高级篇之小程序进阶知识/","excerpt":"","text":"五、小程序1 登录unionid和openid 了解小程序登陆之前，我们写了解下小程序/公众号登录涉及到两个最关键的用户标识： OpenId 是一个用户对于一个小程序／公众号的标识，开发者可以通过这个标识识别出用户。 UnionId 是一个用户对于同主体微信小程序／公众号／APP的标识，开发者需要在微信开放平台下绑定相同账号的主体。开发者可通过UnionId，实现多个小程序、公众号、甚至APP 之间的数据互通了。 关键Api wx.login 官方提供的登录能力 wx.checkSession校验用户当前的session_key是否有效 wx.authorize 提前向用户发起授权请求 wx.getUserInfo 获取用户基本信息 登录流程设计 利用现有登录体系 直接复用现有系统的登录体系，只需要在小程序端设计用户名，密码/验证码输入页面，便可以简便的实现登录，只需要保持良好的用户体验即可 利用OpenId 创建用户体系 OpenId 是一个小程序对于一个用户的标识，利用这一点我们可以轻松的实现一套基于小程序的用户体系，值得一提的是这种用户体系对用户的打扰最低，可以实现静默登录。具体步骤如下 小程序客户端通过 wx.login 获取 code 传递 code 向服务端，服务端拿到 code 调用微信登录凭证校验接口，微信服务器返回 openid 和会话密钥 session_key ，此时开发者服务端便可以利用 openid 生成用户入库，再向小程序客户端返回自定义登录态 小程序客户端缓存 （通过storage）自定义登录态（token），后续调用接口时携带该登录态作为用户身份标识即可 利用 Unionid 创建用户体系 如果想实现多个小程序，公众号，已有登录系统的数据互通，可以通过获取到用户 unionid 的方式建立用户体系。因为 unionid 在同一开放平台下的所所有应用都是相同的，通过 unionid 建立的用户体系即可实现全平台数据的互通，更方便的接入原有的功能，那如何获取 unionid 呢，有以下两种方式 如果户关注了某个相同主体公众号，或曾经在某个相同主体App、公众号上进行过微信登录授权，通过 wx.login 可以直接获取 到 unionid 结合 wx.getUserInfo 和 &lt;button open-type=&quot;getUserInfo&quot;&gt;&lt;button/&gt; 这两种方式引导用户主动授权，主动授权后通过返回的信息和服务端交互 (这里有一步需要服务端解密数据的过程，很简单，微信提供了示例代码) 即可拿到 unionid 建立用户体系， 然后由服务端返回登录态，本地记录即可实现登录，附上微信提供的最佳实践 调用 wx.login 获取 code，然后从微信后端换取到 session_key，用于解密 getUserInfo返回的敏感数据 使用 wx.getSetting 获取用户的授权情况 如果用户已经授权，直接调用 API wx.getUserInfo 获取用户最新的信息； 用户未授权，在界面中显示一个按钮提示用户登入，当用户点击并授权后就获取到用户的最新信息 获取到用户数据后可以进行展示或者发送给自己的后端。 ::: warning 注意事项 需要获取 unionid 形式的登录体系，在以前（18年4月之前）是通过以下这种方式来实现，但后续微信做了调整（因为一进入小程序，主动弹起各种授权弹窗的这种形式，比较容易导致用户流失），调整为必须使用按钮引导用户主动授权的方式，这次调整对开发者影响较大，开发者需要注意遵守微信的规则，并及时和业务方沟通业务形式，不要存在侥幸心理，以防造成小程序不过审等情况 wx.login(获取code) ===&gt; wx.getUserInfo(用户授权) ===&gt; 获取 unionid 因为小程序不存在 cookie 的概念， 登录态必须缓存在本地，因此强烈建议为登录态设置过期时间 值得一提的是如果需要支持风控安全校验，多平台登录等功能，可能需要加入一些公共参数，例如platform，channel，deviceParam等参数。在和服务端确定方案时，作为前端同学应该及时提出这些合理的建议，设计合理的系统。 openid ， unionid 不要在接口中明文传输，这是一种危险的行为，同时也很不专业::: 2 图片导出 这是一种常见的引流方式，一般同时会在图片中附加一个小程序二维码。 基本原理 借助 canvas 元素，将需要导出的样式首先在 canvas 画布上绘制出来 （api基本和h5保持一致，但有轻微差异，使用时注意即可 借助微信提供的 canvasToTempFilePath 导出图片，最后再使用 saveImageToPhotosAlbum （需要授权）保存图片到本地 如何优雅实现 绘制出需要的样式这一步是省略不掉的。但是我们可以封装一个绘制库，包含常见图形的绘制，例如矩形，圆角矩形，圆， 扇形， 三角形， 文字，图片减少绘制代码，只需要提炼出样式信息，便可以轻松的绘制，最后导出图片存入相册。笔者觉得以下这种方式绘制更为优雅清晰一些，其实也可以使用加入一个type参数来指定绘制类型，传入的一个是样式数组，实现绘制。 结合上一步的实现，如果对于同一类型的卡片有多次导出需求的场景，也可以使用自定义组件的方式，封装同一类型的卡片为一个通用组件，在需要导出图片功能的地方，引入该组件即可。 class CanvasKit { constructor() { } drawImg(option = {}) { ... return this } drawRect(option = {}) { return this } drawText(option = {}) { ... return this } static exportImg(option = {}) { ... } } let drawer = new CanvasKit('canvasId').drawImg(styleObj1).drawText(styleObj2) drawer.exportImg() ::: warning 注意事项 小程序中无法绘制网络图片到canvas上，需要通过downLoadFile 先下载图片到本地临时文件才可以绘制 通常需要绘制二维码到导出的图片上，有一种方式导出二维码时，需要携带的参数必须做编码，而且有具体的长度（32可见字符）限制，可以借助服务端生成 短链接 的方式来解决::: 3 数据统计 数据统计作为目前一种常用的分析用户行为的方式，小程序端也是必不可少的。小程序采取的曝光，点击数据埋点其实和h5原理是一样的。但是埋点作为一个和业务逻辑不相关的需求，我们如果在每一个点击事件，每一个生命周期加入各种埋点代码，则会干扰正常的业务逻辑，和使代码变的臃肿，笔者提供以下几种思路来解决数据埋点 设计一个埋点sdk 小程序的代码结构是，每一个 Page 中都有一个 Page 方法，接受一个包含生命周期函数，数据的 业务逻辑对象 包装这层数据，借助小程序的底层逻辑实现页面的业务逻辑。通过这个我们可以想到思路，对Page进行一次包装，篡改它的生命周期和点击事件，混入埋点代码，不干扰业务逻辑，只要做一些简单的配置即可埋点，简单的代码实现如下 // 代码仅供理解思路 page = function(params) { let keys = params.keys() keys.forEach(v => { if (v === 'onLoad') { params[v] = function(options) { stat() //曝光埋点代码 params[v].call(this, options) } } else if (v.includes('click')) { params[v] = funciton(event) { let data = event.dataset.config stat(data) // 点击埋点 param[v].call(this) } } }) } 这种思路不光适用于埋点，也可以用来作全局异常处理，请求的统一处理等场景。 分析接口 对于特殊的一些业务，我们可以采取 接口埋点，什么叫接口埋点呢？很多情况下，我们有的api并不是多处调用的，只会在某一个特定的页面调用，通过这个思路我们可以分析出，该接口被请求，则这个行为被触发了，则完全可以通过服务端日志得出埋点数据，但是这种方式局限性较大，而且属于分析结果得出过程，可能存在误差，但可以作为一种思路了解一下。 微信自定义数据分析 微信本身提供的数据分析能力，微信本身提供了常规分析和自定义分析两种数据分析方式，在小程序后台配置即可。借助小程序数据助手这款小程序可以很方便的查看 4 工程化工程化做什么 目前的前端开发过程，工程化是必不可少的一环，那小程序工程化都需要做些什么呢，先看下目前小程序开发当中存在哪些问题需要解决： 不支持 css预编译器,作为一种主流的 css解决方案，不论是 less,sass,stylus 都可以提升css效率 不支持引入npm包 （这一条，从微信公开课中听闻，微信准备支持） 不支持ES7等后续的js特性，好用的async await等特性都无法使用 不支持引入外部字体文件，只支持base64 没有 eslint 等代码检查工具 方案选型 对于目前常用的工程化方案，webpack，rollup，parcel等来看，都常用与单页应用的打包和处理，而小程序天生是 “多页应用” 并且存在一些特定的配置。根据要解决的问题来看，无非是文件的编译，修改，拷贝这些处理，对于这些需求，我们想到基于流的 gulp非常的适合处理，并且相对于webpack配置多页应用更加简单。所以小程序工程化方案推荐使用 gulp 具体开发思路 通过 gulp 的 task 实现： 实时编译 less 文件至相应目录 引入支持async，await的运行时文件 编译字体文件为base64 并生成相应css文件，方便使用 依赖分析哪些地方引用了npm包，将npm包打成一个文件，拷贝至相应目录 检查代码规范 5 小程序架构 微信小程序的框架包含两部分 View 视图层、App Service逻辑层。View 层用来渲染页面结构，AppService 层用来逻辑处理、数据请求、接口调用。 它们在两个线程里运行。 视图层和逻辑层通过系统层的 JSBridage 进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理 视图层使用 WebView 渲染，iOS中使用自带 WKWebView，在 Android 使用腾讯的 x5内核（基于 Blink）运行。 逻辑层使用在 iOS 中使用自带的 JSCore 运行，在 Android中使用腾讯的 x5 内核（基于 Blink）运行。 开发工具使用 nw.js 同时提供了视图层和逻辑层的运行环境。 6 WXML &amp;&amp; WXSSWXML 支持数据绑定 支持逻辑算术、运算 支持模板、引用 支持添加事件（bindtap） Wxml编译器：Wcc 把 Wxml文件 转为 JS 执行方式：Wcc index.wxml 使用 Virtual DOM，进行局部更新 WXSS wxss编译器：wcsc 把wxss文件转化为 js 执行方式： wcsc index.wxss 尺寸单位 rpx rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。公式： const dsWidth = 750 export const screenHeightOfRpx = function () { return 750 / env.screenWidth * env.screenHeight } export const rpxToPx = function (rpx) { return env.screenWidth / 750 * rpx } export const pxToRpx = function (px) { return 750 / env.screenWidth * px } 样式导入 使用 @import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束 内联样式 静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度 全局样式与局部样式 定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器 7 小程序的问题 小程序仍然使用 WebView 渲染，并非原生渲染。（部分原生） 服务端接口返回的头无法执行，比如：Set-Cookie。 依赖浏览器环境的 JS库不能使用。 不能使用 npm，但是可以自搭构建工具或者使用 mpvue。（未来官方有计划支持） 不能使用 ES7，可以自己用babel+webpack自搭或者使用 mpvue。 不支持使用自己的字体（未来官方计划支持）。 可以用 base64 的方式来使用 iconfont。 小程序不能发朋友圈（可以通过保存图片到本地，发图片到朋友前。二维码可以使用B接口）。 获取二维码/小程序接口的限制 程序推送只能使用“服务通知” 而且需要用户主动触发提交 formId，formId 只有7天有效期。（现在的做法是在每个页面都放入form并且隐藏以此获取更多的 formId。后端使用原则为：优先使用有效期最短的） 小程序大小限制 2M，分包总计不超过 8M 转发（分享）小程序不能拿到成功结果，原来可以。链接（小游戏造的孽） 拿到相同的 unionId 必须绑在同一个开放平台下。开放平台绑定限制： 50个移动应用 10个网站 50个同主体公众号 5个不同主体公众号 50个同主体小程序 5个不同主体小程序 公众号关联小程序 所有公众号都可以关联小程序。 一个公众号可关联10个同主体的小程序，3个不同主体的小程序。 一个小程序可关联500个公众号。 公众号一个月可新增关联小程序13次，小程序一个月可新增关联500次。 一个公众号关联的10个同主体小程序和3个非同主体小程序可以互相跳转 品牌搜索不支持金融、医疗 小程序授权需要用户主动点击 小程序不提供测试 access_token 安卓系统下，小程序授权获取用户信息之后，删除小程序再重新获取，并重新授权，得到旧签名，导致第一次授权失败 开发者工具上，授权获取用户信息之后，如果清缓存选择全部清除，则即使使用了wx.checkSession，并且在session_key有效期内，授权获取用户信息也会得到新的session_key 8 授权获取用户信息流程 session_key 有有效期，有效期并没有被告知开发者，只知道用户越频繁使用小程序，session_key 有效期越长 在调用 wx.login 时会直接更新 session_key，导致旧 session_key 失效 小程序内先调用 wx.checkSession 检查登录态，并保证没有过期的 session_key 不会被更新，再调用 wx.login 获取 code。接着用户授权小程序获取用户信息，小程序拿到加密后的用户数据，把加密数据和 code 传给后端服务。后端通过 code 拿到 session_key 并解密数据，将解密后的用户信息返回给小程序 面试题：先授权获取用户信息再 login 会发生什么？ 用户授权时，开放平台使用旧的 session_key 对用户信息进行加密。调用 wx.login 重新登录，会刷新 session_key，这时后端服务从开放平台获取到新 session_key，但是无法对老 session_key 加密过的数据解密，用户信息获取失败 在用户信息授权之前先调用 wx.checkSession 呢？wx.checkSession 检查登录态，并且保证 wx.login 不会刷新 session_key，从而让后端服务正确解密数据。但是这里存在一个问题，如果小程序较长时间不用导致 session_key 过期，则 wx.login 必定会重新生成 session_key，从而再一次导致用户信息解密失败 9 性能优化 我们知道view部分是运行在webview上的，所以前端领域的大多数优化方式都有用 加载优化 代码包的大小是最直接影响小程序加载启动速度的因素。代码包越大不仅下载速度时间长，业务代码注入时间也会变长。所以最好的优化方式就是减少代码包的大小 小程序加载的三个阶段的表示 优化方式 代码压缩。 及时清理无用代码和资源文件。 减少代码包中的图片等资源文件的大小和数量。 分包加载。 首屏加载的体验优化建议 提前请求: 异步数据请求不需要等待页面渲染完成。 利用缓存: 利用 storage API 对异步请求数据进行缓存，二次启动时先利用缓存数据渲染页面，在进行后台更新。 避免白屏：先展示页面骨架页和基础内容。 及时反馈：即时地对需要用户等待的交互操作给出反馈，避免用户以为小程序无响应 使用分包加载优化 在构建小程序分包项目时，构建会输出一个或多个功能的分包，其中每个分包小程序必定含有一个主包，所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本，而分包则是根据开发者的配置进行划分 在小程序启动时，默认会下载主包并启动主包内页面，如果用户需要打开分包内某个页面，客户端会把对应分包下载下来，下载完成后再进行展示。 优点： 对开发者而言，能使小程序有更大的代码体积，承载更多的功能与服务 对用户而言，可以更快地打开小程序，同时在不影响启动速度前提下使用更多功能 限制 整个小程序所有分包大小不超过 8M 单个分包/主包大小不能超过 2M 原生分包加载的配置 假设支持分包的小程序目录结构如下 ├── app.js ├── app.json ├── app.wxss ├── packageA │ └── pages │ ├── cat │ └── dog ├── packageB │ └── pages │ ├── apple │ └── banana ├── pages │ ├── index │ └── logs └── utils 开发者通过在 app.json subPackages 字段声明项目分包结构 { \"pages\":[ \"pages/index\", \"pages/logs\" ], \"subPackages\": [ { \"root\": \"packageA\", \"pages\": [ \"pages/cat\", \"pages/dog\" ] }, { \"root\": \"packageB\", \"pages\": [ \"pages/apple\", \"pages/banana\" ] } ] } 分包原则 声明 subPackages 后，将按 subPackages 配置路径进行打包，subPackages 配置路径外的目录将被打包到 app（主包） 中 app（主包）也可以有自己的 pages（即最外层的 pages 字段 subPackage 的根目录不能是另外一个 subPackage 内的子目录 首页的 TAB页面必须在 app（主包）内 引用原则 packageA无法require packageB JS 文件，但可以require app、自己package内的JS` 文件 packageA无法import packageB的template，但可以require app、自己package内的template` packageA 无法使用packageB的资源，但可以使用app、自己package` 内的资源 官方即将推出 分包预加载 独立分包 渲染性能优化 每次 setData 的调用都是一次进程间通信过程，通信开销与 setData 的数据量正相关。 setData 会引发视图层页面内容的更新，这一耗时操作一定时间中会阻塞用户交互。 setData 是小程序开发使用最频繁，也是最容易引发性能问题的 避免不当使用 setData 使用 data 在方法间共享数据，可能增加 setData传输的数据量。。data 应仅包括与页面渲染相关的数据。 使用 setData 传输大量数据，通讯耗时与数据正相关，页面更新延迟可能造成页面更新开销增加。仅传输页面中发生变化的数据，使用 setData 的特殊 key实现局部更新。 短时间内频繁调用 setData，操作卡顿，交互延迟，阻塞通信，页面渲染延迟。避免不必要的 setData，对连续的setData调用进行合并。 在后台页面进行 setData，抢占前台页面的渲染资源。页面切入后台后的 setData 调用，延迟到页面重新展示时执行。 避免不当使用onPageScroll 只在有必要的时候监听 pageScroll 事件。不监听，则不会派发。 避免在 onPageScroll 中执行复杂逻辑 避免在 onPageScroll 中频繁调用 setData 避免滑动时频繁查询节点信息（SelectQuery）用以判断是否显示，部分场景建议使用节点布局橡胶状态监听（inersectionObserver）替代 使用自定义组件 在需要频繁更新的场景下，自定义组件的更新只在组件内部进行，不受页面其他部分内容复杂性影响 10 wepy vs mpvue数据流管理 相比传统的小程序框架，这个一直是我们作为资深开发者比较期望去解决的，在 Web 开发中，随着 Flux、Redux、Vuex 等多个数据流工具出现，我们也期望在业务复杂的小程序中使用 WePY 默认支持 Redux，在脚手架生成项目的时候可以内置 Mpvue 作为 Vue 的移植版本，当然支持 Vuex，同样在脚手架生成项目的时候可以内置 组件化 WePY 类似 Vue实现了单文件组件，最大的差别是文件后缀 .wpy，只是写法上会有差异 export default class Index extends wepy.page {} Mpvue 作为 Vue 的移植版本，支持单文件组件，template、script 和 style 都在一个 .vue 文件中，和 vue 的写法类似，所以对 Vue 开发熟悉的同学会比较适应 工程化 所有的小程序开发依赖官方提供的开发者工具。开发者工具简单直观，对调试小程序很有帮助，现在也支持腾讯云（目前我们还没有使用，但是对新的一些开发者还是有帮助的），可以申请测试报告查看小程序在真实的移动设备上运行性能和运行效果，但是它本身没有类似前端工程化中的概念和工具 wepy 内置了构建，通过 wepy init 命令初始化项目，大致流程如下： wepy-cli 会判断模版是在远程仓库还是在本地，如果在本地则会立即跳到第 3 步，反之继续进行。 会从远程仓库下载模版，并保存到本地。 询问开发者 Project name 等问题，依据开发者的回答，创建项目 mpvue 沿用了 vue 中推崇的 webpack作为构建工具，但同时提供了一些自己的插件以及配置文件的一些修改，比如 不再需要 html-webpack-plugin 基于 webpack-dev-middleware 修改成 webpack-dev-middleware-hard-disk 最大的变化是基于 webpack-loader 修改成 mpvue-loader 但是配置方式还是类似，分环境配置文件，最终都会编译成小程序支持的目录结构和文件后缀 11 mpvue::: tip mpvueVue.js 小程序版, fork 自 `vuejs/vue@2.4.1，保留了vue runtime能力，添加了小程序平台的支持。mpvue是一个使用Vue.js开发小程序的前端框架。框架基于Vue.js核心，mpvue修改了Vue.js的runtime和compiler实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套Vue.js` 开发体验::: 框架原理 两个大方向 通过mpvue提供 mp 的 runtime 适配小程序 通过mpvue-loader产出微信小程序所需要的文件结构和模块内容 七个具体问题 要了解 mpvue 原理必然要了解 Vue 原理，这是大前提 现在假设您对 Vue 原理有个大概的了解 由于 Vue 使用了 Virtual DOM，所以 Virtual DOM可以在任何支持 JavaScript 语言的平台上操作，譬如说目前 Vue 支持浏览器平台或 weex，也可以是 mp(小程序)。那么最后 Virtual DOM 如何映射到真实的 DOM节点上呢？vue为平台做了一层适配层，浏览器平台见 runtime/node-ops.js、weex平台见runtime/node-ops.js，小程序见runtime/node-ops.js。不同平台之间通过适配层对外提供相同的接口，Virtual DOM进行操作Real DOM节点的时候，只需要调用这些适配层的接口即可，而内部实现则不需要关心，它会根据平台的改变而改变 所以思路肯定是往增加一个 mp 平台的 runtime方向走。但问题是小程序不能操作 DOM，所以 mp 下的node-ops.js里面的实现都是直接 return obj 新 Virtual DOM 和旧 Virtual DOM 之间需要做一个 patch，找出 diff。patch完了之后的 diff 怎么更新视图，也就是如何给这些 DOM 加入 attr、class、style等 DOM 属性呢？ Vue中有 nextTick 的概念用以更新视图，mpvue这块对于小程序的 setData 应该怎么处理呢？ 另外个问题在于小程序的 Virtual DOM 怎么生成？也就是怎么将 template编译成render function。这当中还涉及到运行时-编译器-vs-只包含运行时，显然如果要提高性能、减少包大小、输出 wxml、mpvue 也要提供预编译的能力。因为要预输出 wxml 且没法动态改变 DOM，所以动态组件，自定义 render，和&lt;script type=&quot;text/x-template&quot;&gt;字符串模版等都不支持 另外还有一些其他问题，最后总结一下 1.如何预编译生成render function 2.如何预编译生成 wxml，wxss，wxs 3.如何 patch 出 diff 4.如何更新视图 5.如何建立小程序事件代理机制，在事件代理函数中触发与之对应的vue组件事件响应 6.如何建立vue实例与小程序 Page实例关联 7.如何建立小程序和vue生命周期映射关系，能在小程序生命周期中触发vue生命周期 platform/mp的目录结构 . ├── compiler //解决问题1，mpvue-template-compiler源码部分 ├── runtime //解决问题3 4 5 6 7 ├── util //工具方法 ├── entry-compiler.js //mpvue-template-compiler的入口。package.json相关命令会自动生成mpvue-template-compiler这个package。 ├── entry-runtime.js //对外提供Vue对象，当然是mpvue └── join-code-in-build.js //编译出SDK时的修复 mpvue-loader mpvue-loader 是 vue-loader 的一个扩展延伸版，类似于超集的关系，除了vue-loader 本身所具备的能力之外，它还会利用mpvue-template-compiler生成render function entry 它会从 webpack 的配置中的 entry 开始，分析依赖模块，并分别打包。在entry 中 app 属性及其内容会被打包为微信小程序所需要的 app.js／app.json／app.wxss，其余的会生成对应的 页面page.js/page.json/page.wxml/page.wxss，如示例的 entry 将会生成如下这些文件，文件内容下文慢慢讲来： // webpack.config.js { // ... entry: { app: resolve('./src/main.js'), // app 字段被识别为 app 类型 index: resolve('./src/pages/index/main.js'), // 其余字段被识别为 page 类型 'news/home': resolve('./src/pages/news/home/index.js') } } // 产出文件的结构 . ├── app.js ├── app.json ├──· app.wxss ├── components │ ├── card$74bfae61.wxml │ ├── index$023eef02.wxml │ └── news$0699930b.wxml ├── news │ ├── home.js │ ├── home.wxml │ └── home.wxss ├── pages │ └── index │ ├── index.js │ ├── index.wxml │ └── index.wxss └── static ├── css │ ├── app.wxss │ ├── index.wxss │ └── news │ └── home.wxss └── js ├── app.js ├── index.js ├── manifest.js ├── news │ └── home.js └── vendor.js wxml 每一个 .vue 的组件都会被生成为一个 wxml 规范的 template，然后通过 wxml 规范的 import 语法来达到一个复用，同时组件如果涉及到 props的 data 数据，我们也会做相应的处理，举个实际的例子： {{msg}} import otherComponent from './otherComponent.vue' export default { components: { otherComponent }, data () { return { msg: 'Hello Vue.js!' } }, methods: { test() {} } } 这样一个 Vue的组件的模版部分会生成相应的 wxml &lt;import src=\"components/other-component$hash.wxml\" /> &lt;template name=\"component$hash\"> &lt;view class=\"my-component\" bindtap=\"handleProxy\"> &lt;view class=\"_h1\">{{msg}}&lt;/view> &lt;template is=\"other-component$hash\" wx:if=\"{{ $c[0] }}\" data=\"{{ ...$c[0] }}\">&lt;/template> &lt;/view> &lt;/template> 可能已经注意到了 other-component(:msg=&quot;msg&quot;) 被转化成了 。mpvue 在运行时会从根组件开始把所有的组件实例数据合并成一个树形的数据，然后通过 setData 到 appData,$c是 $children 的缩写。至于那个 0 则是我们的 compiler处理过后的一个标记，会为每一个子组件打一个特定的不重复的标记。 树形数据结构如下 // 这儿数据结构是一个数组，index 是动态的 { $child: { '0'{ // ... root data $child: { '0': { // ... data msg: 'Hello Vue.js!', $child: { // ...data } } } } } } wxss 这个部分的处理同 web 的处理差异不大，唯一不同在于通过配置生成 .css 为 .wxss ，其中的对于 css的若干处理，在 postcss-mpvue-wxss 和 px2rpx-loader 这两部分的文档中又详细的介绍 推荐和小程序一样，将 app.json／page.json 放到页面入口处，使用 copy-webpack-plugin copy 到对应的生成位置。 这部分内容来源于 app 和page 的entry 文件，通常习惯是 main.js，你需要在你的入口文件中 export default { config: {} }，这才能被我们的 loader 识别为这是一个配置，需要写成 json 文件 import Vue from 'vue'; import App from './app'; const vueApp = new Vue(App); vueApp.$mount(); // 这个是我们约定的额外的配置 export default { // 这个字段下的数据会被填充到 app.json ／ page.json config: { pages: ['static/calendar/calendar', '^pages/list/list'], // Will be filled in webpack window: { backgroundTextStyle: 'light', navigationBarBackgroundColor: '##455A73', navigationBarTitleText: '美团汽车票', navigationBarTextStyle: '##fff' } } };","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"高级篇","slug":"高级篇","permalink":"http://www.chenya.site/tags/高级篇/"},{"name":"小程序","slug":"小程序","permalink":"http://www.chenya.site/tags/小程序/"}]},{"title":"高级篇-04.安全进阶知识","slug":"002.前端知识体系/003.高级篇/004.高级篇之安全进阶知识","date":"2016-11-06T03:06:38.000Z","updated":"2019-09-16T01:57:01.491Z","comments":true,"path":"2016/11/06/002.前端知识体系/003.高级篇/004.高级篇之安全进阶知识/","link":"","permalink":"http://www.chenya.site/2016/11/06/002.前端知识体系/003.高级篇/004.高级篇之安全进阶知识/","excerpt":"","text":"四、安全1 XSS 跨网站指令码（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言 XSS 分为三种：反射型，存储型和 DOM-based 如何攻击 XSS 通过修改 HTML节点或者执行 JS代码来攻击网站。 例如通过 URL 获取某些参数 &lt;!-- http://www.domain.com?name=&lt;script>alert(1)&lt;/script> --> &lt;div>{{name}}&lt;/div> 上述 URL 输入可能会将 HTML 改为 &lt;div&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/div&gt; ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击 如何防御 最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义 function escape(str) { str = str.replace(/&amp;/g, \"&amp;amp;\"); str = str.replace(/&lt;/g, \"&amp;lt;\"); str = str.replace(/>/g, \"&amp;gt;\"); str = str.replace(/\"/g, \"&amp;quto;\"); str = str.replace(/'/g, \"&amp;##39;\"); str = str.replace(/`/g, \"&amp;##96;\"); str = str.replace(/\\//g, \"&amp;##x2F;\"); return str } 通过转义可以将攻击代码 &lt;script&gt;alert(1)&lt;/script&gt; 变成 // -> &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;##x2F;script&amp;gt; escape('&lt;script>alert(1)&lt;/script>') 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式 var xss = require(\"xss\"); var html = xss('&lt;h1 id=\"title\">XSS Demo&lt;/h1>&lt;script>alert(\"xss\");&lt;/script>'); // -> &lt;h1>XSS Demo&lt;/h1>&amp;lt;script&amp;gt;alert(\"xss\");&amp;lt;/script&amp;gt; console.log(html); 以上示例使用了 js-xss来实现。可以看到在输出中保留了 h1 标签且过滤了 script 标签 2 CSRF 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法 CSRF 就是利用用户的登录态发起恶意请求 如何攻击 假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口 &lt;img src=&quot;http://www.domain.com/xxx?comment=&#39;attack&#39;&quot;/&gt; 如何防御 Get 请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 token 3 密码安全加盐 对于密码存储来说，必然是不能明文存储在数据库中的，否则一旦数据库泄露，会对用户造成很大的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系 通常需要对密码加盐，然后进行几次不同加密算法的加密 // 加盐也就是给原密码添加字符串，增加原密码长度 sha256(sha1(md5(salt + password + salt))) 但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误 前端加密 虽然前端加密对于安全防护来说意义不大，但是在遇到中间人攻击的情况下，可以避免明文密码被第三方获取","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"高级篇","slug":"高级篇","permalink":"http://www.chenya.site/tags/高级篇/"},{"name":"安全","slug":"安全","permalink":"http://www.chenya.site/tags/安全/"}]},{"title":"高级篇-03.性能进阶知识","slug":"002.前端知识体系/003.高级篇/003.高级篇之性能进阶知识","date":"2016-09-18T14:18:51.000Z","updated":"2019-09-16T01:57:01.491Z","comments":true,"path":"2016/09/18/002.前端知识体系/003.高级篇/003.高级篇之性能进阶知识/","link":"","permalink":"http://www.chenya.site/2016/09/18/002.前端知识体系/003.高级篇/003.高级篇之性能进阶知识/","excerpt":"","text":"三、性能1 DNS 预解析 DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP &lt;link rel=\"dns-prefetch\" href=\"//blog.poetries.top\"> 2 缓存 缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度 通常浏览器缓存策略分为两种：强缓存和协商缓存 强缓存 实现强缓存可以通过两种响应头实现：Expires和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code为 200 Expires: Wed, 22 Oct 2018 08:41:00 GMT Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效 Cache-control: max-age=30 Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求 协商缓存 如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式 Last-Modified 和 If-Modified-Since Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag ETag 和 If-None-Match ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高 选择合适的缓存策略 对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件 3 使用 HTTP / 2.0 因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间 在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小 4 预加载 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载 预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载 &lt;link rel=\"preload\" href=\"http://example.com\"> 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好 5 预渲染 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染 &lt;link rel=\"prerender\" href=\"http://poetries.com\"> 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染 6 懒执行与懒加载懒执行 懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒 懒加载 懒加载就是将不关键的资源延后加载 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载 懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等 7 文件优化图片优化 对于如何优化图片，有 2 个思路 减少像素点 减少每个像素点能够显示的颜色 图片加载优化 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片 小图使用 base64格式 将多个图标文件整合到一张图片中（雪碧图） 选择正确的图片格式： 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替 照片使用 JPEG 其他文件优化 CSS文件放在 head 中 服务端开启文件压缩功能 将 script 标签放在 body 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 script 标签放在任意位置然后加上 defer ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS文件可以加上 async ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。执行 JS代码过长会卡住渲染，对于需要很多时间计算的代码 可以考虑使用 Webworker。Webworker可以让我们另开一个线程执行脚本而不影响渲染。 CDN 静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie 8 其他使用 Webpack 优化项目 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩 使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码 优化图片，对于小图可以使用 base64 的方式写入文件中 按照路由拆分代码，实现按需加载 给打包出来的文件名添加哈希，实现浏览器缓存文件 监控 对于代码运行错误，通常的办法是使用 window.onerror 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外 对于跨域的代码运行错误会显示 Script error. 对于这种情况我们需要给 script 标签添加 crossorigin 属性 对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 arguments.callee.caller 来做栈递归 对于异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch 但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。 对于捕获的错误需要上传给服务器，通常可以通过 img 标签的 src发起一个请求","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"高级篇","slug":"高级篇","permalink":"http://www.chenya.site/tags/高级篇/"},{"name":"性能","slug":"性能","permalink":"http://www.chenya.site/tags/性能/"}]},{"title":"高级篇-02.浏览器进阶知识","slug":"002.前端知识体系/003.高级篇/002.高级篇之浏览器进阶知识","date":"2016-08-30T05:24:21.000Z","updated":"2019-09-16T01:57:01.490Z","comments":true,"path":"2016/08/30/002.前端知识体系/003.高级篇/002.高级篇之浏览器进阶知识/","link":"","permalink":"http://www.chenya.site/2016/08/30/002.前端知识体系/003.高级篇/002.高级篇之浏览器进阶知识/","excerpt":"","text":"二、浏览器1 事件机制事件触发三阶段 document 往事件触发处传播，遇到注册的捕获事件会触发 传播到事件触发处时触发注册的事件 从事件触发处往 document 传播，遇到注册的冒泡事件会触发 事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行 // 以下会先打印冒泡然后是捕获 node.addEventListener('click',(event) =>{ console.log('冒泡') },false); node.addEventListener('click',(event) =>{ console.log('捕获 ') },true) 注册事件 通常我们使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。useCapture 决定了注册的事件是捕获事件还是冒泡事件 一般来说，我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件 node.addEventListener('click',(event) =>{ event.stopImmediatePropagation() console.log('冒泡') },false); // 点击 node 只会执行上面的函数，该函数不会执行 node.addEventListener('click',(event) => { console.log('捕获 ') },true) 事件代理 如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上 &lt;ul id=\"ul\"> &lt;li>1&lt;/li> &lt;li>2&lt;/li> &lt;li>3&lt;/li> &lt;li>4&lt;/li> &lt;li>5&lt;/li> &lt;/ul> &lt;script> let ul = document.querySelector('##ul') ul.addEventListener('click', (event) => { console.log(event.target); }) &lt;/script> 事件代理的方式相对于直接给目标注册事件来说，有以下优点 节省内存 不需要给子节点注销事件 2 跨域 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败 JSONP JSONP 的原理很简单，就是利用 &lt;script&gt; 标签没有跨域限制的漏洞。通过 &lt;script&gt; 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时 &lt;script src=\"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp\">&lt;/script> &lt;script> function jsonp(data) { console.log(data) } &lt;/script> JSONP 使用简单且兼容性不错，但是只限于 get 请求 CORS CORS需要浏览器和后端同时支持 浏览器会自动进行 CORS 通信，实现CORS通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源 document.domain 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain = &#39;test.com&#39; 表示二级域名都相同就可以实现跨域 postMessage 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息 // 发送消息端 window.parent.postMessage('message', 'http://blog.poetries.com'); // 接收消息端 var mc = new MessageChannel(); mc.addEventListener('message', (event) => { var origin = event.origin || event.originalEvent.origin; if (origin === 'http://blog.poetries.com') { console.log('验证通过') } }); 3 Event loopJS中的event loop 众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点） JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为 console.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); console.log('script end'); 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task console.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); new Promise((resolve) => { console.log('Promise') resolve() }).then(function() { console.log('promise1'); }).then(function() { console.log('promise2'); }); console.log('script end'); // script start => Promise => script end => promise1 => promise2 => setTimeout 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务 微任务 process.nextTick promise Object.observe MutationObserver 宏任务 script setTimeout setInterval setImmediate I/O UI rendering 宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务 所以正确的一次 Event loop 顺序是这样的 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的响应界面响应，我们可以把操作 DOM 放入微任务中 Node 中的 Event loop Node 中的 Event loop 和浏览器中的不相同。 Node 的 Event loop 分为6个阶段，它们会按照顺序反复运行 ┌───────────────────────┐ ┌─>│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │&lt;──connections─── │ │ └──────────┬────────────┘ │ data, etc. │ │ ┌──────────┴────────────┐ └───────────────┘ │ │ check │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ └──┤ close callbacks │ └───────────────────────┘ timer timers 阶段会执行 setTimeout 和 setInterval 一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟 I/O I/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调 poll poll 阶段很重要，这一阶段中，系统会做两件事情 执行到点的定时器 执行 poll 队列中的事件 并且当 poll 中没有定时器的情况下，会发现以下两件事情 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制 如果 poll 队列为空，会有两件事发生 如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate 如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调 如果有别的定时器需要被执行，会回到 timer 阶段执行回调。 check check 阶段执行 setImmediate close callbacks close callbacks 阶段执行 close 事件 并且在 Node 中，有些情况下的定时器执行顺序是随机的 setTimeout(() => { console.log('setTimeout'); }, 0); setImmediate(() => { console.log('setImmediate'); }) // 这里可能会输出 setTimeout，setImmediate // 可能也会相反的输出，这取决于性能 // 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate // 否则会执行 setTimeout 上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行 setTimeout(()=>{ console.log('timer1') Promise.resolve().then(function() { console.log('promise1') }) }, 0) setTimeout(()=>{ console.log('timer2') Promise.resolve().then(function() { console.log('promise2') }) }, 0) // 以上代码在浏览器和 node 中打印情况是不同的 // 浏览器中一定打印 timer1, promise1, timer2, promise2 // node 中可能打印 timer1, timer2, promise1, promise2 // 也可能打印 timer1, promise1, timer2, promise2 Node 中的 process.nextTick 会先于其他 microtask 执行 setTimeout(() => { console.log(\"timer1\"); Promise.resolve().then(function() { console.log(\"promise1\"); }); }, 0); process.nextTick(() => { console.log(\"nextTick\"); }); // nextTick, timer1, promise1 4 Service Worker Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API 目前该技术通常用来做缓存文件，提高首屏速度 // index.js if (navigator.serviceWorker) { navigator.serviceWorker .register(\"sw.js\") .then(function(registration) { console.log(\"service worker 注册成功\"); }) .catch(function(err) { console.log(\"servcie worker 注册失败\"); }); } // sw.js // 监听 `install` 事件，回调中缓存所需文件 self.addEventListener(\"install\", e => { e.waitUntil( caches.open(\"my-cache\").then(function(cache) { return cache.addAll([\"./index.html\", \"./index.js\"]); }) ); }); // 拦截所有请求事件 // 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据 self.addEventListener(\"fetch\", e => { e.respondWith( caches.match(e.request).then(function(response) { if (response) { return response; } console.log(\"fetch source\"); }) ); }); 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了 在 Cache 中也可以发现我们所需的文件已被缓存 当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的 5 渲染机制浏览器的渲染机制一般分为以下几个步骤 处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM 图层 一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用 通过以下几个常用属性可以生成新图层 3D变换：translate3d、translateZ will-change video、iframe 标签 通过动画实现的 opacity 动画转换 position: fixed 重绘（Repaint）和回流（Reflow） 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘 回流是布局或者几何属性需要改变就称为回流 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流 所以以下几个动作可能会导致性能问题： 改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 很多人不知道的是，重绘和回流其实和 Event loop 有关 当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz的刷新率，每 16ms才会更新一次。 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调 减少重绘和回流 使用 translate 替代 top 使用 visibility 替换display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免 DOM 深度过深 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video标签，浏览器会自动将该节点变为图层","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"高级篇","slug":"高级篇","permalink":"http://www.chenya.site/tags/高级篇/"},{"name":"浏览器","slug":"浏览器","permalink":"http://www.chenya.site/tags/浏览器/"}]},{"title":"前端工程与模块化框架","slug":"前端工程与模块化框架","date":"2016-08-08T12:46:25.000Z","updated":"2019-09-16T01:57:01.508Z","comments":true,"path":"2016/08/08/前端工程与模块化框架/","link":"","permalink":"http://www.chenya.site/2016/08/08/前端工程与模块化框架/","excerpt":"","text":"前端工程与模块化框架一直酝酿着写一篇关于模块化框架的文章，因为模块化框架是前端工程中的 最为核心的部分 。本来又想长篇大论的写一篇完整且严肃的paper，但看了 @糖饼 在 div.io 的一篇文章 《再谈 SeaJS 与 RequireJS 的差异》觉得可以借着这篇继续谈一下，加上最近spm3发布，在seajs的官网上又引来了一场 口水战 ，我并不想参与到这场论战中，各有所爱的事情不好评论什么，但我想从工程的角度来阐述一下已知的模块化框架相关的问题，并给出一些新的思路，其实也不新啦，都实践了2多年了。 前端模块化框架肩负着 模块管理、资源加载 两项重要的功能，这两项功能与工具、性能、业务、部署等工程环节都有着非常紧密的联系。因此，模块化框架的设计应该最高优先级考虑工程需要。 基于 @糖饼 的文章 《再谈 SeaJS 与 RequireJS 的差异》，我这里还要补充一些模块化框架在工程方面的缺点： requirejs和seajs二者在加载上都有缺陷，就是模块的依赖要等到模块加载完成后，通过静态分析（seajs）或者deps参数（requirejs）来获取，这就为 合并请求 和 按需加载 带来了实现上的矛盾： 要么放弃按需加载，把所有js合成一个文件，从而满足请求合并（两个框架的官方demo都有这样的例子）； 要么放弃请求合并，请求独立的模块文件，从而满足按需加载。 AMD规范在执行callback的时候，要初始化所有依赖的模块，而CMD只有执行到require的时候才初始化模块。所以用AMD实现某种if-else逻辑分支加载不同的模块的时候，就会比较麻烦了。考虑这种情况： //AMD for SPA require(['page/index', 'page/detail'], function(index, detail){ //在执行回调之前，index和detail模块的factory均执行过了 switch(location.hash){ case '#index': index(); break; case '#detail': detail(); break; } }); 在执行回调之前，已经同时执行了index和detail模块的factory，而CMD只有执行到require才会调用对应模块的factory。这种差别带来的不仅仅是性能上的差异，也可能为开发增加一点小麻烦，比如不方便实现换肤功能，factory注意不要直接操作dom等。当然，我们可以多层嵌套require来解决这个问题，但又会引起模块请求串行的问题。 结论：以纯前端方式实现模块化框架 不能 同时满足 按需加载，请求合并 和 依赖管理 三个需求。 导致这个问题的根本原因是 纯前端方式只能在运行时分析依赖关系。 解决模块化管理的新思路由于根本问题出在 运行时分析依赖，因此新思路的策略很简单：不在运行时分析依赖。这就要借助 构建工具 做线下分析了，其基本原理就是： 利用构建工具在线下进行 模块依赖分析，然后把依赖关系数据写入到构建结果中，并调用模块化框架的 依赖关系声明接口 ，实现模块管理、请求合并以及按需加载等功能。 举个例子，假设我们有一个这样的工程： project ├ lib │ └ xmd.js #模块化框架 ├ mods #模块目录 │ ├ a.js │ ├ b.js │ ├ c.js │ ├ d.js │ └ e.js └ index.html #入口页面 工程中，index.html 的源码内容为： &lt;!doctype html> ... &lt;script src=\"lib/xmd.js\">&lt;/script> &lt;!-- 模块化框架 --> &lt;script> //等待构建工具生成数据替换 `__FRAMEWORK_CONFIG__' 变量 require.config(__FRAMEWORK_CONFIG__); &lt;/script> &lt;script> //用户代码，异步加载模块 require.async(['a', 'e'], function(a, e){ //do something with a and e. }); &lt;/script> ... 工程中，mods/a.js 的源码内容为（采用类似CMD的书写规范）： define('a', function(require, exports, module){ console.log('a.init'); var b = require('b'); var c = require('c'); exports.run = function(){ //do something with b and c. console.log('a.run'); }; }); 具体实现过程 用工具在下线对工程文件进行扫描，得到依赖关系表： { \"a\" : [ \"b\", \"c\" ], \"b\" : [ \"d\" ] } 工具把依赖表构建到页面或者脚本中，并调用模块化框架的配置接口，index.html的构建结果为： &lt;!doctype html> ... &lt;script src=\"lib/xmd.js\">&lt;/script> &lt;!-- 模块化框架 --> &lt;script> //构建工具生成的依赖数据 require.config({ \"deps\" : { \"a\" : [ \"b\", \"c\" ], \"b\" : [ \"d\" ] } }); &lt;/script> &lt;script> //用户代码，异步加载模块 require.async(['a', 'e'], function(a, e){ //do something with a and e. }); &lt;/script> 模块化框架根据依赖表加载资源，比如上述例子，入口需要加载a、e两个模块，查表得知完整依赖关系，配合combo服务，可以发起一个合并后的请求： http://www.example.com/??d.js,b.js,c.js,a.js,e.js 先来看一下这种方案的优点 采用类似CMD的书写规范（同步require函数声明依赖），可以在执行到require语句的时候才调用模块的factory。 虽然采用CMD书写规范，但放弃了运行时分析依赖，改成工具输出依赖表，因此 依赖分析完成后可以压缩掉require关键字 框架并没有严格依赖工具，它只是约定了一种数据结构。不使用工具，人工维护 require.config({...}) 相关的数据也是可以的。对于小项目，文件全部合并的情况，更加不需要deps表了，只要在入口的require.async调用之前加载所有模块化的文件，依赖关系无需额外维护 构建工具设计非常简单，而且可靠。工作就是扫描模块文件目录，得到依赖表，JSON序列化之后插入到构建代码中 由于框架预先知道所有模块的依赖关系，因此可以借助combo服务实现请求合并，而不用等到一级模块加载完成才能知道后续的依赖关系。 如果构建工具可以自动包装define函数，那么整个系统开发起来会感觉跟nodejs非常接近，比较舒服。 再来讨论一下这种方案的缺点：由于采用require函数作为依赖标记，因此如果需要变量方式require，需要额外声明，这个时候可以实现兼容AMD规范写法，比如 define('a', ['b', 'c'], function(require, exports, module){ console.log('a.init'); var name = isIE ? 'b' : 'c'; var mod = require(name); exports.run = function(){ //do something with mod. console.log('a.run'); }; }) 只要工具把define函数中的 deps 参数，或者factory内的require都作为依赖声明标记来识别，这样工程性就比较完备了。 但不管怎样， 线下分析始终依靠了字面量信息，所以开发上可能会有一定的局限性，但总的来说瑕不掩瑜。 希望本文能为前端模块化框架的作者带来一些新的思路。没有必要争论规范，工程问题才是最根本的问题。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.chenya.site/categories/随笔/"}],"tags":[{"name":"前端工程","slug":"前端工程","permalink":"http://www.chenya.site/tags/前端工程/"},{"name":"模块化","slug":"模块化","permalink":"http://www.chenya.site/tags/模块化/"},{"name":"模块化框架","slug":"模块化框架","permalink":"http://www.chenya.site/tags/模块化框架/"}]},{"title":"高级篇-01.JavaScript进阶知识","slug":"002.前端知识体系/003.高级篇/001.高级篇之JavaScript进阶知识","date":"2016-08-05T15:44:30.000Z","updated":"2019-09-16T01:57:01.490Z","comments":true,"path":"2016/08/05/002.前端知识体系/003.高级篇/001.高级篇之JavaScript进阶知识/","link":"","permalink":"http://www.chenya.site/2016/08/05/002.前端知识体系/003.高级篇/001.高级篇之JavaScript进阶知识/","excerpt":"","text":"一、JavaScript进阶1 内置类型 JS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。 基本类型有六种： null，undefined，boolean，number，string，symbol。 其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。NaN 也属于 number 类型，并且 NaN 不等于自身。 对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型。 let a = 111 // 这只是字面量，不是 number 类型 a.toString() // 使用时候才会转换为对象类型 对象（Object）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。 let a = { name: 'FE' } let b = a b.name = 'EF' console.log(a.name) // EF 2 Typeof typeof 对于基本类型，除了 null 都可以显示正确的类型 typeof 1 // 'number' typeof '1' // 'string' typeof undefined // 'undefined' typeof true // 'boolean' typeof Symbol() // 'symbol' typeof b // b 没有声明，但是还会显示 undefined typeof 对于对象，除了函数都会显示 object typeof [] // 'object' typeof {} // 'object' typeof console.log // 'function' 对于 null来说，虽然它是基本类型，但是会显示 object，这是一个存在很久了的 Bug typeof null // &#39;object&#39; PS：为什么会出现这种情况呢？因为在 JS的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个Bug却是一直流传下来。 如果我们想获得一个变量的正确类型，可以通过 Object.prototype.toString.call(xx)。这样我们就可以获得类似 [object Type] 的字符串 let a // 我们也可以这样判断 undefined a === undefined // 但是 undefined 不是保留字，能够在低版本浏览器被赋值 let undefined = 1 // 这样判断就会出错 // 所以可以用下面的方式来判断，并且代码量更少 // 因为 void 后面随便跟上一个组成表达式 // 返回就是 undefined a === void 0 3 类型转换转Boolean 在条件判断时，除了 undefined， null， false， NaN， &#39;&#39;， 0， -0，其他所有值都转为 true，包括所有对象 对象转基本类型 对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。并且这两个方法你是可以重写的 let a = { valueOf() { return 0 } } 四则运算符 只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串 1 + '1' // '11' 2 * '2' // 4 [1, 2] + [2, 1] // '1,22,1' // [1, 2].toString() -> '1,2' // [2, 1].toString() -> '2,1' // '1,2' + '2,1' = '1,22,1' 对于加号需要注意这个表达式 &#39;a&#39; + + &#39;b&#39; 'a' + + 'b' // -> \"aNaN\" // 因为 + 'b' -> NaN // 你也许在一些代码中看到过 + '1' -> 1 == 操作符 这里来解析一道题目 [] == ![] // -&gt; true ，下面是这个表达式为何为 true 的步骤 // [] 转成 true，然后取反变成 false [] == false // 根据第 8 条得出 [] == ToNumber(false) [] == 0 // 根据第 10 条得出 ToPrimitive([]) == 0 // [].toString() -> '' '' == 0 // 根据第 6 条得出 0 == 0 // -> true 比较运算符 如果是对象，就通过 toPrimitive 转换对象 如果是字符串，就通过 unicode 字符索引来比较 4 原型 每个函数都有 prototype 属性，除了 Function.prototype.bind()，该属性指向原型。 每个对象都有 __proto__属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 _proto_ 来访问。 对象可以通过__proto__ 来寻找不属于该对象的属性，__proto__ 将对象连接起来组成了原型链 5 new 新生成了一个对象 链接到原型 绑定 this 返回新对象 在调用 new 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 new function create() { // 创建一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return typeof result === 'object' ? result : obj } 6 instanceof instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype 我们也可以试着实现一下 instanceof function instanceof(left, right) { // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) { if (left === null) return false if (prototype === left) return true left = left.__proto__ } } 7 thisfunction foo() { console.log(this.a) } var a = 1 foo() var obj = { a: 2, foo: foo } obj.foo() // 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况 // 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向 var c = new foo() c.a = 3 console.log(c.a) // 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new 看看箭头函数中的 this function a() { return () => { return () => { console.log(this) } } } console.log(a()()()) 箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是箭头函数的函数的 this。在这个例子中，因为调用 a 符合前面代码中的第一个情况，所以 this 是 window。并且 this 一旦绑定了上下文，就不会被任何代码改变 8 执行上下文 当执行 JS 代码时，会产生三种执行上下文 全局执行上下文 函数执行上下文 eval 执行上下文 每个执行上下文中都有三个重要的属性 变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问 作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定了） this var a = 10 function foo(i) { var b = 20 } foo() 对于上述代码，执行栈中有两个上下文：全局上下文和函数 foo 上下文。 stack = [ globalContext, fooContext ] 对于全局上下文来说，VO大概是这样的 globalContext.VO === globe globalContext.VO = { a: undefined, foo: &lt;Function>, } 对于函数 foo 来说，VO 不能访问，只能访问到活动对象（AO） fooContext.VO === foo.AO fooContext.AO { i: undefined, b: undefined, arguments: &lt;> } // arguments 是函数独有的对象(箭头函数没有) // 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素 // 该对象中的 `callee` 属性代表函数本身 // `caller` 属性代表函数的调用者 对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过 [[Scope]]属性查找上级变量 fooContext.[[Scope]] = [ globalContext.VO ] fooContext.Scope = fooContext.[[Scope]] + fooContext.VO fooContext.Scope = [ fooContext.VO, globalContext.VO ] 接下来让我们看一个老生常谈的例子，var b() // call b console.log(a) // undefined var a = 'Hello world' function b() { console.log('call b') } 想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 VO），JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升 b() // call b second function b() { console.log('call b fist') } function b() { console.log('call b second') } var b = 'Hello world' var会产生很多错误，所以在 ES6中引入了 let。let不能在声明前使用，但是这并不是常说的 let 不会提升，let 提升了声明但没有赋值，因为临时死区导致了并不能在声明前使用。 对于非匿名的立即执行函数需要注意以下一点 var foo = 1 (function foo() { foo = 10 console.log(foo) }()) // -> ƒ foo() { foo = 10 ; console.log(foo) } 因为当 JS 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 foo，但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。 specialObject = {}; Scope = specialObject + Scope; foo = new FunctionExpression; foo.[[Scope]] = Scope; specialObject.foo = foo; // {DontDelete}, {ReadOnly} delete Scope[0]; // remove specialObject from the front of scope chain 9 闭包 闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。 function A() { let a = 1 function B() { console.log(a) } return B } 你是否会疑惑，为什么函数 A已经弹出调用栈了，为什么函数 B 还能引用到函数 A中的变量。因为函数 A 中的变量这时候是存储在堆上的。现在的 JS引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。 经典面试题，循环中使用闭包解决 var 定义函数的问题 for ( var i=1; i&lt;=5; i++) { setTimeout( function timer() { console.log( i ); }, i*1000 ); } 首先因为 setTimeout 是个异步函数，所有会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。 解决办法两种，第一种使用闭包 for (var i = 1; i &lt;= 5; i++) { (function(j) { setTimeout(function timer() { console.log(j); }, j * 1000); })(i); } 第二种就是使用 setTimeout 的第三个参数 for ( var i=1; i&lt;=5; i++) { setTimeout( function timer(j) { console.log( j ); }, i*1000, i); } 第三种就是使用 let 定义 i 了 for ( let i=1; i&lt;=5; i++) { setTimeout( function timer() { console.log( i ); }, i*1000 ); } 因为对于 let 来说，他会创建一个块级作用域，相当于 { // 形成块级作用域 let i = 0 { let ii = i setTimeout( function timer() { console.log( i ); }, i*1000 ); } i++ { let ii = i } i++ { let ii = i } ... } 10 深浅拷贝letet a a = { age : 1 } let b = a a.age = 2 console.log(b.age) // 2 从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。 通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题 浅拷贝 首先可以通过 Object.assign 来解决这个问题 let a = { age: 1 } let b = Object.assign({}, a) a.age = 2 console.log(b.age) // 1 当然我们也可以通过展开运算符（…）来解决 let a = { age: 1 } let b = {...a} a.age = 2 console.log(b.age) // 1 通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了 let a = { age: 1, jobs: { first: 'FE' } } let b = {...a} a.jobs.first = 'native' console.log(b.jobs.first) // native 浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷 深拷贝 这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决 let a = { age: 1, jobs: { first: 'FE' } } let b = JSON.parse(JSON.stringify(a)) a.jobs.first = 'native' console.log(b.jobs.first) // FE 但是该方法也是有局限性的： 会忽略 undefined 不能序列化函数 不能解决循环引用的对象 let obj = { a: 1, b: { c: 2, d: 3, }, } obj.c = obj.b obj.e = obj.a obj.b.c = obj.c obj.b.d = obj.b obj.b.e = obj.b.c let newObj = JSON.parse(JSON.stringify(obj)) console.log(newObj) 如果你有这么一个循环引用对象，你会发现你不能通过该方法深拷贝 在遇到函数或者 undefined 的时候，该对象也不能正常的序列化 let a = { age: undefined, jobs: function() {}, name: 'poetries' } let b = JSON.parse(JSON.stringify(a)) console.log(b) // {name: \"poetries\"} 你会发现在上述情况中，该方法会忽略掉函数和`undefined。 但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。当然如果你的数据中含有以上三种情况下，可以使用 lodash 的深拷贝函数。 11 模块化 在有 Babel 的情况下，我们可以直接使用 ES6的模块化 // file a.js export function a() {} export function b() {} // file b.js export default function() {} import {a, b} from './a.js' import XXX from './b.js' CommonJS CommonJs 是 Node 独有的规范，浏览器中使用就需要用到 Browserify解析了。 // a.js module.exports = { a: 1 } // or exports.a = 1 // b.js var module = require('./a.js') module.a // -> log 1 在上述代码中，module.exports 和 exports 很容易混淆，让我们来看看大致内部实现 var module = require('./a.js') module.a // 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了， // 重要的是 module 这里，module 是 Node 独有的一个变量 module.exports = { a: 1 } // 基本实现 var module = { exports: {} // exports 就是个空对象 } // 这个是为什么 exports 和 module.exports 用法相似的原因 var exports = module.exports var load = function (module) { // 导出的东西 var a = 1 module.exports = a return module.exports }; 再来说说 module.exports 和exports，用法其实是相似的，但是不能对 exports 直接赋值，不会有任何效果。 对于 CommonJS 和 ES6 中的模块化的两者区别是： 前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。 而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。 但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化 后者会编译成 require/exports 来执行的 AMD AMD 是由 RequireJS 提出的 // AMD define(['./a', './b'], function(a, b) { a.do() b.do() }) define(function(require, exports, module) { var a = require('./a') a.doSomething() var b = require('./b') b.doSomething() }) 12 防抖 你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。 这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作 PS：防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数 // 这个是用来获取当前时间戳的 function now() { return +new Date() } /** * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param {function} func 回调函数 * @param {number} wait 表示时间窗口的间隔 * @param {boolean} immediate 设置为ture时，是否立即调用函数 * @return {function} 返回客户调用函数 */ function debounce (func, wait = 50, immediate = true) { let timer, context, args // 延迟执行函数 const later = () => setTimeout(() => { // 延迟函数执行完毕，清空缓存的定时器序号 timer = null // 延迟执行的情况下，函数会在延迟函数中执行 // 使用到之前缓存的参数和上下文 if (!immediate) { func.apply(context, args) context = args = null } }, wait) // 这里返回的函数是每次实际调用的函数 return function(...params) { // 如果没有创建延迟执行函数（later），就创建一个 if (!timer) { timer = later() // 如果是立即执行，调用函数 // 否则缓存参数和调用上下文 if (immediate) { func.apply(this, params) } else { context = this args = params } // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个 // 这样做延迟函数会重新计时 } else { clearTimeout(timer) timer = later() } } } 对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点累了，定时器时间到，定时器重置为 null，就可以再次点击了。 对于延时执行函数来说的实现：清除定时器ID，如果是延迟调用就调用函数 13 节流 防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行 /** * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait * * @param {function} func 回调函数 * @param {number} wait 表示时间窗口的间隔 * @param {object} options 如果想忽略开始函数的的调用，传入{leading: false}。 * 如果想忽略结尾函数的调用，传入{trailing: false} * 两者不能共存，否则函数不能执行 * @return {function} 返回客户调用函数 */ _.throttle = function(func, wait, options) { var context, args, result; var timeout = null; // 之前的时间戳 var previous = 0; // 如果 options 没传则设为空对象 if (!options) options = {}; // 定时器回调函数 var later = function() { // 如果设置了 leading，就将 previous 设为 0 // 用于下面函数的第一个 if 判断 previous = options.leading === false ? 0 : _.now(); // 置空一是为了防止内存泄漏，二是为了下面的定时器判断 timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; }; return function() { // 获得当前时间戳 var now = _.now(); // 首次进入前者肯定为 true // 如果需要第一次不执行函数 // 就将上次时间戳设为当前的 // 这样在接下来计算 remaining 的值时会大于0 if (!previous &amp;&amp; options.leading === false) previous = now; // 计算剩余时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果当前调用已经大于上次调用时间 + wait // 或者用户手动调了时间 // 如果设置了 trailing，只会进入这个条件 // 如果没有设置 leading，那么第一次会进入这个条件 // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了 // 其实还是会进入的，因为定时器的延时 // 并不是准确的时间，很可能你设置了2秒 // 但是他需要2.2秒才触发，这时候就会进入这个条件 if (remaining &lt;= 0 || remaining > wait) { // 如果存在定时器就清理掉否则会调用二次回调 if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; result = func.apply(context, args); if (!timeout) context = args = null; } else if (!timeout &amp;&amp; options.trailing !== false) { // 判断是否设置了定时器和 trailing // 没有的话就开启一个定时器 // 并且不能不能同时设置 leading 和 trailing timeout = setTimeout(later, remaining); } return result; }; }; 14 继承 在 ES5 中，我们可以使用如下方式解决继承的问题 function Super() {} Super.prototype.getNumber = function() { return 1 } function Sub() {} let s = new Sub() Sub.prototype = Object.create(Super.prototype, { constructor: { value: Sub, enumerable: false, writable: true, configurable: true } }) 以上继承实现思路就是将子类的原型设置为父类的原型 在 ES6 中，我们可以通过 class 语法轻松解决这个问题 class MyDate extends Date { test() { return this.getTime() } } let myDate = new MyDate() myDate.test() 但是 ES6 不是所有浏览器都兼容，所以我们需要使用 Babel 来编译这段代码。 如果你使用编译过得代码调用 myDate.test()你会惊奇地发现出现了报错 因为在 JS 底层有限制，如果不是由 Date构造出来的实例的话，是不能调用 Date 里的函数的。所以这也侧面的说明了：ES6 中的 class 继承与 ES5 中的一般继承写法是不同的。 既然底层限制了实例必须由 Date 构造出来，那么我们可以改变下思路实现继承 function MyData() { } MyData.prototype.test = function () { return this.getTime() } let d = new Date() Object.setPrototypeOf(d, MyData.prototype) Object.setPrototypeOf(MyData.prototype, Date.prototype) 以上继承实现思路：先创建父类实例 =&gt; 改变实例原先的 _proto__转而连接到子类的 prototype=&gt; 子类的 prototype 的 __proto__ 改为父类的 prototype。 通过以上方法实现的继承就可以完美解决 JS 底层的这个限制 15 call, apply, bind call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。 除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组 let a = { value: 1 } function getValue(name, age) { console.log(name) console.log(age) console.log(this.value) } getValue.call(a, 'yck', '24') getValue.apply(a, ['yck', '24']) 16 Promise 实现 可以把 Promise 看成一个状态机。初始是 pending 状态，可以通过函数 resolve和 reject ，将状态转变为 resolved或者 rejected 状态，状态一旦改变就不能再次变化。 then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 then 调用就失去意义了。 对于 then来说，本质上可以把它看成是 flatMap // 三种状态 const PENDING = \"pending\"; const RESOLVED = \"resolved\"; const REJECTED = \"rejected\"; // promise 接收一个函数参数，该函数会立即执行 function MyPromise(fn) { let _this = this; _this.currentState = PENDING; _this.value = undefined; // 用于保存 then 中的回调，只有当 promise // 状态为 pending 时才会缓存，并且每个实例至多缓存一个 _this.resolvedCallbacks = []; _this.rejectedCallbacks = []; _this.resolve = function (value) { if (value instanceof MyPromise) { // 如果 value 是个 Promise，递归执行 return value.then(_this.resolve, _this.reject) } setTimeout(() => { // 异步执行，保证执行顺序 if (_this.currentState === PENDING) { _this.currentState = RESOLVED; _this.value = value; _this.resolvedCallbacks.forEach(cb => cb()); } }) }; _this.reject = function (reason) { setTimeout(() => { // 异步执行，保证执行顺序 if (_this.currentState === PENDING) { _this.currentState = REJECTED; _this.value = reason; _this.rejectedCallbacks.forEach(cb => cb()); } }) } // 用于解决以下问题 // new Promise(() => throw Error('error)) try { fn(_this.resolve, _this.reject); } catch (e) { _this.reject(e); } } MyPromise.prototype.then = function (onResolved, onRejected) { var self = this; // 规范 2.2.7，then 必须返回一个新的 promise var promise2; // 规范 2.2.onResolved 和 onRejected 都为可选参数 // 如果类型不是函数需要忽略，同时也实现了透传 // Promise.resolve(4).then().then((value) => console.log(value)) onResolved = typeof onResolved === 'function' ? onResolved : v => v; onRejected = typeof onRejected === 'function' ? onRejected : r => throw r; if (self.currentState === RESOLVED) { return (promise2 = new MyPromise(function (resolve, reject) { // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行 // 所以用了 setTimeout 包裹下 setTimeout(function () { try { var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (reason) { reject(reason); } }); })); } if (self.currentState === REJECTED) { return (promise2 = new MyPromise(function (resolve, reject) { setTimeout(function () { // 异步执行onRejected try { var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (reason) { reject(reason); } }); })); } if (self.currentState === PENDING) { return (promise2 = new MyPromise(function (resolve, reject) { self.resolvedCallbacks.push(function () { // 考虑到可能会有报错，所以使用 try/catch 包裹 try { var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (r) { reject(r); } }); self.rejectedCallbacks.push(function () { try { var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (r) { reject(r); } }); })); } }; // 规范 2.3 function resolutionProcedure(promise2, x, resolve, reject) { // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用 if (promise2 === x) { return reject(new TypeError(\"Error\")); } // 规范 2.3.2 // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行 if (x instanceof MyPromise) { if (x.currentState === PENDING) { x.then(function (value) { // 再次调用该函数是为了确认 x resolve 的 // 参数是什么类型，如果是基本类型就再次 resolve // 把值传给下个 then resolutionProcedure(promise2, value, resolve, reject); }, reject); } else { x.then(resolve, reject); } return; } // 规范 2.3.3.3.3 // reject 或者 resolve 其中一个执行过得话，忽略其他的 let called = false; // 规范 2.3.3，判断 x 是否为对象或者函数 if (x !== null &amp;&amp; (typeof x === \"object\" || typeof x === \"function\")) { // 规范 2.3.3.2，如果不能取出 then，就 reject try { // 规范 2.3.3.1 let then = x.then; // 如果 then 是函数，调用 x.then if (typeof then === \"function\") { // 规范 2.3.3.3 then.call( x, y => { if (called) return; called = true; // 规范 2.3.3.3.1 resolutionProcedure(promise2, y, resolve, reject); }, e => { if (called) return; called = true; reject(e); } ); } else { // 规范 2.3.3.4 resolve(x); } } catch (e) { if (called) return; called = true; reject(e); } } else { // 规范 2.3.4，x 为基本类型 resolve(x); } } 17 Generator 实现 Generator 是 ES6中新增的语法，和 Promise 一样，都可以用来异步编程 // 使用 * 表示这是一个 Generator 函数 // 内部可以通过 yield 暂停代码 // 通过调用 next 恢复执行 function* test() { let a = 1 + 2; yield 2; yield 3; } let b = test(); console.log(b.next()); // > { value: 2, done: false } console.log(b.next()); // > { value: 3, done: false } console.log(b.next()); // > { value: undefined, done: true } 从以上代码可以发现，加上 * 的函数执行后拥有了 next函数，也就是说函数执行后返回了一个对象。每次调用 next函数可以继续执行被暂停的代码。以下是 Generator 函数的简单实现 // cb 也就是编译过的 test 函数 function generator(cb) { return (function() { var object = { next: 0, stop: function() {} }; return { next: function() { var ret = cb(object); if (ret === undefined) return { value: undefined, done: true }; return { value: ret, done: false }; } }; })(); } // 如果你使用 babel 编译后可以发现 test 函数变成了这样 function test() { var a; return generator(function(_context) { while (1) { switch ((_context.prev = _context.next)) { // 可以发现通过 yield 将代码分割成几块 // 每次执行 next 函数就执行一块代码 // 并且表明下次需要执行哪块代码 case 0: a = 1 + 2; _context.next = 4; return 2; case 4: _context.next = 6; return 3; // 执行完毕 case 6: case \"end\": return _context.stop(); } } }); } 18 Proxy Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作 let p = new Proxy(target, handler); // `target` 代表需要添加代理的对象 // `handler` 用来自定义对象中的操作 可以很方便的使用 Proxy 来实现一个数据绑定和监听 let onWatch = (obj, setBind, getLogger) => { let handler = { get(target, property, receiver) { getLogger(target, property) return Reflect.get(target, property, receiver); }, set(target, property, value, receiver) { setBind(value); return Reflect.set(target, property, value); } }; return new Proxy(obj, handler); }; let obj = { a: 1 } let value let p = onWatch(obj, (v) => { value = v }, (target, property) => { console.log(`Get '${property}' = ${target[property]}`); }) p.a = 2 // bind `value` to `2` p.a // -> Get 'a' = 2","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"高级篇","slug":"高级篇","permalink":"http://www.chenya.site/tags/高级篇/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenya.site/tags/JavaScript/"}]},{"title":"进阶篇-03.Webpack进阶知识","slug":"002.前端知识体系/002.进阶篇/003.进阶篇之Webpack进阶知识","date":"2016-07-25T13:35:22.000Z","updated":"2019-09-16T01:57:01.490Z","comments":true,"path":"2016/07/25/002.前端知识体系/002.进阶篇/003.进阶篇之Webpack进阶知识/","link":"","permalink":"http://www.chenya.site/2016/07/25/002.前端知识体系/002.进阶篇/003.进阶篇之Webpack进阶知识/","excerpt":"","text":"三、Webpack1 优化打包速度 减少文件搜索范围 比如通过别名 loader 的 test，include &amp; exclude Webpack4 默认压缩并行 Happypack 并发调用 babel 也可以缓存编译 2 Babel 原理 本质就是编译器，当代码转为字符串生成 AST，对 AST 进行转变最后再生成新的代码 分为三步：词法分析生成 Token，语法分析生成 AST，遍历 AST，根据插件变换相应的节点，最后把 AST转换为代码 3 如何实现一个插件 调用插件 apply 函数传入 compiler 对象 通过 compiler 对象监听事件 比如你想实现一个编译结束退出命令的插件 apply (compiler) { const afterEmit = (compilation, cb) => { cb() setTimeout(function () { process.exit(0) }, 1000) } compiler.plugin('after-emit', afterEmit) } } module.exports = BuildEndPlugin","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"进阶篇","slug":"进阶篇","permalink":"http://www.chenya.site/tags/进阶篇/"},{"name":"Webpack","slug":"Webpack","permalink":"http://www.chenya.site/tags/Webpack/"}]},{"title":"进阶篇-02.浏览器进阶知识","slug":"002.前端知识体系/002.进阶篇/002.进阶篇之浏览器进阶知识","date":"2016-07-12T15:25:22.000Z","updated":"2019-09-16T01:57:01.490Z","comments":true,"path":"2016/07/12/002.前端知识体系/002.进阶篇/002.进阶篇之浏览器进阶知识/","link":"","permalink":"http://www.chenya.site/2016/07/12/002.前端知识体系/002.进阶篇/002.进阶篇之浏览器进阶知识/","excerpt":"","text":"二、浏览器1 cookie和localSrorage、session、indexDB 的区别 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在 header 中，对于请求性能影响 不参与 不参与 不参与 从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。 对于 cookie，我们还需要注意安全性 属性 作用 value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JS访问 Cookie，减少 XSS攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 2 怎么判断页面是否加载完成？ Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。 DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载 3 如何解决跨域 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax请求会失败。 我们可以通过以下几种常用方法解决跨域的问题 JSONP JSONP 的原理很简单，就是利用 &lt;script&gt;标签没有跨域限制的漏洞。通过 &lt;script&gt;标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时 &lt;script src=\"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp\">&lt;/script> &lt;script> function jsonp(data) { console.log(data) } &lt;/script> JSONP 使用简单且兼容性不错，但是只限于 get 请求 在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP，以下是简单实现 function jsonp(url, jsonpCallback, success) { let script = document.createElement(\"script\"); script.src = url; script.async = true; script.type = \"text/javascript\"; window[jsonpCallback] = function(data) { success &amp;&amp; success(data); }; document.body.appendChild(script); } jsonp( \"http://xxx\", \"callback\", function(value) { console.log(value); } ); CORS CORS需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。 浏览器会自动进行 CORS 通信，实现CORS通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 document.domain 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain = &#39;test.com&#39; 表示二级域名都相同就可以实现跨域 postMessage 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息 // 发送消息端 window.parent.postMessage('message', 'http://test.com'); // 接收消息端 var mc = new MessageChannel(); mc.addEventListener('message', (event) => { var origin = event.origin || event.originalEvent.origin; if (origin === 'http://test.com') { console.log('验证通过') } }); 4 什么是事件代理 如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上 &lt;ul id=\"ul\"> &lt;li>1&lt;/li> &lt;li>2&lt;/li> &lt;li>3&lt;/li> &lt;li>4&lt;/li> &lt;li>5&lt;/li> &lt;/ul> &lt;script> let ul = document.querySelector('#ul') ul.addEventListener('click', (event) => { console.log(event.target); }) &lt;/script> 事件代理的方式相对于直接给目标注册事件来说，有以下优点 节省内存 不需要给子节点注销事件 5 Service workerService workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API 目前该技术通常用来做缓存文件，提高首屏速度，可以试着来实现这个功能 // index.js if (navigator.serviceWorker) { navigator.serviceWorker .register(\"sw.js\") .then(function(registration) { console.log(\"service worker 注册成功\"); }) .catch(function(err) { console.log(\"servcie worker 注册失败\"); }); } // sw.js // 监听 `install` 事件，回调中缓存所需文件 self.addEventListener(\"install\", e => { e.waitUntil( caches.open(\"my-cache\").then(function(cache) { return cache.addAll([\"./index.html\", \"./index.js\"]); }) ); }); // 拦截所有请求事件 // 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据 self.addEventListener(\"fetch\", e => { e.respondWith( caches.match(e.request).then(function(response) { if (response) { return response; } console.log(\"fetch source\"); }) ); }); 打开页面，可以在开发者工具中的 Application 看到 Service Worker已经启动了 6 浏览器缓存 缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。 通常浏览器缓存策略分为两种：强缓存和协商缓存。 强缓存 实现强缓存可以通过两种响应头实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200 Expires: Wed, 22 Oct 2018 08:41:00 GMT Expires 是 HTTP / 1.0 的产物，表示资源会在Wed,22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 Cache-control: max-age=30 Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。 协商缓存 如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式 Last-Modified 和 If-Modified-Since Last-Modified表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified被修改，所以在 HTTP / 1.1 出现了 ETag ETag 和 If-None-Match ETag 类似于文件指纹，If-None-Match 会将当前 ETag发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高 选择合适的缓存策略 对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存 对于频繁变动的资源，可以使用 Cache-Control: no-cache并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件 7 浏览器性能问题重绘（Repaint）和回流（Reflow） 重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。 重绘是当节点需要更改外观而不会影响布局的，比如改变 color就叫称为重绘 回流是布局或者几何属性需要改变就称为回流。 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。 所以以下几个动作可能会导致性能问题： 改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 很多人不知道的是，重绘和回流其实和 Event loop 有关。 当 Event loop 执行完 Microtasks后，会判断 document 是否需要更新。- 因为浏览器是 60Hz 的刷新率，每 16ms才会更新一次。 然后判断是否有resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。 减少重绘和回流 使用 translate 替代 top &lt;div class=\"test\">&lt;/div> &lt;style> .test { position: absolute; top: 10px; width: 100px; height: 100px; background: red; } &lt;/style> &lt;script> setTimeout(() => { // 引起回流 document.querySelector('.test').style.top = '100px' }, 1000) &lt;/script> 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 把 DOM 离线后修改，比如：先把 DOM 给 display:none(有一次 Reflow)，然后你修改100次，然后再把它显示出来 不要把 DOM结点的属性值放在一个循环里当成循环里的变量 for(let i = 0; i &lt; 1000; i++) { // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector('.test').style.offsetTop) } 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS选择符从右往左匹配查找，避免 DOM 深度过深 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层。 CDN 静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie 使用 Webpack 优化项目 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩 使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码 优化图片，对于小图可以使用 base64 的方式写入文件中 按照路由拆分代码，实现按需加载","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"进阶篇","slug":"进阶篇","permalink":"http://www.chenya.site/tags/进阶篇/"},{"name":"浏览器","slug":"浏览器","permalink":"http://www.chenya.site/tags/浏览器/"}]},{"title":"进阶篇-01.JavaScript进阶知识","slug":"002.前端知识体系/002.进阶篇/001.进阶篇之JavaScript进阶知识","date":"2016-07-02T05:42:15.000Z","updated":"2019-09-16T01:57:01.489Z","comments":true,"path":"2016/07/02/002.前端知识体系/002.进阶篇/001.进阶篇之JavaScript进阶知识/","link":"","permalink":"http://www.chenya.site/2016/07/02/002.前端知识体系/002.进阶篇/001.进阶篇之JavaScript进阶知识/","excerpt":"","text":"一、JS1 谈谈变量提升 当执行 JS 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境。 b() // call b console.log(a) // undefined var a = 'Hello world' function b() { console.log('call b') } 想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升 b() // call b second function b() { console.log('call b fist') } function b() { console.log('call b second') } var b = 'Hello world' var 会产生很多错误，所以在 ES6中引入了 let。let不能在声明前使用，但是这并不是常说的 let 不会提升，let提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用 2 bind、call、apply 区别 call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。 除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组 let a = { value: 1 } function getValue(name, age) { console.log(name) console.log(age) console.log(this.value) } getValue.call(a, 'yck', '24') getValue.apply(a, ['yck', '24']) bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化 3 如何实现一个 bind 函数对于实现以下几个函数，可以从几个方面思考 不传入第一个参数，那么默认为 window 改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？ Function.prototype.myBind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } var _this = this var args = [...arguments].slice(1) // 返回一个函数 return function F() { // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) { return new _this(...args, ...arguments) } return _this.apply(context, args.concat(...arguments)) } } 4 如何实现一个 call 函数Function.prototype.myCall = function (context) { var context = context || window // 给 context 添加一个属性 // getValue.call(a, 'yck', '24') => a.fn = getValue context.fn = this // 将 context 后面的参数取出来 var args = [...arguments].slice(1) // getValue.call(a, 'yck', '24') => a.fn('yck', '24') var result = context.fn(...args) // 删除 fn delete context.fn return result } 5 如何实现一个 apply 函数Function.prototype.myApply = function (context) { var context = context || window context.fn = this var result // 需要判断是否存储第二个参数 // 如果存在，就将第二个参数展开 if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } 6 简单说下原型链？ 每个函数都有 prototype 属性，除了 Function.prototype.bind()，该属性指向原型。 每个对象都有 __proto__ 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]]是内部属性，我们并不能访问到，所以使用 _proto_来访问。 对象可以通过 __proto__ 来寻找不属于该对象的属性，__proto__ 将对象连接起来组成了原型链。 7 怎么判断对象类型 可以通过 Object.prototype.toString.call(xx)。这样我们就可以获得类似 [object Type] 的字符串。 instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype 8 箭头函数的特点function a() { return () => { return () => { console.log(this) } } } console.log(a()()()) 箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是箭头函数的函数的 this。在这个例子中，因为调用 a 符合前面代码中的第一个情况，所以 this 是window。并且 this一旦绑定了上下文，就不会被任何代码改变 9 Thisfunction foo() { console.log(this.a) } var a = 1 foo() var obj = { a: 2, foo: foo } obj.foo() // 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况 // 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向 var c = new foo() c.a = 3 console.log(c.a) // 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new 10 async、await 优缺点 async 和 await 相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性 下面来看一个使用 await 的代码。 var a = 0 var b = async () => { a = a + await 10 console.log('2', a) // -> '2' 10 a = (await 10) + a console.log('3', a) // -> '3' 20 } b() a++ console.log('1', a) // -> '1' 1 首先函数b 先执行，在执行到 await 10 之前变量 a 还是 0，因为在 await 内部实现了 generators ，generators 会保留堆栈中东西，所以这时候 a = 0 被保存了下来 因为 await 是异步操作，遇到await就会立即返回一个pending状态的Promise对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 console.log(&#39;1&#39;, a) 这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 10 然后后面就是常规执行代码了 11 generator 原理 Generator 是 ES6中新增的语法，和 Promise 一样，都可以用来异步编程 // 使用 * 表示这是一个 Generator 函数 // 内部可以通过 yield 暂停代码 // 通过调用 next 恢复执行 function* test() { let a = 1 + 2; yield 2; yield 3; } let b = test(); console.log(b.next()); // > { value: 2, done: false } console.log(b.next()); // > { value: 3, done: false } console.log(b.next()); // > { value: undefined, done: true } 从以上代码可以发现，加上 *的函数执行后拥有了 next 函数，也就是说函数执行后返回了一个对象。每次调用 next 函数可以继续执行被暂停的代码。以下是 Generator 函数的简单实现 // cb 也就是编译过的 test 函数 function generator(cb) { return (function() { var object = { next: 0, stop: function() {} }; return { next: function() { var ret = cb(object); if (ret === undefined) return { value: undefined, done: true }; return { value: ret, done: false }; } }; })(); } // 如果你使用 babel 编译后可以发现 test 函数变成了这样 function test() { var a; return generator(function(_context) { while (1) { switch ((_context.prev = _context.next)) { // 可以发现通过 yield 将代码分割成几块 // 每次执行 next 函数就执行一块代码 // 并且表明下次需要执行哪块代码 case 0: a = 1 + 2; _context.next = 4; return 2; case 4: _context.next = 6; return 3; // 执行完毕 case 6: case \"end\": return _context.stop(); } } }); } 12 Promise Promise 是 ES6 新增的语法，解决了回调地狱的问题。 可以把 Promise看成一个状态机。初始是 pending 状态，可以通过函数 resolve 和 reject，将状态转变为 resolved 或者 rejected 状态，状态一旦改变就不能再次变化。 then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 then 调用就失去意义了。对于 then 来说，本质上可以把它看成是 flatMap 13 如何实现一个 Promise// 三种状态 const PENDING = \"pending\"; const RESOLVED = \"resolved\"; const REJECTED = \"rejected\"; // promise 接收一个函数参数，该函数会立即执行 function MyPromise(fn) { let _this = this; _this.currentState = PENDING; _this.value = undefined; // 用于保存 then 中的回调，只有当 promise // 状态为 pending 时才会缓存，并且每个实例至多缓存一个 _this.resolvedCallbacks = []; _this.rejectedCallbacks = []; _this.resolve = function (value) { if (value instanceof MyPromise) { // 如果 value 是个 Promise，递归执行 return value.then(_this.resolve, _this.reject) } setTimeout(() => { // 异步执行，保证执行顺序 if (_this.currentState === PENDING) { _this.currentState = RESOLVED; _this.value = value; _this.resolvedCallbacks.forEach(cb => cb()); } }) }; _this.reject = function (reason) { setTimeout(() => { // 异步执行，保证执行顺序 if (_this.currentState === PENDING) { _this.currentState = REJECTED; _this.value = reason; _this.rejectedCallbacks.forEach(cb => cb()); } }) } // 用于解决以下问题 // new Promise(() => throw Error('error)) try { fn(_this.resolve, _this.reject); } catch (e) { _this.reject(e); } } MyPromise.prototype.then = function (onResolved, onRejected) { var self = this; // 规范 2.2.7，then 必须返回一个新的 promise var promise2; // 规范 2.2.onResolved 和 onRejected 都为可选参数 // 如果类型不是函数需要忽略，同时也实现了透传 // Promise.resolve(4).then().then((value) => console.log(value)) onResolved = typeof onResolved === 'function' ? onResolved : v => v; onRejected = typeof onRejected === 'function' ? onRejected : r => throw r; if (self.currentState === RESOLVED) { return (promise2 = new MyPromise(function (resolve, reject) { // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行 // 所以用了 setTimeout 包裹下 setTimeout(function () { try { var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (reason) { reject(reason); } }); })); } if (self.currentState === REJECTED) { return (promise2 = new MyPromise(function (resolve, reject) { setTimeout(function () { // 异步执行onRejected try { var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (reason) { reject(reason); } }); })); } if (self.currentState === PENDING) { return (promise2 = new MyPromise(function (resolve, reject) { self.resolvedCallbacks.push(function () { // 考虑到可能会有报错，所以使用 try/catch 包裹 try { var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (r) { reject(r); } }); self.rejectedCallbacks.push(function () { try { var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (r) { reject(r); } }); })); } }; // 规范 2.3 function resolutionProcedure(promise2, x, resolve, reject) { // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用 if (promise2 === x) { return reject(new TypeError(\"Error\")); } // 规范 2.3.2 // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行 if (x instanceof MyPromise) { if (x.currentState === PENDING) { x.then(function (value) { // 再次调用该函数是为了确认 x resolve 的 // 参数是什么类型，如果是基本类型就再次 resolve // 把值传给下个 then resolutionProcedure(promise2, value, resolve, reject); }, reject); } else { x.then(resolve, reject); } return; } // 规范 2.3.3.3.3 // reject 或者 resolve 其中一个执行过得话，忽略其他的 let called = false; // 规范 2.3.3，判断 x 是否为对象或者函数 if (x !== null &amp;&amp; (typeof x === \"object\" || typeof x === \"function\")) { // 规范 2.3.3.2，如果不能取出 then，就 reject try { // 规范 2.3.3.1 let then = x.then; // 如果 then 是函数，调用 x.then if (typeof then === \"function\") { // 规范 2.3.3.3 then.call( x, y => { if (called) return; called = true; // 规范 2.3.3.3.1 resolutionProcedure(promise2, y, resolve, reject); }, e => { if (called) return; called = true; reject(e); } ); } else { // 规范 2.3.3.4 resolve(x); } } catch (e) { if (called) return; called = true; reject(e); } } else { // 规范 2.3.4，x 为基本类型 resolve(x); } } 14 == 和 ===区别，什么情况用 == 这里来解析一道题目 [] == ![] // -&gt; true ，下面是这个表达式为何为 true 的步骤 // [] 转成 true，然后取反变成 false [] == false // 根据第 8 条得出 [] == ToNumber(false) [] == 0 // 根据第 10 条得出 ToPrimitive([]) == 0 // [].toString() -> '' '' == 0 // 根据第 6 条得出 0 == 0 // -> true ===用于判断两者类型和值是否相同。 在开发中，对于后端返回的 code，可以通过 ==去判断 15 基本数据类型和引⽤类型在存储上的差别 前者存储在栈上，后者存储在堆上 16 浏览器 Eventloop 和 Node 中的有什么区别 众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题。 JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为 console.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); console.log('script end'); 以上代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。所以 setTimeout还是会在 script end 之后打印。 不同的任务源会被分配到不同的 Task队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。 console.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); new Promise((resolve) => { console.log('Promise') resolve() }).then(function() { console.log('promise1'); }).then(function() { console.log('promise2'); }); console.log('script end'); // script start => Promise => script end => promise1 => promise2 => setTimeout 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout属于宏任务，所以会有以上的打印。 微任务包括 process.nextTick ，promise ，Object.observe，MutationObserver 宏任务包括 script ， setTimeout ，setInterval，setImmediate ，I/O ，UI renderin 很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务 所以正确的一次 Event loop 顺序是这样的 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中 17 setTimeout 倒计时误差 JS 是单线程的，所以 setTimeout 的误差其实是无法被完全解决的，原因有很多，可能是回调中的，有可能是浏览器中的各种事件导致。这也是为什么页面开久了，定时器会不准的原因，当然我们可以通过一定的办法去减少这个误差。 // 以下是一个相对准备的倒计时实现 var period = 60 * 1000 * 60 * 2 var startTime = new Date().getTime(); var count = 0 var end = new Date().getTime() + period var interval = 1000 var currentInterval = interval function loop() { count++ var offset = new Date().getTime() - (startTime + count * interval); // 代码执行所消耗的时间 var diff = end - new Date().getTime() var h = Math.floor(diff / (60 * 1000 * 60)) var hdiff = diff % (60 * 1000 * 60) var m = Math.floor(hdiff / (60 * 1000)) var mdiff = hdiff % (60 * 1000) var s = mdiff / (1000) var sCeil = Math.ceil(s) var sFloor = Math.floor(s) currentInterval = interval - offset // 得到下一次循环所消耗的时间 console.log('时：'+h, '分：'+m, '毫秒：'+s, '秒向上取整：'+sCeil, '代码执行时间：'+offset, '下次循环间隔'+currentInterval) // 打印 时 分 秒 代码执行时间 下次循环间隔 setTimeout(loop, currentInterval) } setTimeout(loop, currentInterval) 18 数组降维[1, [2], 3].flatMap((v) => v + 1) // -> [2, 3, 4] 如果想将一个多维数组彻底的降维，可以这样实现 const flattenDeep = (arr) => Array.isArray(arr) ? arr.reduce( (a, b) => [...a, ...flattenDeep(b)] , []) : [arr] flattenDeep([1, [[2], [3, [4]], 5]]) 19 深拷贝 这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决 let a = { age: 1, jobs: { first: 'FE' } } let b = JSON.parse(JSON.stringify(a)) a.jobs.first = 'native' console.log(b.jobs.first) // FE 但是该方法也是有局限性的： 会忽略 undefined 会忽略 symbol 不能序列化函数 不能解决循环引用的对象 let obj = { a: 1, b: { c: 2, d: 3, }, } obj.c = obj.b obj.e = obj.a obj.b.c = obj.c obj.b.d = obj.b obj.b.e = obj.b.c let newObj = JSON.parse(JSON.stringify(obj)) console.log(newObj) 复 在遇到函数、 undefined 或者 symbol 的时候，该对象也不能正常的序列化 let a = { age: undefined, sex: Symbol('male'), jobs: function() {}, name: 'yck' } let b = JSON.parse(JSON.stringify(a)) console.log(b) // {name: \"yck\"} 但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。当然如果你的数据中含有以上三种情况下，可以使用 lodash 的深拷贝函数 20 typeof 于 instanceof 区别 typeof 对于基本类型，除了 null都可以显示正确的类型 typeof 1 // 'number' typeof '1' // 'string' typeof undefined // 'undefined' typeof true // 'boolean' typeof Symbol() // 'symbol' typeof b // b 没有声明，但是还会显示 undefined typeof 对于对象，除了函数都会显示 object typeof [] // 'object' typeof {} // 'object' typeof console.log // 'function' 对于 null 来说，虽然它是基本类型，但是会显示 object，这是一个存在很久了的 Bug typeof null // &#39;object&#39; instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 iprototype 我们也可以试着实现一下 instanceof function instanceof(left, right) { // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) { if (left === null) return false if (prototype === left) return true left = left.__proto__ } }","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"进阶篇","slug":"进阶篇","permalink":"http://www.chenya.site/tags/进阶篇/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenya.site/tags/JavaScript/"}]},{"title":"基础篇-10.综合问题","slug":"002.前端知识体系/001.基础篇/010.基础篇之综合问题","date":"2016-06-25T13:55:19.000Z","updated":"2019-09-16T01:57:01.488Z","comments":true,"path":"2016/06/25/002.前端知识体系/001.基础篇/010.基础篇之综合问题/","link":"","permalink":"http://www.chenya.site/2016/06/25/002.前端知识体系/001.基础篇/010.基础篇之综合问题/","excerpt":"","text":"十、综合1 谈谈你对重构的理解 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 2 什么样的前端代码是好的 高复用低耦合，这样文件小，好维护，而且好扩展。 3 对前端工程师这个职位是怎么样理解的？它的前景会怎么样 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近 实现界面交互 提升用户体验 有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 4 你觉得前端工程的价值体现在哪 为简化用户使用提供技术支持（交互部分） 为多个浏览器兼容性提供支持 为提高用户浏览速度（浏览器性能）提供支持 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持 为展示数据提供支持（数据接口） 5 平时如何管理你的项目 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 - 尽量整合在一起使用方便将来的管理 6 组件封装 目的：为了重用，提高开发效率和代码质量 注意：低耦合，单一职责，可复用性，可维护性 常用操作 分析布局 初步开发 化繁为简 组件抽象 十一、一些常见问题 自我介绍 面试完你还有什么问题要问的吗 你有什么爱好? 你最大的优点和缺点是什么? 你为什么会选择这个行业，职位? 你觉得你适合从事这个岗位吗? 你有什么职业规划? 你对工资有什么要求? 如何看待前端开发？ 未来三到五年的规划是怎样的？ 你的项目中技术难点是什么？遇到了什么问题？你是怎么解决的？ 你们部门的开发流程是怎样的 你认为哪个项目做得最好？ 说下工作中你做过的一些性能优化处理 最近在看哪些前端方面的书？ 平时是如何学习前端开发的？ 你最有成就感的一件事 你为什么要离开前一家公司？ 你对加班的看法 你希望通过这份工作获得什么？ 我想通过这份工作好好的锻炼自己，提升自己的能力，同时为公司贡献自己的一份力量","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"基础篇","slug":"基础篇","permalink":"http://www.chenya.site/tags/基础篇/"},{"name":"综合问题","slug":"综合问题","permalink":"http://www.chenya.site/tags/综合问题/"}]},{"title":"基础篇-09.其他综合问题","slug":"002.前端知识体系/001.基础篇/009.基础篇之其他问题","date":"2016-06-23T11:32:09.000Z","updated":"2019-09-16T01:57:01.488Z","comments":true,"path":"2016/06/23/002.前端知识体系/001.基础篇/009.基础篇之其他问题/","link":"","permalink":"http://www.chenya.site/2016/06/23/002.前端知识体系/001.基础篇/009.基础篇之其他问题/","excerpt":"","text":"九、其他1 负载均衡 多台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用 http重定向负载均衡：调度者根据策略选择服务器以302响应请求，缺点只有第一次有效果，后续操作维持在该服务器dns负载均衡：解析域名时，访问多个ip服务器中的一个（可监控性较弱） 反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大，性能受到 服务器群的数量 2 CDN 内容分发网络，基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 3 内存泄漏 定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题。 js中可能出现的内存泄漏情况 结果：变慢，崩溃，延迟大等，原因： 全局变量 dom清空时，还存在引用 ie中使用闭包 定时器未清理 子元素存在引起的内存泄露 避免策略 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收； 注意程序逻辑，避免“死循环”之类的 ； 避免创建过多的对象 原则：不用了的东西要及时归还。 减少层级过多的引用 4 babel原理 ES6、7代码输入 -&gt; babylon进行解析 -&gt; 得到AST（抽象语法树）-&gt; plugin用babel-traverse对AST树进行遍历转译 -&gt;得到新的AST树-&gt;用babel-generator通过AST树生成ES5代码 5 js自定义事件 三要素： document.createEvent() event.initEvent() element.dispatchEvent() // (en:自定义事件名称，fn:事件处理函数，addEvent:为DOM元素添加自定义事件，triggerEvent:触发自定义事件) window.onload = function(){ var demo = document.getElementById(\"demo\"); demo.addEvent(\"test\",function(){console.log(\"handler1\")}); demo.addEvent(\"test\",function(){console.log(\"handler2\")}); demo.onclick = function(){ this.triggerEvent(\"test\"); } } Element.prototype.addEvent = function(en,fn){ this.pools = this.pools || {}; if(en in this.pools){ this.pools[en].push(fn); }else{ this.pools[en] = []; this.pools[en].push(fn); } } Element.prototype.triggerEvent = function(en){ if(en in this.pools){ var fns = this.pools[en]; for(var i=0,il=fns.length;i&lt;il;i++){ fns[i](); } }else{ return; } } 6 前后端路由差别 后端每次路由请求都是重新访问服务器 前端路由实际上只是JS根据URL来操作DOM元素，根据每个页面需要的去服务端请求数据，返回数据后和模板进行组合","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"基础篇","slug":"基础篇","permalink":"http://www.chenya.site/tags/基础篇/"},{"name":"其他","slug":"其他","permalink":"http://www.chenya.site/tags/其他/"}]},{"title":"基础篇-08.编程题综合问题","slug":"002.前端知识体系/001.基础篇/008.基础篇之编程题综合问题","date":"2016-06-20T14:52:31.000Z","updated":"2019-09-16T01:57:01.488Z","comments":true,"path":"2016/06/20/002.前端知识体系/001.基础篇/008.基础篇之编程题综合问题/","link":"","permalink":"http://www.chenya.site/2016/06/20/002.前端知识体系/001.基础篇/008.基础篇之编程题综合问题/","excerpt":"","text":"八、编程题1 写一个通用的事件侦听器函数 // event(事件)工具集，来源：github.com/markyun markyun.Event = { // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) { if (element.addEventListener) { //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent('on' + type, function() { handler.call(element); }); } else { element['on' + type] = handler; } }, // 移除事件 removeEvent : function(element, type, handler) { if (element.removeEventListener) { element.removeEventListener(type, handler, false); } else if (element.datachEvent) { element.detachEvent('on' + type, handler); } else { element['on' + type] = null; } }, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) { if (ev.stopPropagation) { ev.stopPropagation(); } else { ev.cancelBubble = true; } }, // 取消事件的默认行为 preventDefault : function(event) { if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; } }, // 获取事件目标 getTarget : function(event) { return event.target || event.srcElement; } 2 如何判断一个对象是否为数组function isArray(arg) { if (typeof arg === 'object') { return Object.prototype.toString.call(arg) === '[object Array]'; } return false; } 3 冒泡排序 每次比较相邻的两个数，如果后一个比前一个小，换位置 var arr = [3, 1, 4, 6, 5, 7, 2]; function bubbleSort(arr) { for (var i = 0; i &lt; arr.length - 1; i++) { for(var j = 0; j &lt; arr.length - 1; j++) { if(arr[j + 1] &lt; arr[j]) { var temp; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } return arr; } console.log(bubbleSort(arr)); 4 快速排序 采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边 var arr = [3, 1, 4, 6, 5, 7, 2]; function quickSort(arr) { if(arr.length == 0) { return []; // 返回空数组 } var cIndex = Math.floor(arr.length / 2); var c = arr.splice(cIndex, 1); var l = []; var r = []; for (var i = 0; i &lt; arr.length; i++) { if(arr[i] &lt; c) { l.push(arr[i]); } else { r.push(arr[i]); } } return quickSort(l).concat(c, quickSort(r)); } console.log(quickSort(arr)); 5 编写一个方法 求一个字符串的字节长度 假设：一个英文字符占用一个字节，一个中文字符占用两个字节 function GetBytes(str){ var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++){ if (str.charCodeAt(i) > 255) bytes++; } return bytes; } alert(GetBytes(\"你好,as\")); 6 bind的用法，以及如何实现bind的函数和需要注意的点 bind的作用与call和apply相同，区别是call和apply是立即调用函数，而bind是返回了一个函数，需要调用的时候再执行。一个简单的bind函数实现如下 Function.prototype.bind = function(ctx) { var fn = this; return function() { fn.apply(ctx, arguments); }; }; 7 实现一个函数clone 可以对JavaScript中的5种主要的数据类型,包括Number、String、Object、Array、Boolean）进行值复 考察点1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚 考察点2：是否知道如何判断一个变量是什么类型的 考察点3：递归算法的设计 // 方法一： Object.prototype.clone = function(){ var o = this.constructor === Array ? [] : {}; for(var e in this){ o[e] = typeof this[e] === \"object\" ? this[e].clone() : this[e]; } return o; } //方法二： /** * 克隆一个对象 * @param Obj * @returns */ function clone(Obj) { var buf; if (Obj instanceof Array) { buf = []; //创建一个空的数组 var i = Obj.length; while (i--) { buf[i] = clone(Obj[i]); } return buf; }else if (Obj instanceof Object){ buf = {}; //创建一个空对象 for (var k in Obj) { //为这个对象添加新的属性 buf[k] = clone(Obj[k]); } return buf; }else{ //普通变量直接赋值 return Obj; } } 8 下面这个ul，如何点击每一列的时候alert其index \b考察闭包 &lt;ul id=”test”> &lt;li>这是第一条&lt;/li> &lt;li>这是第二条&lt;/li> &lt;li>这是第三条&lt;/li> &lt;/ul> // 方法一： var lis=document.getElementById('2223').getElementsByTagName('li'); for(var i=0;i&lt;3;i++) { lis[i].index=i; lis[i].onclick=function(){ alert(this.index); } //方法二： var lis=document.getElementById('2223').getElementsByTagName('li'); for(var i=0;i&lt;3;i++) { lis[i].index=i; lis[i].onclick=(function(a){ return function() { alert(a); } })(i); } 9 定义一个log方法，让它可以代理console.log的方法可行的方法一： function log(msg) { console.log(msg); } log(\"hello world!\") // hello world! 如果要传入多个参数呢？显然上面的方法不能满足要求，所以更好的方法是： function log(){ console.log.apply(console, arguments); }; 10 输出今天的日期 以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26 var d = new Date(); // 获取年，getFullYear()返回4位的数字 var year = d.getFullYear(); // 获取月，月份比较特殊，0是1月，11是12月 var month = d.getMonth() + 1; // 变成两位 month = month &lt; 10 ? '0' + month : month; // 获取日 var day = d.getDate(); day = day &lt; 10 ? '0' + day : day; alert(year + '-' + month + '-' + day); 11 用js实现随机选取10–100之间的10个数字，存入一个数组，并排序var iArray = []; funtion getRandom(istart, iend){ var iChoice = istart - iend +1; return Math.floor(Math.random() * iChoice + istart; } for(var i=0; i&lt;10; i++){ iArray.push(getRandom(10,100)); } iArray.sort(); 12 写一段JS程序提取URL中的各个GET参数 有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:’1′, b:’2′, c:”, d:’xxx’, e:undefined} function serilizeUrl(url) { var result = {}; url = url.split(\"?\")[1]; var map = url.split(\"&amp;\"); for(var i = 0, len = map.length; i &lt; len; i++) { result[map[i].split(\"=\")[0]] = map[i].split(\"=\")[1]; } return result; } 13 写一个function，清除字符串前后的空格 使用自带接口trim()，考虑兼容性： if (!String.prototype.trim) { String.prototype.trim = function() { return this.replace(/^\\s+/, \"\").replace(/\\s+$/,\"\"); } } // test the function var str = \" \\t\\n test string \".trim(); alert(str == \"test string\"); // alerts \"true\" 14 实现每隔一秒钟输出1,2,3…数字for(var i=0;i&lt;10;i++){ (function(j){ setTimeout(function(){ console.log(j+1) },j*1000) })(i) } 15 实现一个函数，判断输入是不是回文字符串function run(input) { if (typeof input !== 'string') return false; return input.split('').reverse().join('') === input; } 16、数组扁平化处理 实现一个flatten方法，使得输入一个数组，该数组里面的元素也可以是数组，该方法会输出一个扁平化的数组 function flatten(arr){ return arr.reduce(function(prev,item){ return prev.concat(Array.isArray(item)?flatten(item):item); },[]); }","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"基础篇","slug":"基础篇","permalink":"http://www.chenya.site/tags/基础篇/"},{"name":"编程题","slug":"编程题","permalink":"http://www.chenya.site/tags/编程题/"}]},{"title":"基础篇-07.webpack综合问题","slug":"002.前端知识体系/001.基础篇/007.基础篇之webpack综合问题","date":"2016-06-12T12:23:15.000Z","updated":"2019-09-16T01:57:01.488Z","comments":true,"path":"2016/06/12/002.前端知识体系/001.基础篇/007.基础篇之webpack综合问题/","link":"","permalink":"http://www.chenya.site/2016/06/12/002.前端知识体系/001.基础篇/007.基础篇之webpack综合问题/","excerpt":"","text":"七、webpack相关1 打包体积 优化思路 提取第三方库或通过引用外部文件的方式引入第三方库 代码压缩插件UglifyJsPlugin 服务器启用gzip压缩 按需加载资源文件 require.ensure 优化devtool中的source-map 剥离css文件，单独打包 去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致 2 打包效率 开发环境采用增量构建，启用热更新 开发环境不做无意义的工作如提取css计算文件hash等 配置devtool 选择合适的loader 个别loader开启cache 如babel-loader 第三方库采用引入方式 提取公共代码 优化构建时的搜索路径 指明需要构建目录及不需要构建目录 模块化引入需要的部分 3 Loader编写一个loader loader就是一个node模块，它输出了一个函数。当某种资源需要用这个loader转换时，这个函数会被调用。并且，这个函数可以通过提供给它的this上下文访问Loader API。reverse-txt-loader // 定义 module.exports = function(src) { //src是原文件内容（abcde），下面对内容进行处理，这里是反转 var result = src.split('').reverse().join(''); //返回JavaScript源码，必须是String或者Buffer return `module.exports = '${result}'`; } //使用 { test: /\\.txt$/, use: [ { './path/reverse-txt-loader' } ] }, 4 说一下webpack的一些plugin，怎么使用webpack对项目进行优化构建优化 减少编译体积 ContextReplacementPugin、IgnorePlugin、babel-plugin-import、babel-plugin-transform-runtime 并行编译 happypack、thread-loader、uglifyjsWebpackPlugin开启并行 缓存 cache-loader、hard-source-webpack-plugin、uglifyjsWebpackPlugin开启缓存、babel-loader开启缓存 预编译 dllWebpackPlugin &amp;&amp; DllReferencePlugin、auto-dll-webapck-plugin 性能优化 减少编译体积 Tree-shaking、Scope Hositing hash缓存 webpack-md5-plugin 拆包 splitChunksPlugin、import()、require.ensure","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"基础篇","slug":"基础篇","permalink":"http://www.chenya.site/tags/基础篇/"},{"name":"webpack","slug":"webpack","permalink":"http://www.chenya.site/tags/webpack/"}]},{"title":"基础篇-06.微信小程序综合问题","slug":"002.前端知识体系/001.基础篇/006.基础篇之微信小程序综合问题","date":"2016-06-06T05:42:55.000Z","updated":"2019-09-16T01:57:01.488Z","comments":true,"path":"2016/06/06/002.前端知识体系/001.基础篇/006.基础篇之微信小程序综合问题/","link":"","permalink":"http://www.chenya.site/2016/06/06/002.前端知识体系/001.基础篇/006.基础篇之微信小程序综合问题/","excerpt":"","text":"1 微信小程序有几个文件 WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，js 逻辑处理，网络请求json小程序设置，如页面注册，页面标题及 tabBar。 app.json 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window 背景色，配置导航条样式，配置默认标题。 app.js 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。 app.wxss 配置全局 css 2 微信小程序怎样跟事件传值 给 HTML 元素添加 data-*属性来传递我们需要的值，然后通过 e.currentTarget.dataset 或onload的param参数获取。但 data - 名称不能有大写字母和不可以存放对象 3 小程序的 wxss 和 css 有哪些不一样的地方？ wxss的图片引入需使用外链地址 没有 Body；样式可直接使用 import 导入 4 小程序关联微信公众号如何确定用户的唯一性 使用 wx.getUserInfo 方法 withCredentials 为 true 时 可获取 encryptedData，里面有 union_id。后端需要进行对称解密 生命周期不一样，微信小程序生命周期比较简单 数据绑定也不同，微信小程序数据绑定需要使用双大括号，vue 直接:就可以 显示与隐藏元素，vue中，使用 v-if 和 v-show 控制元素的显示和隐藏，小程序中，使用wx-if 和hidden 控制元素的显示和隐藏 事件处理不同，小程序中，全用 bindtap(bind+event)，或者 catchtap(catch+event) 绑定事件,vue：使用 v-on:event 绑定事件，或者使用@event 绑定事件 数据双向绑定也不也不一样在 vue中,只需要再表单元素上加上 v-model,然后再绑定 data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是 vue非常 nice 的一点。微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个 data中声明的变量。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"基础篇","slug":"基础篇","permalink":"http://www.chenya.site/tags/基础篇/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://www.chenya.site/tags/微信小程序/"}]},{"title":"基础篇-05.Bootstrap综合问题","slug":"002.前端知识体系/001.基础篇/005.基础篇之Bootstrap综合问题","date":"2016-06-02T17:02:15.000Z","updated":"2019-09-16T01:57:01.488Z","comments":true,"path":"2016/06/03/002.前端知识体系/001.基础篇/005.基础篇之Bootstrap综合问题/","link":"","permalink":"http://www.chenya.site/2016/06/03/002.前端知识体系/001.基础篇/005.基础篇之Bootstrap综合问题/","excerpt":"","text":"五、Bootstrap1 什么是Bootstrap？以及为什么要使用Bootstrap？ Bootstrap 是一个用于快速开发 Web应用程序和网站的前端框架。Bootstrap是基于 HTML、CSS、JAVASCRIPT 的 Bootstrap具有移动设备优先、浏览器支持良好、容易上手、响应式设计等优点，所以Bootstrap被广泛应用 2 使用Bootstrap时，要声明的文档类型是什么？以及为什么要这样声明？ 使用Bootstrap时，需要使用 HTML5 文档类型（Doctype）。&lt;!DOCTYPE html&gt; 因为Bootstrap使用了一些 HTML5 元素和 CSS 属性，如果在 Bootstrap创建的网页开头不使用 HTML5 的文档类型（Doctype），可能会面临一些浏览器显示不一致的问题，甚至可能面临一些特定情境下的不一致，以致于代码不能通过 W3C 标准的验证 3 什么是Bootstrap网格系统 Bootstrap 包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到 12 列。它包含了用于简单的布局选项的预定义类，也包含了用于生成更多语义布局的功能强大的混合类 响应式网格系统随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。 4 Bootstrap 网格系统（Grid System）的工作原理 （1）行必须放置在 .container class 内，以便获得适当的对齐（alignment）和内边距（padding）。 （2）使用行来创建列的水平组。 （3）内容应该放置在列内，且唯有列可以是行的直接子元素。 （4）预定义的网格类，比如 .row 和 .col-xs-4，可用于快速创建网格布局。LESS 混合类可用于更多语义布局。 （5）列通过内边距（padding）来创建列内容之间的间隙。该内边距是通过 .rows 上的外边距（margin）取负，表示第一列和最后一列的行偏移。 （6）网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个 .col-xs-4 5 对于各类尺寸的设备，Bootstrap设置的class前缀分别是什么 超小设备手机（&lt;768px）：.col-xs- 小型设备平板电脑（&gt;=768px）：.col-sm- 中型设备台式电脑（&gt;=992px）：.col-md- 大型设备台式电脑（&gt;=1200px）：.col-lg- 6 Bootstrap 网格系统列与列之间的间隙宽度是多少 间隙宽度为30px（一个列的每边分别是15px） 7 如果需要在一个标题的旁边创建副标题，可以怎样操作 在元素两旁添加&lt;small&gt;，或者添加.small的class 8 用Bootstrap，如何设置文字的对齐方式？ class=&quot;text-center&quot; 设置居中文本 class=&quot;text-right&quot; 设置向右对齐文本 class=&quot;text-left&quot; 设置向左对齐文本 9 Bootstrap如何设置响应式表格？ 增加class=&quot;table-responsive&quot; 10 使用Bootstrap创建垂直表单的基本步骤？ （1）向父&lt;form&gt;元素添加role=&quot;form&quot;； （2）把标签和控件放在一个带有class=&quot;form-group&quot;的&lt;div&gt;中，这是获取最佳间距所必需的； （3）向所有的文本元素&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;添加class=&quot;form-control&quot; 11 使用Bootstrap创建水平表单的基本步骤？ （1）向父&lt;form&gt;元素添加class=&quot;form-horizontal&quot;； （2）把标签和控件放在一个带有class=&quot;form-group&quot;的&lt;div&gt;中； （3）向标签添加class=&quot;control-label&quot;。 12 使用Bootstrap如何创建表单控件的帮助文本？ 增加class=&quot;help-block&quot;的span标签或p标签。 13 使用Bootstrap激活或禁用按钮要如何操作？ 激活按钮：给按钮增加.active的class 禁用按钮：给按钮增加disabled=&quot;disabled&quot;的属性 14 Bootstrap有哪些关于的class？ （1）.img-rounded 为图片添加圆角 （2）.img-circle 将图片变为圆形 （3）.img-thumbnail 缩略图功能 （4）.img-responsive 图片响应式 (将很好地扩展到父元素) 15 Bootstrap中有关元素浮动及清除浮动的class？ （1）class=&quot;pull-left&quot; 元素浮动到左边 （2）class=&quot;pull-right&quot; 元素浮动到右边 （3）class=&quot;clearfix&quot; 清除浮动 16 除了屏幕阅读器外，其他设备上隐藏元素的class？ class=&quot;sr-only&quot;` 17 Bootstrap如何制作下拉菜单？ （1）将下拉菜单包裹在class=&quot;dropdown&quot;的&lt;div&gt;中； （2）在触发下拉菜单的按钮中添加：class=&quot;btn dropdown-toggle&quot; id=&quot;dropdownMenu1&quot; data-toggle=&quot;dropdown&quot; （3）在包裹下拉菜单的ul中添加：class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;dropdownMenu1&quot; （4）在下拉菜单的列表项中添加：role=&quot;presentation&quot;。其中，下拉菜单的标题要添加class=&quot;dropdown-header&quot;，选项部分要添加tabindex=&quot;-1&quot;。 18 Bootstrap如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？ （1）用class=&quot;btn-group&quot;的&lt;div&gt;去包裹按钮组；class=&quot;btn-group-vertical&quot;可设置垂直按钮组。 （2）btn-group的优先级高于btn-group-vertical的优先级。 19 Bootstrap如何设置按钮的下拉菜单？ 在一个 .btn-group 中放置按钮和下拉菜单即可。 20 Bootstrap中的输入框组如何制作？ （1）把前缀或者后缀元素放在一个带有class=&quot;input-group&quot;中的&lt;div&gt;中 （2）在该&lt;div&gt;内，在class=&quot;input-group-addon&quot;的&lt;span&gt;里面放置额外的内容； （3）把&lt;span&gt;放在&lt;input&gt;元素的前面或后面。 21 Bootstrap中的导航都有哪些？ （1）导航元素：有class=&quot;nav nav-tabs&quot;的标签页导航，还有class=&quot;nav nav-pills&quot;的胶囊式标签页导航； （2）导航栏：class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;； （3）面包屑导航：class=&quot;breadcrumb&quot; 22 Bootstrap中设置分页的class？ 默认的分页：class=&quot;pagination&quot; 默认的翻页：class=&quot;pager&quot; 23 Bootstrap中显示标签的class？ class=&quot;label&quot; 24 Bootstrap中如何制作徽章？ &lt;span class=&quot;badge&quot;&gt;26&lt;/span&gt; 25 Bootstrap中超大屏幕的作用是什么？ 设置class=&quot;jumbotron&quot;可以制作超大屏幕，该组件可以增加标题的大小并增加更多的外边距","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"基础篇","slug":"基础篇","permalink":"http://www.chenya.site/tags/基础篇/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://www.chenya.site/tags/Bootstrap/"}]},{"title":"基础篇-04.jQuery综合问题","slug":"002.前端知识体系/001.基础篇/004.基础篇之jQuery综合问题","date":"2016-06-01T04:29:02.000Z","updated":"2019-09-16T01:57:01.488Z","comments":true,"path":"2016/06/01/002.前端知识体系/001.基础篇/004.基础篇之jQuery综合问题/","link":"","permalink":"http://www.chenya.site/2016/06/01/002.前端知识体系/001.基础篇/004.基础篇之jQuery综合问题/","excerpt":"","text":"四、jQuery1 你觉得jQuery或zepto源码有哪些写的好的地方 jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链 (function( window, undefined ) { //用一个函数域包起来，就是所谓的沙箱 //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局 //把当前沙箱需要的外部变量通过函数参数引入进来 //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数 window.jQuery = window.$ = jQuery; })( window ); jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度 jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率 2 jQuery 的实现原理 (function(window, undefined) {})(window); jQuery 利用 JS 函数作用域的特性，采用立即调用表达式包裹了自身，解决命名空间和变量污染问题 window.jQuery = window.$ = jQuery; 在闭包当中将 jQuery 和 $ 绑定到 window 上，从而将 jQuery 和 $ 暴露为全局变量 3 jQuery.fn 的 init 方法返回的 this 指的是什么对象 jQuery.fn 的 init 方法 返回的 this 就是 jQuery 对象 用户使用 jQuery() 或 $() 即可初始化 jQuery 对象，不需要动态的去调用 init 方法 4 jQuery.extend 与 jQuery.fn.extend 的区别 $.fn.extend() 和 $.extend() 是 jQuery 为扩展插件提拱了两个方法 $.extend(object); // 为jQuery添加“静态方法”（工具方法） $.extend({ min: function(a, b) { return a &lt; b ? a : b; }, max: function(a, b) { return a > b ? a : b; } }); $.min(2,3); // 2 $.max(4,5); // 5 $.extend([true,] targetObject, object1[, object2]); // 对targt对象进行扩展 var settings = {validate:false, limit:5}; var options = {validate:true, name:\"bar\"}; $.extend(settings, options); // 注意：不支持第一个参数传 false // settings == {validate:true, limit:5, name:\"bar\"} $.fn.extend(json); // 为jQuery添加“成员函数”（实例方法） $.fn.extend({ alertValue: function() { $(this).click(function(){ alert($(this).val()); }); } }); $(\"#email\").alertValue(); 5 jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝 浅拷贝（只复制一份原始对象的引用）var newObject = $.extend({}, oldObject); 深拷贝（对原始对象属性所引用的对象进行进行递归拷贝）var newObject = $.extend(true, {}, oldObject); 6 jQuery 的队列是如何实现的 jQuery 核心中有一组队列控制方法，由 queue()/dequeue()/clearQueue() 三个方法组成。 主要应用于 animate()，ajax，其他要按时间顺序执行的事件中 var func1 = function(){alert('事件1');} var func2 = function(){alert('事件2');} var func3 = function(){alert('事件3');} var func4 = function(){alert('事件4');} // 入栈队列事件 $('#box').queue(\"queue1\", func1); // push func1 to queue1 $('#box').queue(\"queue1\", func2); // push func2 to queue1 // 替换队列事件 $('#box').queue(\"queue1\", []); // delete queue1 with empty array $('#box').queue(\"queue1\", [func3, func4]); // replace queue1 // 获取队列事件（返回一个函数数组） $('#box').queue(\"queue1\"); // [func3(), func4()] // 出栈队列事件并执行 $('#box').dequeue(\"queue1\"); // return func3 and do func3 $('#box').dequeue(\"queue1\"); // return func4 and do func4 // 清空整个队列 $('#box').clearQueue(\"queue1\"); // delete queue1 with clearQueue 7 jQuery 中的 bind(), live(), delegate(), on()的区别 bind 直接绑定在目标元素上 live 通过冒泡传播事件，默认document上，支持动态数据 delegate 更精确的小范围使用事件代理，性能优于 live on 是最新的1.9版本整合了之前的三种方式的新事件绑定机制 8 是否知道自定义事件 事件即“发布/订阅”模式，自定义事件即“消息发布”，事件的监听即“订阅订阅” JS 原生支持自定义事件，示例： document.createEvent(type); // 创建事件 event.initEvent(eventType, canBubble, prevent); // 初始化事件 target.addEventListener('dataavailable', handler, false); // 监听事件 target.dispatchEvent(e); // 触发事件 jQuery 里的fire 函数用于调用jQuery自定义事件列表中的事件 9 jQuery 通过哪个方法和 Sizzle 选择器结合的 Sizzle 选择器采取 Right To Left 的匹配模式，先搜寻所有匹配标签，再判断它的父节点 jQuery 通过 $(selecter).find(selecter); 和 Sizzle 选择器结合 10 jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来// 通过原生 JSON.stringify/JSON.parse 扩展 jQuery 实现 $.array2json = function(array) { return JSON.stringify(array); } $.json2array = function(array) { // $.parseJSON(array); // 3.0 开始，已过时 return JSON.parse(array); } // 调用 var json = $.array2json(['a', 'b', 'c']); var array = $.json2array(json); 11 jQuery 一个对象可以同时绑定多个事件，这是如何实现的 $(\"#btn\").on(\"mouseover mouseout\", func); $(\"#btn\").on({ mouseover: func1, mouseout: func2, click: func3 }); 12 针对 jQuery 的优化方法 缓存频繁操作DOM对象 尽量使用id选择器代替class选择器 总是从#id选择器来继承 尽量使用链式操作 使用时间委托 on绑定事件 采用jQuery的内部函数data()来存储数据 使用最新版本的 jQuery 13 jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢 在触发元素上的事件设置为延迟处理：使用 JS 原生 setTimeout 方法 在触发元素的事件时预先停止所有的动画，再执行相应的动画事件：$(&#39;.tab&#39;).stop().slideUp(); 14 jQuery UI 如何自定义组件 通过向 $.widget() 传递组件名称和一个原型对象来完成 $.widget(&quot;ns.widgetName&quot;, [baseWidget], widgetPrototype); 15 jQuery 与 jQuery UI、jQuery Mobile 区别 jQuery 是 JS 库，兼容各种PC浏览器，主要用作更方便地处理 DOM、事件、动画、AJAX jQuery UI 是建立在 jQuery 库上的一组用户界面交互、特效、小部件及主题 jQuery Mobile 以 jQuery 为基础，用于创建“移动Web应用”的框架 16 jQuery 和 Zepto 的区别？ 各自的使用场景 jQuery 主要目标是PC的网页中，兼容全部主流浏览器。在移动设备方面，单独推出 `jQuery Mobile Zepto从一开始就定位移动设备，相对更轻量级。它的API 基本兼容jQuery`，但对PC浏览器兼容不理想 17 jQuery对象的特点 只有 JQuery对象才能使用 JQuery 方法 JQuery 对象是一个数组对象","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"基础篇","slug":"基础篇","permalink":"http://www.chenya.site/tags/基础篇/"},{"name":"jQuery","slug":"jQuery","permalink":"http://www.chenya.site/tags/jQuery/"}]},{"title":"基础篇-03.JavaScript综合问题","slug":"002.前端知识体系/001.基础篇/003.基础篇之JavaScript综合问题","date":"2016-05-31T04:18:51.000Z","updated":"2019-09-16T01:57:01.487Z","comments":true,"path":"2016/05/31/002.前端知识体系/001.基础篇/003.基础篇之JavaScript综合问题/","link":"","permalink":"http://www.chenya.site/2016/05/31/002.前端知识体系/001.基础篇/003.基础篇之JavaScript综合问题/","excerpt":"","text":"三、JavaScript1 闭包 闭包就是能够读取其他函数内部变量的函数 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域 闭包的特性： 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 说说你对闭包的理解 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中 闭包的另一个用处，是封装对象的私有属性和私有方法 好处：能够实现封装和缓存等； 坏处：就是消耗内存、不正当使用会造成内存溢出的问题 使用闭包的注意点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露 解决方法是，在退出函数之前，将不使用的局部变量全部删除 2 说说你对作用域链的理解 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的 简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期 3 JavaScript原型，原型链 ? 有什么特点？ 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念 关系：instance.constructor.prototype = instance.__proto__ 特点： JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象 4 请解释什么是事件代理 事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能 可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒 可以实现当新增子对象时无需再次对其绑定 5 Javascript如何实现继承？ 构造继承 原型继承 实例继承 拷贝继承 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式 function Parent(){ this.name = 'wang'; } function Child(){ this.age = 28; } Child.prototype = new Parent();//继承了Parent，通过原型 var demo = new Child(); alert(demo.age); alert(demo.name);//得到被继承的属性 } 6 谈谈This对象的理解 this总是指向函数的直接调用者（而非间接调用者） 如果有new关键字，this指向new出来的那个对象 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window 7 事件模型 W3C中定义事件的发生经历三个阶段：捕获阶段（capturing）、目标阶段（targetin）、冒泡阶段（bubbling） 冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发 捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发 DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件 阻止冒泡：在W3c中，使用stopPropagation（）方法；在IE下设置cancelBubble = true 阻止捕获：阻止事件的默认行为，例如click - &lt;a&gt;后的跳转。在W3c中，使用preventDefault（）方法，在IE下设置window.event.returnValue = false 8 new操作符具体干了什么呢? 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this 9 Ajax原理 Ajax的原理简单来说是在用户和服务器之间加了—个中间层(AJAX引擎)，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据 Ajax的过程只涉及JavaScript、XMLHttpRequest和DOM。XMLHttpRequest是ajax的核心机制 // 1. 创建连接 var xhr = null; xhr = new XMLHttpRequest() // 2. 连接服务器 xhr.open('get', url, true) // 3. 发送请求 xhr.send(null); // 4. 接受请求 xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ if(xhr.status == 200){ success(xhr.responseText); } else { // fail fail &amp;&amp; fail(xhr.status); } } } ajax 有那些优缺点? 优点： 通过异步模式，提升了用户体验. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用. Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。 Ajax可以实现动态不刷新（局部刷新） 缺点： 安全问题 AJAX暴露了与服务器交互的细节。 对搜索引擎的支持比较弱。 不容易调试。 10 如何解决跨域问题? 首先了解下浏览器的同源策略 同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口“三者相同，即便两个不同的域名指向同一个ip地址，也非同源 那么怎样解决跨域问题的呢？ 通过jsonp跨域 var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.....:8080/login?user=admin&amp;callback=onBack'; document.head.appendChild(script); // 回调执行函数 function onBack(res) { alert(JSON.stringify(res)); } document.domain + iframe跨域 此方案仅限主域相同，子域不同的跨域应用场景 1.）父窗口：(http://www.domain.com/a.html) &lt;iframe id=\"iframe\" src=\"http://child.domain.com/b.html\">&lt;/iframe> &lt;script> document.domain = 'domain.com'; var user = 'admin'; &lt;/script> 2.）子窗口：(http://child.domain.com/b.html) document.domain = 'domain.com'; // 获取父窗口中变量 alert('get js data from parent ---> ' + window.parent.user); nginx代理跨域 nodejs中间件代理跨域 后端在头部信息里面设置安全域名 11 模块化开发怎么做？ 立即执行函数,不暴露私有成员 var module1 = (function(){ var _count = 0; var m1 = function(){ //... }; var m2 = function(){ //... }; return { m1 : m1, m2 : m2 }; })(); 12 异步加载JS的方式有哪些？ defer，只支持IE async： 创建script，插入到DOM中，加载完毕后callBack 13 那些操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏 闭包使用不当 14 XML和JSON的区别？ 数据体积方面 JSON相对于XML来讲，数据的体积小，传递的速度更快些。 数据交互方面 JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互 数据描述方面 JSON对数据的描述性比XML较差 传输速度方面 JSON的速度要远远快于XML 15 谈谈你对webpack的看法 WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源 16 说说你对AMD和Commonjs的理解 CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 17 常见web安全及防护原理 sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令 总的来说有以下几点 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双&quot;-&quot;进行转换等 永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息 XSS原理及防范 Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点 XSS防范方法 首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击 XSS与CSRF有什么区别吗？ XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤 登录受信任网站A，并在本地生成Cookie 在不登出A的情况下，访问危险网站B CSRF的防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数 通过验证码的方法 18 用过哪些设计模式？ 工厂模式： 工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字 构造函数模式 使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于 直接将属性和方法赋值给 this对象; 19 为什么要有同源限制？ 同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议 举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 20 offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别 offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同 clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条 scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸 21 javascript有哪些方法定义对象 对象字面量： var obj = {}; 构造函数： var obj = new Object(); Object.create(): var obj = Object.create(Object.prototype); 22 常见兼容性问题？ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一,，但是全局效率很低，一般是如下这样解决： body,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p{ margin:0; padding:0; } IE下,event对象有x,y属性,但是没有pageX,pageY属性 Firefox下,event对象有pageX,pageY属性,但是没有x,y属性. 23 说说你对promise的了解 依照 Promise/A+ 的定义，Promise 有四种状态： pending: 初始状态, 非 fulfilled 或 rejected. fulfilled: 成功的操作. rejected: 失败的操作. settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled与 rejected一起合称 settled Promise 对象用来进行延迟(deferred) 和异步(asynchronous) 计算 Promise 的构造函数 构造一个 Promise，最基本的用法如下： var promise = new Promise(function(resolve, reject) { if (...) { // succeed resolve(result); } else { // fails reject(Error(errMessage)); } }); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下： promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应resolve, onRejected对应 reject 24 你觉得jQuery源码有哪些写的好的地方 jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链 jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度 jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率 25 vue、react、angular Vue.js一个用于创建 web 交互界面的库，是一个精简的 MVVM。它通过双向数据绑定把 View 层和 Model 层连接了起来。实际的 DOM 封装和输出格式都被抽象为了Directives 和 Filters AngularJS是一个比较完善的前端MVVM框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 Angular指令 reactReact 仅仅是 VIEW 层是facebook公司。推出的一个用于构建UI的一个库，能够实现服务器端的渲染。用了virtual dom，所以性能很好。 26 Node的应用场景 特点： 1、它是一个Javascript运行环境 2、依赖于Chrome V8引擎进行代码解释 3、事件驱动 4、非阻塞I/O 5、单进程，单线程 优点： 高并发（最重要的优点） 缺点： 1、只支持单核CPU，不能充分利用CPU 2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃 27 谈谈你对AMD、CMD的理解 CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 es6模块 commonjs amd cmd CommonJS 的规范中，每个 JavaScript 文件就是一个独立的模块上下文（module context），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。 CommonJS是同步加载模块,在浏览器中会出现堵塞情况，所以不适用 AMD 异步，需要定义回调define方式 es6 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量es6还可以导出类、方法，自动适用严格模式 28 那些操作会造成内存泄漏 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 29 web开发中会话跟踪的方法有哪些 cookie session url重写 隐藏input ip地址 30 介绍js的基本数据类型 Undefined、Null、Boolean、Number、String 31 介绍js有哪些内置对象 Object 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error 32 说几条写JavaScript的基本规范 不要在同一行声明多个变量 请使用===/!==来比较true/false或者数值 使用对象字面量替代new Array这种形式 不要使用全局函数 Switch语句必须带有default分支 If语句必须使用大括号 for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污 33 JavaScript有几种类型的值 栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其 在栈中的地址，取得地址后从堆中获得实体 34 javascript创建对象的几种方式 javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用 对象字面量的方式 person={firstname:\"Mark\",lastname:\"Yun\",age:25,eyecolor:\"black\"}; 用function来模拟无参的构造函数 function Person(){} var person=new Person();//定义一个function，如果使用new\"实例化\",该function可以看作是一个Class person.name=\"Mark\"; person.age=\"25\"; person.work=function(){ alert(person.name+\" hello...\"); } person.work(); 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） function Pet(name,age,hobby){ this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function(){ alert(\"我叫\"+this.name+\",我喜欢\"+this.hobby+\",是个程序员\"); } } var maidou =new Pet(\"麦兜\",25,\"coding\");//实例化、创建对象 maidou.eat();//调用eat方法 用工厂方式来创建（内置对象） var wcDog =new Object(); wcDog.name=\"旺财\"; wcDog.age=3; wcDog.work=function(){ alert(\"我是\"+wcDog.name+\",汪汪汪......\"); } wcDog.work(); 用原型方式来创建 function Dog(){ } Dog.prototype.name=\"旺财\"; Dog.prototype.eat=function(){ alert(this.name+\"是个吃货\"); } var wangcai =new Dog(); wangcai.eat(); 用混合方式来创建 function Car(name,price){ this.name=name; this.price=price; } Car.prototype.sell=function(){ alert(\"我是\"+this.name+\"，我现在卖\"+this.price+\"万元\"); } var camry =new Car(\"凯美瑞\",27); camry.sell(); 35 eval是做什么的 它的功能是把对应的字符串解析成JS代码并运行 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&#39;(&#39;+ str +&#39;)&#39;) 36 null，undefined 的区别 undefined 表示不存在这个值。 undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined 例如变量被声明了，但没有赋值时，就等于undefined null 表示一个对象被定义了，值为“空值” null : 是一个对象(空对象, 没有任何属性和方法) 例如作为函数的参数，表示该函数的参数不是对象； 在验证null时，一定要使用 === ，因为 ==无法分别null 和 undefined 37 [“1”, “2”, “3”].map(parseInt) 答案是多少 [1, NaN, NaN]因为 parseInt 需要两个参数 (val, radix)，其中radix 表示解析时用的基数。 map传了 3个(element, index, array)，对应的 radix 不合法导致解析失败。 38 javascript 代码中的”use strict”;是什么意思 use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 39 JSON 的了解 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小 JSON字符串转换为JSON对象: var obj =eval('('+ str +')'); var obj = str.parseJSON(); var obj = JSON.parse(str); JSON对象转换为JSON字符串： var last=obj.toJSONString(); var last=JSON.stringify(obj); 40 js延迟加载的方式有哪些 defer和async、动态创建DOM方式（用得最多）、按需异步载入js 41 同步和异步的区别 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容 42 渐进增强和优雅降级 渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 43 defer和async defer并行加载js文件，会按照页面上script标签的顺序执行 async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 44 说说严格模式的限制 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 禁止this指向全局对象 45 attribute和property的区别是什么 attribute是dom元素在文档中作为html标签拥有的属性； property就是dom元素在js中作为对象拥有的属性。 对于html的标准属性来说，attribute和property是同步的，是会自动更新的 但是对于自定义的属性来说，他们是不同步的 46 谈谈你对ES6的理解 新增模板字符串（为JavaScript提供了简单的字符串插值功能） 箭头函数 for-of（用来遍历数据—例如数组中的值。） arguments对象可被不定参数和默认参数完美代替。 ES6将promise对象纳入规范，提供了原生的Promise对象。 增加了let和const命令，用来声明变量。 增加了块级作用域。 let命令实际上就增加了块级作用域。 还有就是引入module模块的概念 47 ECMAScript6 怎么写class么 这个语法糖可以让有OOP基础的人更快上手js，至少是一个官方的实现了 但对熟悉js的人来说，这个东西没啥大影响；一个Object.creat()搞定继承，比class简洁清晰的多 48 什么是面向对象编程及面向过程编程，它们的异同和优缺点 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为 面向对象是以功能来划分问题，而不是步骤 49 面向对象编程思想 基本思想是使用对象，类，继承，封装等基本概念来进行程序设计 优点 易维护 采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的 易扩展 开发工作的重用性、继承性高，降低重复工作量。 缩短了开发周期 50 对web标准、可用性、可访问性的理解 可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力 可访问性（Accessibility）：Web内容对于残障用户的可阅读和可理解性 可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。 51 如何通过JS判断一个数组 instanceof方法 instanceof 运算符是用来测试一个对象是否在其原型链原型构造函数的属性 var arr = []; arr instanceof Array; // true constructor方法 constructor属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数 var arr = []; arr.constructor == Array; //true 最简单的方法 这种写法，是 jQuery 正在使用的 Object.prototype.toString.call(value) == '[object Array]' // 利用这个方法，可以写一个返回数据类型的方法 var isType = function (obj) { return Object.prototype.toString.call(obj).slice(8,-1); } ES5新增方法isArray() var a = new Array(123); var b = new Date(); console.log(Array.isArray(a)); //true console.log(Array.isArray(b)); //false 52 谈一谈let与var的区别 let命令不存在变量提升，如果在let前使用，会导致报错 如果块区中存在let和const命令，就会形成封闭作用域 不允许重复声明，因此，不能在函数内部重新声明参数 53 map与forEach的区别 forEach方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容item、数组索引index、和当前遍历数组Array map方法，基本用法与forEach一致，但是不同的，它会返回一个新的数组，所以在callback需要有return值，如果没有，会返回undefined 54 谈一谈你理解的函数式编程 简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论 它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是”第一等公民”、只用”表达式” 55 谈一谈箭头函数与普通函数的区别？ 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替 不可以使用yield命令，因此箭头函数不能用作Generator函数 56 谈一谈函数中this的指向 this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象 《javascript语言精髓》中大概概括了4种调用方式： 方法调用模式 函数调用模式 构造器调用模式 graph LR A-->B apply/call调用模式 57 异步编程的实现方式 回调函数 优点：简单、容易理解 缺点：不利于维护，代码耦合高 事件监听(采用时间驱动模式，取决于某个事件是否发生)： 优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数 缺点：事件驱动型，流程不够清晰 发布/订阅(观察者模式) 类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者 Promise对象 优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数； 缺点：编写和理解，相对比较难 Generator函数 优点：函数体内外的数据交换、错误处理机制 缺点：流程管理不方便 async函数 优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。 缺点：错误处理机制 58 对原生Javascript了解程度 数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 59 Js动画与CSS动画区别及相应实现 CSS3的动画的优点 在性能上会稍微好一些，浏览器会对CSS3的动画做一些优化 代码相对简单 缺点 在动画控制上不够灵活 兼容性不好 JavaScript的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容IE6，并且功能强大。对于一些复杂控制的动画，使用javascript会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑CSS吧 60 JS 数组和对象的遍历方式，以及几种方式的比较 通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。一般我们会采用下几种方式来进行数组的遍历 for in循环 for循环 forEach 这里的 forEach回调中两个参数分别为 value，index forEach 无法遍历对象 IE不支持该方法；Firefox 和 chrome 支持 forEach 无法使用 break，continue 跳出循环，且使用 return 是跳过本次循环 这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题 在方式一中，for-in需要分析出array的每个属性，这个操作性能开销很大。用在 key 已知的数组上是非常不划算的。所以尽量不要用for-in，除非你不清楚要处理哪些属性，例如 JSON对象这样的情况 在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 array 里存放的都是 DOM 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低 61 gulp是什么 gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成 Gulp的核心概念：流 流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向 gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作 Gulp的特点： 易于使用：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理 构建快速 利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作 易于学习 通过最少的 API，掌握 gulp 毫不费力，构建工作尽在掌握：如同一系列流管道 62 说一下Vue的双向绑定数据的原理 vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调 63 事件的各个阶段 1：捕获阶段 —&gt; 2：目标阶段 —&gt; 3：冒泡阶段 document —&gt; target目标 —-&gt; document 由此，addEventListener的第三个参数设置为true和false的区别已经非常清晰了 true表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件 false表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件 64 let var constlet 允许你声明一个作用域被限制在块级中的变量、语句或者表达式 let绑定不受变量提升的约束，这意味着let声明不会被提升到当前 该变量处于从块开始到初始化处理的“暂存死区” var 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的 由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明 const 声明创建一个值的只读引用 (即指针) 基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 const申明基本数据类型时 再将其值改变时，将会造成报错， 例如 const a = 3 ; a = 5时 将会报错 但是如果是复合类型时，如果只改变复合类型的其中某个Value项时， 将还是正常使用 65 快速的让一个数组乱序var arr = [1,2,3,4,5,6,7,8,9,10]; arr.sort(function(){ return Math.random() - 0.5; }) console.log(arr); 66 如何渲染几万条数据并不卡住界面 这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 requestAnimationFrame 来每 16 ms 刷新一次 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;ul>控件&lt;/ul> &lt;script> setTimeout(() => { // 插入十万条数据 const total = 100000 // 一次插入 20 条，如果觉得性能不好就减少 const once = 20 // 渲染数据总共需要几次 const loopCount = total / once let countOfRender = 0 let ul = document.querySelector(\"ul\"); function add() { // 优化性能，插入不会造成回流 const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; once; i++) { const li = document.createElement(\"li\"); li.innerText = Math.floor(Math.random() * total); fragment.appendChild(li); } ul.appendChild(fragment); countOfRender += 1; loop(); } function loop() { if (countOfRender &lt; loopCount) { window.requestAnimationFrame(add); } } loop(); }, 0); &lt;/script> &lt;/body> &lt;/html> 67 希望获取到页面中所有的checkbox怎么做？ 不使用第三方框架 var domList = document.getElementsByTagName(‘input’) var checkBoxList = []; var len = domList.length; //缓存到局部变量 while (len--) { //使用while的效率会比for循环更高 if (domList[len].type == ‘checkbox’) { checkBoxList.push(domList[len]); } } 68 怎样添加、移除、移动、复制、创建和查找节点创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 添加、移除、替换、插入 appendChild() //添加 removeChild() //移除 replaceChild() //替换 insertBefore() //插入 查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值 getElementById() //通过元素Id，唯一性 69 正则表达式 正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？ 当使用RegExp()构造函数的时候，不仅需要转义引号（即\\”表示”），并且还需要双反斜杠（即\\\\表示一个\\）。使用正则表达字面量的效率更高 邮箱的正则匹配： var regMail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/; 70 Javascript中callee和caller的作用？ caller是返回一个对函数的引用，该函数调用了当前函数； callee是返回正在被执行的function函数，也就是所指定的function对象的正文 那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用callee完成） var result=[]; function fn(n){ //典型的斐波那契数列 if(n==1){ return 1; }else if(n==2){ return 1; }else{ if(result[n]){ return result[n]; }else{ //argument.callee()表示fn() result[n]=arguments.callee(n-1)+arguments.callee(n-2); return result[n]; } } } 71 window.onload和$(document).ready 原生JS的window.onload与Jquery的$(document).ready(function(){})有什么不同？如何用原生JS实现Jq的ready方法？ window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。 $(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕 function ready(fn){ if(document.addEventListener) { //标准浏览器 document.addEventListener('DOMContentLoaded', function() { //注销事件, 避免反复触发 document.removeEventListener('DOMContentLoaded',arguments.callee, false); fn(); //执行函数 }, false); }else if(document.attachEvent) { //IE document.attachEvent('onreadystatechange', function() { if(document.readyState == 'complete') { document.detachEvent('onreadystatechange', arguments.callee); fn(); //函数执行 } }); } }; 72 addEventListener()和attachEvent()的区别 addEventListener()是符合W3C规范的标准方法; attachEvent()是IE低版本的非标准方法 addEventListener()支持事件冒泡和事件捕获; - 而attachEvent()只支持事件冒泡 addEventListener()的第一个参数中,事件类型不需要添加on; attachEvent()需要添加&#39;on&#39; 如果为同一个元素绑定多个事件, addEventListener()会按照事件绑定的顺序依次执行, attachEvent()会按照事件绑定的顺序倒序执行 73 获取页面所有的checkboxvar resultArr= []; var input = document.querySelectorAll('input'); for( var i = 0; i &lt; input.length; i++ ) { if( input[i].type == 'checkbox' ) { resultArr.push( input[i] ); } } //resultArr即中获取到了页面中的所有checkbox 74 数组去重方法总结方法一、利\u001c用ES6 Set去重（ES6中最常用） function unique (arr) { return Array.from(new Set(arr)) } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {}, {}] 方法二、利用for嵌套for，然后splice去重（ES5中最常用） function unique(arr){ for(var i=0; i&lt;arr.length; i++){ for(var j=i+1; j&lt;arr.length; j++){ if(arr[i]==arr[j]){ //第一个等同于第二个，splice方法删除第二个 arr.splice(j,1); j--; } } } return arr; } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"true\", 15, false, undefined, NaN, NaN, \"NaN\", \"a\", {…}, {…}] //NaN和{}没有去重，两个null直接消失了 双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。 想快速学习更多常用的ES6语法 方法三、利用indexOf去重 function unique(arr) { if (!Array.isArray(arr)) { console.log('type error!') return } var array = []; for (var i = 0; i &lt; arr.length; i++) { if (array .indexOf(arr[i]) === -1) { array .push(arr[i]) } } return array; } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) // [1, \"true\", true, 15, false, undefined, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, {…}] //NaN、{}没有去重 新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组 方法四、利用sort() function unique(arr) { if (!Array.isArray(arr)) { console.log('type error!') return; } arr = arr.sort() var arrry= [arr[0]]; for (var i = 1; i &lt; arr.length; i++) { if (arr[i] !== arr[i-1]) { arrry.push(arr[i]); } } return arrry; } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) // [0, 1, 15, \"NaN\", NaN, NaN, {…}, {…}, \"a\", false, null, true, \"true\", undefined] //NaN、{}没有去重 利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对 方法五、利用对象的属性不能相同的特点进行去重 function unique(arr) { if (!Array.isArray(arr)) { console.log('type error!') return } var arrry= []; var obj = {}; for (var i = 0; i &lt; arr.length; i++) { if (!obj[arr[i]]) { arrry.push(arr[i]) obj[arr[i]] = 1 } else { obj[arr[i]]++ } } return arrry; } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"true\", 15, false, undefined, null, NaN, 0, \"a\", {…}] //两个true直接去掉了，NaN和{}去重 方法六、利用includes function unique(arr) { if (!Array.isArray(arr)) { console.log('type error!') return } var array =[]; for(var i = 0; i &lt; arr.length; i++) { if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值 array.push(arr[i]); } } return array } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}, {…}] //{}没有去重 方法七、利用hasOwnProperty function unique(arr) { var obj = {}; return arr.filter(function(item, index, arr){ return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) }) } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}] //所有的都去重了 利用hasOwnProperty 判断是否存在对象属性 方法八、利用filter function unique(arr) { return arr.filter(function(item, index, arr) { //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素 return arr.indexOf(item, 0) === index; }); } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"true\", true, 15, false, undefined, null, \"NaN\", 0, \"a\", {…}, {…}] 方法九、利用递归去重 function unique(arr) { var array= arr; var len = array.length; array.sort(function(a,b){ //排序后更加方便去重 return a - b; }) function loop(index){ if(index >= 1){ if(array[index] === array[index-1]){ array.splice(index,1); } loop(index - 1); //递归loop，然后数组去重 } } loop(len-1); return array; } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"a\", \"true\", true, 15, false, 1, {…}, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, undefined] 方法十、利用Map数据结构去重 function arrayNonRepeatfy(arr) { let map = new Map(); let array = new Array(); // 数组用于返回结果 for (let i = 0; i &lt; arr.length; i++) { if(map .has(arr[i])) { // 如果有该key值 map .set(arr[i], true); } else { map .set(arr[i], false); // 如果没有该key值 array .push(arr[i]); } } return array ; } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)) //[1, \"a\", \"true\", true, 15, false, 1, {…}, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, undefined] 创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果 方法十一、利用reduce+includes function unique(arr){ return arr.reduce((prev,cur) => prev.includes(cur) ? prev : [...prev,cur],[]); } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique(arr)); // [1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}, {…}] 方法十二、[…new Set(arr)] [...new Set(arr)] //代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码） 75 （设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS） 给需要拖拽的节点绑定mousedown, mousemove, mouseup事件 mousedown事件触发后，开始拖拽 mousemove时，需要通过event.clientX和clientY获取拖拽位置，并实时更新位置 mouseup时，拖拽结束 需要注意浏览器边界的情况 76 Javascript全局函数和全局变量全局变量 Infinity 代表正的无穷大的数值。 NaN 指示某个值是不是数字值。 undefined 指示未定义的值。 全局函数 decodeURI() 解码某个编码的 URI。 decodeURIComponent() 解码一个编码的 URI 组件。 `encodeURI() 把字符串编码为 URI。 encodeURIComponent() 把字符串编码为 URI 组件。 escape() 对字符串进行编码。 eval() 计算 JavaScript 字符串，并把它作为脚本代码来执行。 isFinite() 检查某个值是否为有穷大的数。 isNaN() 检查某个值是否是数字。 Number() 把对象的值转换为数字。 parseFloat() 解析一个字符串并返回一个浮点数。 parseInt() 解析一个字符串并返回一个整数。 String() 把对象的值转换为字符串。 unescape() 对由escape() 编码的字符串进行解码 77 使用js实现一个持续的动画效果定时器思路 var e = document.getElementById('e') var flag = true; var left = 0; setInterval(() => { left == 0 ? flag = true : left == 100 ? flag = false : '' flag ? e.style.left = ` ${left++}px` : e.style.left = ` ${left--}px` }, 1000 / 60) requestAnimationFrame //兼容性处理 window.requestAnimFrame = (function(){ return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback){ window.setTimeout(callback, 1000 / 60); }; })(); var e = document.getElementById(\"e\"); var flag = true; var left = 0; function render() { left == 0 ? flag = true : left == 100 ? flag = false : ''; flag ? e.style.left = ` ${left++}px` : e.style.left = ` ${left--}px`; } (function animloop() { render(); requestAnimFrame(animloop); })(); 使用css实现一个持续的动画效果 animation:mymove 5s infinite; @keyframes mymove { from {top:0px;} to {top:200px;} } animation-name规定需要绑定到选择器的 keyframe名称。 animation-duration规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function规定动画的速度曲线。 animation-delay规定在动画开始之前的延迟。 animation-iteration-count规定动画应该播放的次数。 animation-direction 规定是否应该轮流反向播放动画 78 封装一个函数，参数是定时器的时间，.then执行回调函数function sleep (time) { return new Promise((resolve) => setTimeout(resolve, time)); } 79 怎么判断两个对象相等？obj={ a:1, b:2 } obj2={ a:1, b:2 } obj3={ a:1, b:'2' } 可以转换为字符串来判断 JSON.stringify(obj)==JSON.stringify(obj2);//true JSON.stringify(obj)==JSON.stringify(obj3);//false 80 项目做过哪些性能优化？ 减少 HTTP` 请求数 减少 DNS 查询 使用 CDN 避免重定向 图片懒加载 减少 DOM 元素数量 减少DOM 操作 使用外部 JavaScript 和 CSS 压缩 JavaScript 、 CSS 、字体、图片等 优化 CSS Sprite 使用 iconfont 字体裁剪 多域名分发划分内容到不同域名 尽量减少 iframe 使用 避免图片 src 为空 把样式表放在link 中 把脚本放在页面底部 81 浏览器缓存 浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器； 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源； 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；区别是，强缓存不对发送请求到服务器，但协商缓存会。 当协商缓存也没命中时，服务器就会将资源发送回客户端。 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存； 当 f5刷新网页时，跳过强缓存，但是会检查协商缓存； 强缓存 Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间） Cache-Control:max-age（该字段是 http1.1的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒） 协商缓存 Last-Modified（值为资源最后更新时间，随服务器response返回） If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存） ETag（表示资源内容的唯一标识，随服务器response返回） If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存） 82 WebSocket 由于 http 存在一个明显的弊端（消息只能有客户端推送到服务器端，而服务器端不能主动推送到客户端），导致如果服务器如果有连续的变化，这时只能使用轮询，而轮询效率过低，并不适合。于是 WebSocket被发明出来 相比与 http 具有以下有点 支持双向通信，实时性更强； 可以发送文本，也可以二进制文件； 协议标识符是 ws，加密后是 wss ； 较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部； 支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等） 无跨域问题。 实现比较简单，服务端库如 socket.io、ws，可以很好的帮助我们入门。而客户端也只需要参照 api 实现即可 83 尽可能多的说出你对 Electron 的理解 最最重要的一点，electron 实际上是一个套了 Chrome 的 node程序 所以应该是从两个方面说开来 Chrome （无各种兼容性问题）； Node（Node 能做的它也能做） 84 深浅拷贝浅拷贝 Object.assign 或者展开运算符 深拷贝 可以通过 JSON.parse(JSON.stringify(object)) 来解决 let a = { age: 1, jobs: { first: 'FE' } } let b = JSON.parse(JSON.stringify(a)) a.jobs.first = 'native' console.log(b.jobs.first) // FE 该方法也是有局限性的 会忽略 undefined 不能序列化函数 不能解决循环引用的对象 85 防抖/节流防抖 在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。可以通过函数防抖动来实现 // 使用 underscore 的源码来解释防抖动 /** * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param {function} func 回调函数 * @param {number} wait 表示时间窗口的间隔 * @param {boolean} immediate 设置为ture时，是否立即调用函数 * @return {function} 返回客户调用函数 */ _.debounce = function(func, wait, immediate) { var timeout, args, context, timestamp, result; var later = function() { // 现在和上一次时间戳比较 var last = _.now() - timestamp; // 如果当前间隔时间少于设定时间且大于0就重新设置定时器 if (last &lt; wait &amp;&amp; last >= 0) { timeout = setTimeout(later, wait - last); } else { // 否则的话就是时间到了执行回调函数 timeout = null; if (!immediate) { result = func.apply(context, args); if (!timeout) context = args = null; } } }; return function() { context = this; args = arguments; // 获得时间戳 timestamp = _.now(); // 如果定时器不存在且立即执行函数 var callNow = immediate &amp;&amp; !timeout; // 如果定时器不存在就创建一个 if (!timeout) timeout = setTimeout(later, wait); if (callNow) { // 如果需要立即执行函数的话 通过 apply 执行 result = func.apply(context, args); context = args = null; } return result; }; }; 整体函数实现 对于按钮防点击来说的实现 开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了 对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数 节流 防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行 /** * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait * * @param {function} func 回调函数 * @param {number} wait 表示时间窗口的间隔 * @param {object} options 如果想忽略开始函数的的调用，传入{leading: false}。 * 如果想忽略结尾函数的调用，传入{trailing: false} * 两者不能共存，否则函数不能执行 * @return {function} 返回客户调用函数 */ _.throttle = function(func, wait, options) { var context, args, result; var timeout = null; // 之前的时间戳 var previous = 0; // 如果 options 没传则设为空对象 if (!options) options = {}; // 定时器回调函数 var later = function() { // 如果设置了 leading，就将 previous 设为 0 // 用于下面函数的第一个 if 判断 previous = options.leading === false ? 0 : _.now(); // 置空一是为了防止内存泄漏，二是为了下面的定时器判断 timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; }; return function() { // 获得当前时间戳 var now = _.now(); // 首次进入前者肯定为 true // 如果需要第一次不执行函数 // 就将上次时间戳设为当前的 // 这样在接下来计算 remaining 的值时会大于0 if (!previous &amp;&amp; options.leading === false) previous = now; // 计算剩余时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果当前调用已经大于上次调用时间 + wait // 或者用户手动调了时间 // 如果设置了 trailing，只会进入这个条件 // 如果没有设置 leading，那么第一次会进入这个条件 // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了 // 其实还是会进入的，因为定时器的延时 // 并不是准确的时间，很可能你设置了2秒 // 但是他需要2.2秒才触发，这时候就会进入这个条件 if (remaining &lt;= 0 || remaining > wait) { // 如果存在定时器就清理掉否则会调用二次回调 if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; result = func.apply(context, args); if (!timeout) context = args = null; } else if (!timeout &amp;&amp; options.trailing !== false) { // 判断是否设置了定时器和 trailing // 没有的话就开启一个定时器 // 并且不能不能同时设置 leading 和 trailing timeout = setTimeout(later, remaining); } return result; }; }; 86 谈谈变量提升？ 当执行 JS 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境 接下来让我们看一个老生常谈的例子，var b() // call b console.log(a) // undefined var a = 'Hello world' function b() { console.log('call b') } ::: tip 变量提升这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用::: 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升 b() // call b second function b() { console.log('call b fist') } function b() { console.log('call b second') } var b = 'Hello world' 复制代码var 会产生很多错误，所以在 ES6中引入了 let。let 不能在声明前使用，但是这并不是常说的 let 不会提升，let 提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用 87 什么是单线程，和异步的关系 单线程 - 只有一个线程，只能做一件事 原因 - 避免 DOM 渲染的冲突 浏览器需要渲染 DOM JS 可以修改 DOM 结构 JS 执行的时候，浏览器 DOM 渲染会暂停 两段 JS 也不能同时执行（都修改 DOM 就冲突了） webworker 支持多线程，但是不能访问 DOM 解决方案 - 异步 88 是否用过 jQuery 的 Deferred image.png image.png image.png image.png image.png image.png image.png image.png image.png image.png 89 前端面试之hybrid http://blog.poetries.top/2018/10/20/fe-interview-hybrid/ 90 前端面试之组件化 http://blog.poetries.top/2018/10/20/fe-interview-component/ 91 前端面试之MVVM浅析 http://blog.poetries.top/2018/10/20/fe-interview-mvvm/ 92 实现效果，点击容器内的图标，图标边框变成border 1px solid red，点击空白处重置const box = document.getElementById('box'); function isIcon(target) { return target.className.includes('icon'); } box.onClick = function(e) { e.stopPropagation(); const target = e.target; if (isIcon(target)) { target.style.border = '1px solid red'; } } const doc = document; doc.onclick = function(e) { const children = box.children; for(let i; i &lt; children.length; i++) { if (isIcon(children[i])) { children[i].style.border = 'none'; } } } 93 请简单实现双向数据绑定mvvm&lt;input id=&quot;input&quot;/&gt; const data = {}; const input = document.getElementById('input'); Object.defineProperty(data, 'text', { set(value) { input.value = value; this.value = value; } }); input.onChange = function(e) { data.text = e.target.value; } 94 实现Storage，使得该对象为单例，并对localStorage进行封装设置值setItem(key,value)和getItem(key)var instance = null; class Storage { static getInstance() { if (!instance) { instance = new Storage(); } return instance; } setItem = (key, value) => localStorage.setItem(key, value), getItem = key => localStorage.getItem(key) } 95 说说event loop 首先，js是单线程的，主要的任务是处理用户的交互，而用户的交互无非就是响应DOM的增删改，使用事件队列的形式，一次事件循环只处理一个事件响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件，那么事件队列的事件从哪里被push进来的呢。那就是另外一个线程叫事件触发线程做的事情了，他的作用主要是在定时触发器线程、异步HTTP请求线程满足特定条件下的回调函数push到事件队列中，等待js引擎空闲的时候去执行，当然js引擎执行过程中有优先级之分，首先js引擎在一次事件循环中，会先执行js线程的主任务，然后会去查找是否有微任务microtask（promise），如果有那就优先执行微任务，如果没有，在去查找宏任务macrotask（setTimeout、setInterval）进行执行 96 说说事件流事件流分为两种，捕获事件流和冒泡事件流 捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点 冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点 事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段 97 为什么canvas的图片为什么过有跨域问题98 我现在有一个canvas，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块 https://www.jianshu.com/p/f54d265f7aa4 99 请手写实现一个promise https://segmentfault.com/a/1190000013396601 100 说说从输入URL到看到页面发生的全过程，越详细越好 首先浏览器主进程接管，开了一个下载线程。 然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。 将下载完的内容转交给Renderer进程管理。 Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。 解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。 css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。 绘制结束后，关闭TCP连接，过程有四次挥手 101 描述一下this this，函数执行的上下文，可以通过apply，call，bind改变this的指向。对于匿名函数或者直接调用的函数来说，this指向全局上下文（浏览器为window，nodejs为global），剩下的函数调用，那就是谁调用它，this就指向谁。当然还有es6的箭头函数，箭头函数的指向取决于该箭头函数声明的位置，在哪里声明，this就指向哪里 102 说一下浏览器的缓存机制 浏览器缓存机制有两种，一种为强缓存，一种为协商缓存 对于强缓存，浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，直接使用缓存。 对于协商缓存，第一次请求缓存且保存缓存标识与时间，重复请求向服务器发送缓存标识和最后缓存时间，服务端进行校验，如果失效则使用缓存 协商缓存方 Exprires：服务端的响应头，第一次请求的时候，告诉客户端，该资源什么时候会过期。Exprires的缺陷是必须保证服务端时间和客户端时间严格同步。 Cache-control：max-age，表示该资源多少时间后过期，解决了客户端和服务端时间必须同步的问题， If-None-Match/ETag：缓存标识，对比缓存时使用它来标识一个缓存，第一次请求的时候，服务端会返回该标识给客户端，客户端在第二次请求的时候会带上该标识与服务端进行对比并返回If-None-Match标识是否表示匹配。 Last-modified/If-Modified-Since：第一次请求的时候服务端返回Last-modified表明请求的资源上次的修改时间，第二次请求的时候客户端带上请求头If-Modified-Since，表示资源上次的修改时间，服务端拿到这两个字段进行对比 103 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？ 该组件需要提供hook指定渲染位置，默认渲染在body下面。 然后改组件可以指定外层样式，如宽度等 组件外层还需要一层mask来遮住底层内容，点击mask可以执行传进来的onCancel函数关闭Dialog。 另外组件是可控的，需要外层传入visible表示是否可见。 然后Dialog可能需要自定义头head和底部footer，默认有头部和底部，底部有一个确认按钮和取消按钮，确认按钮会执行外部传进来的onOk事件，然后取消按钮会执行外部传进来的onCancel事件。 当组件的visible为true时候，设置body的overflow为hidden，隐藏body的滚动条，反之显示滚动条。 组件高度可能大于页面高度，组件内部需要滚动条。 只有组件的visible有变化且为ture时候，才重渲染组件内的所有内容 104 caller和callee的区别 caller返回一个函数的引用，这个函数调用了当前的函数。 使用这个属性要注意 这个属性只有当函数在执行时才有用 如果在javascript程序中，函数是由顶层调用的，则返回null functionName.caller: functionName是当前正在执行的函数。 function a() { console.log(a.caller) } callee callee放回正在执行的函数本身的引用，它是arguments的一个属性 使用callee时要注意: 这个属性只有在函数执行时才有效 它有一个length属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较arguments.length是否等于arguments.callee.length 它可以用来递归匿名函数。 function a() { console.log(arguments.callee) } 105 ajax、axios、fetch区别jQuery ajax $.ajax({ type: 'POST', url: url, data: data, dataType: dataType, success: function () {}, error: function () {} }); 优缺点： 本身是针对MVC的编程,不符合现在前端MVVM的浪潮 基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案 JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务） axios axios({ method: 'post', url: '/user/12345', data: { firstName: 'Fred', lastName: 'Flintstone' } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 优缺点： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止CSRF/XSRF fetch try { let response = await fetch(url); let data = response.json(); console.log(data); } catch(e) { console.log(\"Oops, error\", e); } 优缺点： fetcht只对网络请求报错，对400，500都当做成功的请求，需要封装去处理 fetch默认不会带cookie，需要添加配置项 fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费 fetch没有办法原生监测请求的进度，而XHR可以","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"基础篇","slug":"基础篇","permalink":"http://www.chenya.site/tags/基础篇/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenya.site/tags/JavaScript/"}]},{"title":"基础篇-02.CSS综合问题","slug":"002.前端知识体系/001.基础篇/002.基础篇之CSS综合问题","date":"2016-05-26T10:08:31.000Z","updated":"2019-09-16T01:57:01.487Z","comments":true,"path":"2016/05/26/002.前端知识体系/001.基础篇/002.基础篇之CSS综合问题/","link":"","permalink":"http://www.chenya.site/2016/05/26/002.前端知识体系/001.基础篇/002.基础篇之CSS综合问题/","excerpt":"","text":"二、CSS部分1 css sprite是什么,有什么优缺点 概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。 优点： 减少HTTP请求数，极大地提高页面加载速度 增加图片信息重复度，提高压缩比，减少图片大小 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现 缺点： 图片合并麻烦 维护麻烦，修改一个图片可能需要从新布局整个图片，样式 2 display: none;与visibility: hidden;的区别 联系：它们都能让元素不可见 区别： display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见 display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。 读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容 3 link与@import的区别 link是HTML方式， @import是CSS方式 link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC link可以通过rel=&quot;alternate stylesheet&quot;指定候选样式 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式 @import必须在样式规则之前，可以在css文件中引用其他文件 总体来说：link优于@import 4 什么是FOUC?如何避免 Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。 解决方法：把样式表放到文档的head 5 如何创建块级格式化上下文(block formatting context),BFC有什么用 创建规则： 根元素 浮动元素（float不是none） 绝对定位元素（position取值为absolute或fixed） display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素 overflow不是visible的元素 作用： 可以包含浮动元素 不被浮动元素覆盖 阻止父子元素的margin折叠 6 display,float,position的关系 如果display为none，那么position和float都不起作用，这种情况下元素不产生框 否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。 否则，如果float不是none，框是浮动的，display根据下表进行调整 否则，如果元素是根元素，display根据下表进行调整 其他情况下display的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整display 7 清除浮动的几种方式，各自的优缺点 父级div定义height 结尾处加空div标签clear:both 父级div定义伪类:after和zoom 父级div定义overflow:hidden 父级div也浮动，需要定义宽度 结尾处加br标签clear:both 比较好的是第3种方式，好多网站都这么用 8 为什么要初始化CSS样式? 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化 9 css3有哪些新特性 新增各种css选择器 圆角 border-radius 多列布局 阴影和反射 文字特效text-shadow 线性渐变 旋转transform CSS3新增伪类有那些？ p:first-of-type 选择属于其父元素的首个&lt;p&gt;元素的每个&lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个&lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt;元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :after 在元素之前添加内容,也可以用来做清除浮动。 :before 在元素之后添加内容 :enabled :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中 10 display有哪些值？说明他们的作用 block 象块类型元素一样显示。 none 缺省值。象行内元素类型一样显示。 inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示 inherit 规定应该从父元素继承 display 属性的值 11 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ 有两种， IE盒子模型、W3C盒子模型； 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)； 区 别： IE的content部分把 border 和 padding计算了进去; 12 CSS优先级算法如何计算？ 优先级就近原则，同权重情况下样式定义最近者为准 载入样式以最后载入的定位为准 优先级为: !important &gt; id &gt; class &gt; tag important 比 内联优先级高 13 对BFC规范的理解？ 它决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用 14 谈谈浮动和清除浮动 浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上 15 position的值， relative和absolute定位原点是 absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位 fixed：生成绝对定位的元素，相对于浏览器窗口进行定位 relative：生成相对定位的元素，相对于其正常位置进行定位 static 默认值。没有定位，元素出现在正常的流中 inherit 规定从父元素继承 position 属性的值 16 display:inline-block 什么时候不会显示间隙？(携程) 移除空格 使用margin负值 使用font-size:0 letter-spacing word-spacing 17 PNG,GIF,JPG的区别及如何选 GIF 8位像素，256色 无损压缩 支持简单动画 支持boolean透明 适合简单动画 JPEG 颜色限于256 有损压缩 可控制压缩质量 不支持透明 适合照片 PNG 有PNG8和truecolor PNG PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画 适合图标、背景、按钮 18 行内元素float:left后是否变为块级元素？ 浮动后，行内元素不会成为块状元素，但是可以设置宽高。行内元素要想变成块状元素，占一行，直接设置display:block;。但如果元素设置了浮动后再设置display:block;那就不会占一行。 19 在网页中的应该使用奇数还是偶数的字体？为什么呢？ 偶数字号相对更容易和 web 设计的其他部分构成比例关系 20 ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素 用于区分伪类和伪元素 21 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms 22 CSS合并方法 避免使用@import引入多个css文件，可以使用CSS工具将CSS合并为一个CSS文件，例如使用Sass\\Compass等 23 CSS不同选择器的权重(CSS层叠的规则) ！important规则最重要，大于其它规则 行内样式规则，加1000 对于选择器中给定的各个ID属性值，加100 对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加10 对于选择其中给定的各个元素标签选择器，加1 如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则 24 列出你所知道可以改变页面布局的属性 position、display、float、width、height、margin、padding、top、left、right、` 25 CSS在性能优化方面的实践 css压缩与合并、Gzip压缩 css文件放在head里、不要用@import 尽量用缩写、避免用滤镜、合理使用选择器 26 CSS3动画（简单动画的实现，如旋转等） 依靠CSS3中提出的三个属性：transition、transform、animation transition：定义了元素在变化过程中是怎么样的，包含transition-property、transition-duration、transition-timing-function、transition-delay。 transform：定义元素的变化结果，包含rotate、scale、skew、translate。 animation：动画定义了动作的每一帧（@keyframes）有什么效果，包括animation-name，animation-duration、animation-timing-function、animation-delay、animation-iteration-count、animation-direction 27 base64的原理及优缺点 优点可以加密，减少了http请求 缺点是需要消耗CPU进行编解码 28 几种常见的CSS布局流体布局.left { float: left; width: 100px; height: 200px; background: red; } .right { float: right; width: 200px; height: 200px; background: blue; } .main { margin-left: 120px; margin-right: 220px; height: 200px; background: green; } &lt;div class=\"container\"> &lt;div class=\"left\">&lt;/div> &lt;div class=\"right\">&lt;/div> &lt;div class=\"main\">&lt;/div> &lt;/div> 圣杯布局.container { margin-left: 120px; margin-right: 220px; } .main { float: left; width: 100%; height:300px; background: green; } .left { position: relative; left: -120px; float: left; height: 300px; width: 100px; margin-left: -100%; background: red; } .right { position: relative; right: -220px; float: right; height: 300px; width: 200px; margin-left: -200px; background: blue; } &lt;div class=\"container\"> &lt;div class=\"main\">&lt;/div> &lt;div class=\"left\">&lt;/div> &lt;div class=\"right\">&lt;/div> &lt;/div> 双飞翼布局 .content { float: left; width: 100%; } .main { height: 200px; margin-left: 110px; margin-right: 220px; background: green; } .main::after { content: ''; display: block; font-size:0; height: 0; zoom: 1; clear: both; } .left { float:left; height: 200px; width: 100px; margin-left: -100%; background: red; } .right { float: right; height: 200px; width: 200px; margin-left: -200px; background: blue; } &lt;div class=\"content\"> &lt;div class=\"main\">&lt;/div> &lt;/div> &lt;div class=\"left\">&lt;/div> &lt;div class=\"right\">&lt;/div> 29 stylus/sass/less区别 均具有“变量”、“混合”、“嵌套”、“继承”、“颜色混合”五大基本特性 Scss和LESS语法较为严谨，LESS要求一定要使用大括号“{}”，Scss和Stylus可以通过缩进表示层次与嵌套关系 Scss无全局变量的概念，LESS和Stylus有类似于其它语言的作用域概念 Sass是基于Ruby语言的，而LESS和Stylus可以基于NodeJS NPM下载相应库后进行编译； 30 postcss的作用 可以直观的理解为：它就是一个平台。为什么说它是一个平台呢？因为我们直接用它，感觉不能干什么事情，但是如果让一些插件在它上面跑，那么将会很强大 PostCSS 提供了一个解析器，它能够将 CSS 解析成抽象语法树 通过在 PostCSS 这个平台上，我们能够开发一些插件，来处理我们的CSS，比如热门的：autoprefixer postcss可以对sass处理过后的css再处理 最常见的就是autoprefixer 31 css样式（选择器）的优先级 计算权重确定 !important 内联样式 后写的优先级高 32 自定义字体的使用场景 宣传/品牌/banner等固定文案 字体图标 33 如何美化CheckBox label（for） 和id 隐藏原生的 input :checked + label 34 伪类和伪元素的区别 伪类表状态 伪元素是真的有元素 前者单冒号，后者双冒号 35 base64的使用 用于减少 HTTP 请求 适用于小图片 base64的体积约为原图的4/3 36 自适应布局思路： 左侧浮动或者绝对定位，然后右侧margin撑开 使用div包含，然后靠负margin形成bfc 使用flex 37 请用Css写一个简单的幻灯片效果页面 知道是要用css3。使用animation动画实现一个简单的幻灯片效果 /**css**/ .ani{ width:480px; height:320px; margin:50px auto; overflow: hidden; box-shadow:0 0 5px rgba(0,0,0,1); background-size: cover; background-position: center; -webkit-animation-name: \"loops\"; -webkit-animation-duration: 20s; -webkit-animation-iteration-count: infinite; } @-webkit-keyframes \"loops\" { 0% { background:url(http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg) no-repeat; } 25% { background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg) no-repeat; } 50% { background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg) no-repeat; } 75% { background:url(http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg) no-repeat; } 100% { background:url(http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg) no-repeat; } } 38 什么是外边距重叠？重叠的结果是什么？ 外边距重叠就是margin-collapse 在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠结果遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 39 rgba()和opacity的透明效果有什么不同？ rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度， 而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！） 40 css中可以让文字在垂直和水平方向上重叠的两个属性是什么？ 垂直方向：line-height 水平方向：letter-spacing 41 如何垂直居中一个浮动元素？/**方法一：已知元素的高宽**/ #div1{ background-color:#6699FF; width:200px; height:200px; position: absolute; //父元素需要相对定位 top: 50%; left: 50%; margin-top:-100px ; //二分之一的height，width margin-left: -100px; } /**方法二:**/ #div1{ width: 200px; height: 200px; background-color: #6699FF; margin:auto; position: absolute; //父元素需要相对定位 left: 0; top: 0; right: 0; bottom: 0; } 如何垂直居中一个&lt;img&gt;?（用更简便的方法。） #container /**&lt;img>的容器设置如下**/ { display:table-cell; text-align:center; vertical-align:middle; } 42 px和em的区别 px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。 浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。 43 Sass、LESS是什么？大家为什么要使用他们？ 他们是CSS预处理器。他是CSS上的一种抽象层。他们是一种特殊的语法/语言编译成CSS。 例如Less是一种动态样式语言. 将CSS赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js) 为什么要使用它们？ 结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对- 浏览器语法差异的重复处理，减少无意义的机械劳动。 可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只- 是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译 44 知道css有个content属性吗？有什么作用？有什么应用？ css的content属性专门应用在 before/after伪元素上，用于来插入生成内容。最常见的应用是利用伪类清除浮动。 /**一种常见利用伪类清除浮动的代码**/ .clearfix:after { content:\".\"; //这里利用到了content属性 display:block; height:0; visibility:hidden; clear:both; } .clearfix { *zoom:1; } 45 水平居中的方法 元素为行内元素，设置父元素text-align:center 如果元素宽度固定，可以设置左右margin为auto; 如果元素为绝对定位，设置父元素position为relative，元素设left:0;right:0;margin:auto; 使用flex-box布局，指定justify-content属性为center display设置为tabel-ceil 46 垂直居中的方法 将显示方式设置为表格，display:table-cell,同时设置vertial-align：middle 使用flex布局，设置为align-item：center 绝对定位中设置bottom:0,top:0,并设置margin:auto 绝对定位中固定高度时设置top:50%，margin-top值为高度一半的负值 文本垂直居中设置line-height为height值 47 如何使用CSS实现硬件加速？ 硬件加速是指通过创建独立的复合图层，让GPU来渲染这个图层，从而提高性能， 一般触发硬件加速的CSS属性有transform、opacity、filter，为了避免2D动画在开始和结束的时候的repaint操作，一般使用tranform:translateZ(0) 48 重绘和回流（重排）是什么，如何避免？ DOM的变化影响到了元素的几何属性（宽高）,浏览器重新计算元素的几何属性，其他元素的几何 属性和位置也会受到影响，浏览器需要重新构造渲染树，这个过程称为重排，浏览器将受到影响的部分 重新绘制到屏幕上的过程称为重绘。引起重排的原因有 添加或者删除可见的DOM元素， 元素位置、尺寸、内容改变， 浏览器页面初始化， 浏览器窗口尺寸改变，重排一定重绘，重绘不一定重排， 减少重绘和重排的方法： 不在布局信息改变时做DOM查询 使用cssText或者className一次性改变属性 使用fragment 对于多次重排的元素，如动画，使用绝对定位脱离文档流，让他的改变不影响到其他元素 49 说一说css3的animation css3的animation是css3新增的动画属性，这个css3动画的每一帧是通过@keyframes来声明的，keyframes声明了动画的名称，通过from、to或者是百分比来定义 每一帧动画元素的状态，通过animation-name来引用这个动画，同时css3动画也可以定义动画运行的时长、动画开始时间、动画播放方向、动画循环次数、动画播放的方式， 这些相关的动画子属性有：animation-name定义动画名、animation-duration定义动画播放的时长、animation-delay定义动画延迟播放的时间、animation-direction定义动画的播放方向、animation-iteration-count定义播放次数、animation-fill-mode定义动画播放之后的状态、animation-play-state定义播放状态，如暂停运行等、animation-timing-function 定义播放的方式，如恒速播放、艰涩播放等。 50 左边宽度固定，右边自适应 左侧固定宽度，右侧自适应宽度的两列布局实现 html结构 &lt;div class=\"outer\"> &lt;div class=\"left\">固定宽度&lt;/div> &lt;div class=\"right\">自适应宽度&lt;/div> &lt;/div> 在外层div（类名为outer）的div中，有两个子div，类名分别为left和right，其中left为固定宽度，而right为自适应宽度 方法1：左侧div设置成浮动：float: left，右侧div宽度会自拉升适应 .outer { width: 100%; height: 500px; background-color: yellow; } .left { width: 200px; height: 200px; background-color: red; float: left; } .right { height: 200px; background-color: blue; } 方法2：对右侧:div进行绝对定位，然后再设置right=0，即可以实现宽度自适应 绝对定位元素的第一个高级特性就是其具有自动伸缩的功能，当我们将 width设置为 auto 的时候（或者不设置，默认为 auto ），绝对定位元素会根据其 left 和 right 自动伸缩其大小 .outer { width: 100%; height: 500px; background-color: yellow; position: relative; } .left { width: 200px; height: 200px; background-color: red; } .right { height: 200px; background-color: blue; position: absolute; left: 200px; top:0; right: 0; } 方法3：将左侧div进行绝对定位，然后右侧div设置margin-left: 200px .outer { width: 100%; height: 500px; background-color: yellow; position: relative; } .left { width: 200px; height: 200px; background-color: red; position: absolute; } .right { height: 200px; background-color: blue; margin-left: 200px; } 方法4：使用flex布局 .outer { width: 100%; height: 500px; background-color: yellow; display: flex; flex-direction: row; } .left { width: 200px; height: 200px; background-color: red; } .right { height: 200px; background-color: blue; flex: 1; } 51 两种以上方式实现已知或者未知宽度的垂直水平居中// 1 .wraper { position: relative; .box { position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; margin: -50px 0 0 -50px; } } // 2 .wraper { position: relative; .box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } } // 3 .wraper { .box { display: flex; justify-content:center; align-items: center; height: 100px; } } // 4 .wraper { display: table; .box { display: table-cell; vertical-align: middle; } } 52 如何实现小于12px的字体效果 transform:scale()这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个display:inline-block; transform: scale(0.7); css的属性，可以缩放大小","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"基础篇","slug":"基础篇","permalink":"http://www.chenya.site/tags/基础篇/"},{"name":"CSS","slug":"CSS","permalink":"http://www.chenya.site/tags/CSS/"}]},{"title":"基础篇-01.HTML、HTTP、web综合问题","slug":"002.前端知识体系/001.基础篇/001.基础篇之HTML、HTTP、web综合问题","date":"2016-05-21T09:56:11.000Z","updated":"2019-09-16T01:57:01.486Z","comments":true,"path":"2016/05/21/002.前端知识体系/001.基础篇/001.基础篇之HTML、HTTP、web综合问题/","link":"","permalink":"http://www.chenya.site/2016/05/21/002.前端知识体系/001.基础篇/001.基础篇之HTML、HTTP、web综合问题/","excerpt":"","text":"第一部分：基础篇 面试经验谈--来自知乎芋头Live 一、HTML、HTTP、web综合问题1 前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 2 &lt;img&gt;的title和alt有什么区别 通常当鼠标滑动到元素上的时候显示 alt是&lt;img&gt;的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 3 HTTP的几种请求方法用途 GET方法 发送一个请求来取得服务器上的某一资源 POST方法 向URL指定的资源提交数据或附加新的数据 PUT方法 跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST没有 HEAD方法 只请求页面的首部 DELETE方法 删除服务器上的某资源 OPTIONS方法 它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息 TRACE方法 TRACE方法被用于激发一个远程的，应用层的请求消息回路 CONNECT方法 把请求连接转换到透明的TCP/IP通道 4 从浏览器地址栏输入url到显示页面的步骤基础版本 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。 详细版 在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树： Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树: 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 js解析如下： 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件 显示页面（HTML解析过程中会逐步显示页面） 详细简版 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系） 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识） 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等） 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等） 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等） 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等） CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念） JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等） 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容） 5 如何进行网站性能优化 content方面 减少HTTP请求：合并文件、CSS精灵、inline Image 减少DNS查询：DNS缓存、将资源分布到恰当数量的主机名 减少DOM元素数量 Server方面 使用CDN 配置ETag 对组件使用Gzip压缩 Cookie方面 减小cookie大小 css方面 将样式表放到页面顶部 不使用CSS表达式 使用&lt;link&gt;不使用@import Javascript方面 将脚本放到页面底部 将javascript和css从外部引入 压缩javascript和css 删除不需要的脚本 减少DOM访问 图片方面 优化图片：根据实际颜色需要选择色深、压缩 优化css精灵 不要在HTML中拉伸图片 6 HTTP状态码及其含义 1XX：信息状态码 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 2XX：成功状态码 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 3XX：重定向 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 4XX：客户端错误 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 5XX: 服务器错误 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 7 语义化的理解 用正确的标签做正确的事情！ html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析； 在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 8 介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核 JS引擎则：解析和执行javascript来实现网页的动态效果 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎 9 html5有哪些新特性、移除了那些元素？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加 绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失 sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker, websocket, Geolocation 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u 对可用性产生负面影响的元素：frame，frameset，noframes 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签 可以利用这一特性让这些浏览器支持HTML5新标签 浏览器支持新标签后，还需要添加标签默认的样式 当然也可以直接使用成熟的框架、比如html5shim 10 HTML5的离线储存怎么使用，工作原理能不能解释一下？ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示 如何使用： 页面头部像下面一样加入一个manifest的属性； 在cache.manifest文件的编写离线存储的资源 在离线状态时，操作window.applicationCache进行需求实现 CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html 11 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。 12 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密） cookie数据始终在同源的http请求中携带（即使不需要），会在浏览器和服务器间来回传递 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存 存储大小： cookie数据大小不能超过4k sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 过期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 13 iframe有那些缺点？ iframe会阻塞主页面的Onload事件 搜索引擎的检索程序无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题 14 WEB标准以及W3C标准是什么? 标签闭合、标签小写、不乱嵌套、使用外链css和js、结构行为表现的分离 15 xhtml和html有什么区别? 一个是功能上的差别 主要是XHTML可兼容各大浏览器、手机以及PDA，并且浏览器也能快速正确地编译网页 另外是书写习惯的差别 XHTML 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素 16 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义? 页面被加载的时，link会同时被加载，而@imort页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载import只在IE5以上才能识别，而link是XHTML标签，无兼容问题link方式的样式的权重 高于@import的权重 &lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现 17 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？ 行内元素有：a b span img input select strong 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p 空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; 行内元素不可以设置宽高，不独占一行 块级元素可以设置宽高，独占一行 18 HTML全局属性(global attribute)有哪些 class:为元素设置类标识 data-*: 为元素增加自定义属性 draggable: 设置元素是否可拖拽 id: 元素id，文档内唯一 lang: 元素内容的的语言 style: 行内css样式 title: 元素相关的建议信息 19 Canvas和SVG有什么区别？ svg绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。canvas输出的是一整幅画布 svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会是真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿 20 HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt; HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型 21 如何在页面上实现一个圆形的可点击区域？ svg border-radius 纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 22 网页验证码是干嘛的，是为了解决什么安全问题 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试 23 viewport &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /> // width 设置viewport宽度，为一个正整数，或字符串‘device-width’ // device-width 设备宽度 // height 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置 // initial-scale 默认缩放比例（初始缩放比例），为一个数字，可以带小数 // minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数 // maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数 // user-scalable 是否允许手动缩放 延伸提问 怎样处理 移动端 1px 被 渲染成 2px问题 局部处理 mate标签中的 viewport属性 ，initial-scale 设置为 1 rem按照设计稿标准走，外加利用transfrome 的scale(0.5) 缩小一倍即可； 全局处理 mate标签中的 viewport属性 ，initial-scale 设置为 0.5 rem 按照设计稿标准走即可 24 渲染优化 禁止使用iframe（阻塞父文档onload事件） iframe会阻塞主页面的Onload事件 搜索引擎的检索程序无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript 动态给iframe添加src属性值，这样可以绕开以上两个问题 禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能） 使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流） 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU 小图标优势在于 减少HTTP请求 避免文件跨域 修改及时生效 页面头部的&lt;style&gt;&lt;/style&gt; &lt;script&lt;/script&gt; 会阻塞页面；（因为 Renderer进程中 JS线程和渲染线程是互斥的） 页面中空的 href 和 src 会阻塞页面其他资源的加载 (阻塞下载进程) 网页Gzip，CDN托管，data缓存 ，图片服务器 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能 当需要设置的样式很多时设置className而不是直接操作style 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO 25 meta viewport相关&lt;!DOCTYPE html> &lt;!--H5标准声明，使用 HTML5 doctype，不区分大小写--> &lt;head lang=”en”> &lt;!--标准的 lang 属性写法--> &lt;meta charset=’utf-8′> &lt;!--声明文档使用的字符编码--> &lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/> &lt;!--优先使用 IE 最新版本和 Chrome--> &lt;meta name=”description” content=”不超过150个字符”/> &lt;!--页面描述--> &lt;meta name=”keywords” content=””/> &lt;!-- 页面关键词--> &lt;meta name=”author” content=”name, email@gmail.com”/> &lt;!--网页作者--> &lt;meta name=”robots” content=”index,follow”/> &lt;!--搜索引擎抓取--> &lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”> &lt;!--为移动设备添加 viewport--> &lt;meta name=”apple-mobile-web-app-title” content=”标题”> &lt;!--iOS 设备 begin--> &lt;meta name=”apple-mobile-web-app-capable” content=”yes”/> &lt;!--添加到主屏后的标题（iOS 6 新增） 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--> &lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”> &lt;!--添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）--> &lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/> &lt;meta name=”format-detection” content=”telphone=no, email=no”/> &lt;!--设置苹果工具栏颜色--> &lt;meta name=”renderer” content=”webkit”> &lt;!-- 启用360浏览器的极速模式(webkit)--> &lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”> &lt;!--避免IE使用兼容模式--> &lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /> &lt;!--不让百度转码--> &lt;meta name=”HandheldFriendly” content=”true”> &lt;!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓--> &lt;meta name=”MobileOptimized” content=”320″> &lt;!--微软的老式浏览器--> &lt;meta name=”screen-orientation” content=”portrait”> &lt;!--uc强制竖屏--> &lt;meta name=”x5-orientation” content=”portrait”> &lt;!--QQ强制竖屏--> &lt;meta name=”full-screen” content=”yes”> &lt;!--UC强制全屏--> &lt;meta name=”x5-fullscreen” content=”true”> &lt;!--QQ强制全屏--> &lt;meta name=”browsermode” content=”application”> &lt;!--UC应用模式--> &lt;meta name=”x5-page-mode” content=”app”> &lt;!-- QQ应用模式--> &lt;meta name=”msapplication-tap-highlight” content=”no”> &lt;!--windows phone 点击无高光 设置页面不缓存--> &lt;meta http-equiv=”pragma” content=”no-cache”> &lt;meta http-equiv=”cache-control” content=”no-cache”> &lt;meta http-equiv=”expires” content=”0″> 26 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么? IE: trident内核 Firefox：gecko内核 Safari:webkit内核 Opera:以前是presto内核，Opera现已改用Google - Chrome的Blink内核 Chrome:Blink(基于webkit，Google与Opera Software共同开发) 27 div+css的布局较table布局有什么优点？ 改版的时候更方便 只要改css文件。 页面加载速度更快、结构化清晰、页面显示简洁。 表现与结构相分离。 易于优化（seo）搜索引擎更友好，排名更容易靠前。 28 a：img的alt与title有何异同？b：strong与em的异同？ alt(alt text):为不能显示图像、窗体或applets的用户代理（UA），alt属性用来指定替换文字。替换文字的语言由lang属性指定。(在IE浏览器下会在没有title时把alt当成 tool tip显示) title(tool tip):该属性为设置该属性的元素提供建议性的信息 strong:粗体强调标签，强调，表示内容的重要性 em:斜体强调标签，更强烈强调，表示内容的强调点 29 你能描述一下渐进增强和优雅降级之间的不同吗 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带 30 为什么利用多个域名来存储网站资源会更有效？ CDN缓存更方便 突破浏览器并发限制 节约cookie带宽 节约主域名的连接数，优化页面响应速度 防止不必要的安全问题 31 简述一下src与href的区别 src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。 src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素 &lt;script src =&quot;js.js&quot;&gt;&lt;/script&gt; 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部 href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加 &lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;/&gt;那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式 32 知道的网页制作会用到的图片格式有哪些？ png-8，png-24，jpeg，gif，svg 但是上面的那些都不是面试官想要的最后答案。面试官希望听到是Webp,Apng。（是否有关注新技术，新鲜事物） Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。 在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%。 Apng：全称是“Animated Portable Network Graphics”, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 iOS safari 8的支持，有望代替GIF成为下一代动态图标准 33 在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？ dns缓存，cdn缓存，浏览器缓存，服务器缓存 33 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。 图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。 如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。 34 常见排序算法的时间复杂度,空间复杂度 35 web开发中会话跟踪的方法有哪些 cookie session url重写 隐藏input ip地址 36 HTTP request报文结构是怎样的 首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF 首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束 请求头和消息实体之间有一个CRLF分隔 根据实际请求需要可能包含一个消息实体一个请求报文例子如下： GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1 Host: www.w3.org Connection: keep-alive Cache-Control: max-age=0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36 Referer: https://www.google.com.hk/ Accept-Encoding: gzip,deflate,sdch Accept-Language: zh-CN,zh;q=0.8,en;q=0.6 Cookie: authorstyle=yes If-None-Match: &quot;2cc8-3e3073913b100&quot; If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT name=qiu&amp;age=25 37 HTTP response报文结构是怎样的 首行是状态行包括：HTTP版本，状态码，状态描述，后面跟一个CRLF 首行之后是若干行响应头，包括：通用头部，响应头部，实体头部 响应头部和响应实体之间用一个CRLF空行分隔 最后是一个可能的消息实体响应报文例子如下： HTTP/1.1 200 OK Date: Tue, 08 Jul 2014 05:28:43 GMT Server: Apache/2 Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT ETag: &quot;40d7-3e3073913b100&quot; Accept-Ranges: bytes Content-Length: 16599 Cache-Control: max-age=21600 Expires: Tue, 08 Jul 2014 11:28:43 GMT P3P: policyref=&quot;http://www.w3.org/2001/05/P3P/p3p.xml&quot; Content-Type: text/html; charset=iso-8859-1 {&quot;name&quot;: &quot;qiu&quot;, &quot;age&quot;: 25}","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://www.chenya.site/categories/学习笔记/"}],"tags":[{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://www.chenya.site/tags/前端知识体系/"},{"name":"基础篇","slug":"基础篇","permalink":"http://www.chenya.site/tags/基础篇/"},{"name":"HTML","slug":"HTML","permalink":"http://www.chenya.site/tags/HTML/"}]},{"title":"Markdown基本语法","slug":"Markdown基本语法","date":"2016-01-08T10:23:59.000Z","updated":"2019-09-16T01:57:01.508Z","comments":true,"path":"2016/01/08/Markdown基本语法/","link":"","permalink":"http://www.chenya.site/2016/01/08/Markdown基本语法/","excerpt":"","text":"一、标题示例： # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题二、字体示例： **这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 效果如下：这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三、引用示例： &gt;这是引用的内容 &gt;&gt;这是引用的内容 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： --- ---- *** ***** 五、图片 语法：![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： Markdown 六、超链接语法：[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 简书百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 &lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt; 示例简书 七、列表 语法： - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格 无序列表语法：无序列表用 - + * 任何一种都可以 效果如下： - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 有序列表语法：数字加点 1.列表内容 2.列表内容 3.列表内容 注意：序号跟内容之间要有空格 1.列表内容2.列表内容3.列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 * 一级无序列表内容 * 二级无序列表内容 * 二级无序列表内容 * 二级无序列表内容 * 一级无序列表内容 1.二级有序列表内容 2.二级有序列表内容 3.二级有序列表内容 1.一级有序列表内容 * 二级无序列表内容 * 二级无序列表内容 * 二级无序列表内容 2.一级有序列表内容 1.二级有序列表内容 2.二级有序列表内容 3.二级有序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 1.二级有序列表内容 2.二级有序列表内容 3.二级有序列表内容 1.一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 2.一级有序列表内容 1.二级有序列表内容 2.二级有序列表内容 3.二级有序列表内容 八、表格 语法： 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 示例： 姓名|技能|排行 --|:--:|--: 刘备|哭|大哥 关羽|打|二哥 张飞|骂|三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码 语法： 单行代码：代码之间分别用一个反引号包起来 `代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 create database hero; js代码块 const Koa = require('koa') const app = new Koa() html代码块 &lt;!doctype html> &lt;script src=\"lib/xmd.js\">&lt;/script> &lt;!-- 模块化框架 --> &lt;script> //等待构建工具生成数据替换 `__FRAMEWORK_CONFIG__' 变量 require.config(__FRAMEWORK_CONFIG__); &lt;/script> &lt;script> //用户代码，异步加载模块 require.async(['a', 'e'], function(a, e){ //do something with a and e. }); &lt;/script> 十、工程目录 project ├ lib │ └ xmd.js #模块化框架 ├ mods #模块目录 │ ├ a.js │ ├ b.js │ ├ c.js │ ├ d.js │ └ e.js └ index.html #入口页面","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.chenya.site/categories/随笔/"}],"tags":[{"name":"前端工程","slug":"前端工程","permalink":"http://www.chenya.site/tags/前端工程/"}]}]}